<?xml version="1.0" encoding="US-ASCII"?>
<!-- edited with XMLSPY v5 rel. 3 U (http://www.xmlspy.com)
     by Daniel M Kohn (private) -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY rfc2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC3344 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3344.xml">
<!ENTITY RFC3775 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3775.xml">
<!ENTITY RFC4225 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4225.xml">
<!ENTITY RFC4866 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4866.xml">
<!ENTITY RFC5213 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5213.xml">
<!ENTITY RFC3588 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3588.xml">
<!ENTITY RFC4005 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4005.xml">
<!ENTITY RFC4006 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4006.xml">
<!ENTITY RFC4601 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4601.xml">
<!ENTITY RFC4605 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4605.xml">
<!ENTITY RFC6224 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6224.xml">
<!ENTITY RFC7333 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7333.xml">
<!ENTITY RFC7429 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7429.xml">
<!ENTITY RFC6088 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6088.xml">
<!ENTITY RFC7222 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7222.xml">
<!ENTITY I-D.ietf-dmm-requirements PUBLIC "" "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-dmm-requirements.xml">
]>
<rfc category="std" docName="draft-ietf-dmm-fpc-cpdp-04.txt"
     ipr="trust200902">
  <?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

  <?rfc toc="yes" ?>

  <?rfc symrefs="yes" ?>

  <?rfc sortrefs="yes"?>

  <?rfc iprnotified="no" ?>

  <?rfc strict="yes" ?>

  <front>
    <title abbrev="DMM FPC Protocol">Protocol for Forwarding Policy Configuration (FPC) in DMM</title>

    <author fullname="Marco Liebsch" initials="M." surname="Liebsch">
      <organization abbrev="NEC">NEC Laboratories Europe</organization>

      <address>
        <postal>
          <street>NEC Europe Ltd.</street>

          <street>Kurfuersten-Anlage 36</street>

          <city>D-69115 Heidelberg</city>

          <region></region>

          <code></code>

          <country>Germany</country>
        </postal>

        <phone>+49 6221 4342146</phone>

        <email>liebsch@neclab.eu</email>
      </address>
    </author>

 <author fullname="Satoru Matsushima" initials="S." surname="Matsushima">
      <organization abbrev="SoftBank">SoftBank</organization>

      <address>
        <postal>

          <street>1-9-1,Higashi-Shimbashi,Minato-Ku</street>

          <city>Tokyo  105-7322</city>

          <region></region>

          <code></code>

          <country>Japan</country>
        </postal>

        <phone></phone>

        <email>satoru.matsushima@g.softbank.co.jp</email>
      </address>
    </author>

   <author fullname="Sri Gundavelli" initials="S" surname="Gundavelli">
      <organization abbrev="">Cisco</organization>

      <address>
        <postal>
          <street>170 West Tasman Drive</street>

          <city>San Jose</city>

          <region>CA</region>

          <code>95134</code>

          <country>USA</country>
        </postal>

        <email>sgundave@cisco.com</email>
      </address>
    </author>



<author initials="D." surname="Moses" fullname="Danny Moses">
<organization abbrev="Intel Corporation"></organization>
<address>
<postal>
          <street></street>

          <city></city>

          <region></region>

          <code></code>

          <country></country>
        </postal>

        <phone></phone>

        <email>danny.moses@intel.com</email>

</address>
</author>

<author initials="L." surname="Bertz" fullname="Lyle Bertz">
<organization abbrev="Sprint"></organization>
<address>
<postal>
          <street>6220 Sprint Parkway</street>

          <city>Overland Park  KS, 66251</city>

          <region></region>

          <code></code>

          <country>USA</country>
        </postal>

        <phone></phone>

        <email>lyleb551144@gmail.com</email>

</address>
</author>


    <date year="2016" />

    <workgroup>DMM Working Group</workgroup>

    <abstract>
      <t>
        This document describes the solution of data-plane separation
        from control-plane which enables mobility management system
        flexible using agent and client functions. To configure
        data-plane nodes and functions, the data-plane is abstracted in
        the agent to provide interface to the client. The data-plane
        abstraction model is extensible to support many different type
        of mobility management systems and data-plane functions.
      </t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">


<t>
One objective of the Distributed Mobility Management (DMM) WG is the separation of
the mobility management Control- and Data-Plane to enable flexible deployment, such
as decentralized provisioning of Data-Plane nodes (DPN). Data-Plane nodes can be configured
to function as an anchor for a registered Mobile Node's (MN) traffic, others can be configured
to function as a Mobile Access Gateway (MAG) per the Proxy Mobile IPv6 protocol
<xref target="RFC5213"></xref> or a Foreign Agent (FA) per the Mobile IPv4 protocol
<xref target="RFC3344"></xref>. Requirements for DMM have been described in <xref target="RFC7333"></xref>,
whereas best current practices for DMM are documented in <xref target="RFC7429"></xref>.
</t>

<t>
The Data-Plane must provide a set of functions to the Mobility Control-Plane, such as
support for encapsulation, IP address re-writing, QoS differentiation and traffic shaping.
In addition, means for traffic description must be provided to complement traffic treatment actions
and build unambiguous Data-plane rules. These requirements are met by various transport network components,
such as IP switches and routers, though configuration semantics differ between them.
</t>

<t>Forwarding Policy Configuration (FPC) per this document enables the configuration
of any Data-Plane node and type by the abstraction of configuration details and the use
of common configuration semantics. The protocol using the FPC semantics is deployed between
a Client function, which is associated with the Mobility Management Control-Plane,
and an Agent function. The Agent function enforces the Data-Plane configuration
and can be present on a transport network controller or co-located with a Data-Plane
node. The Agent applies the generalized configuration semantics to configuration, which
is specific to the Data-Plane node and type.
</t>

<t>This specification follows a common functional architecture, which utilizes the FPC
protocol between the Client and Agent functions.</t>

<t>A Client interacts with the Agent to build unambiguous rules which are to be enforced in
the Data-Plane. An Agent translates a rule, which follows the data model herein, into one or
multiple configuration actions to enforce the rule in the Data-Plane. Distinct collections of
rulese are defined as Ports in the information Model.</t>

<t>The Client interacts with the Agent to build sessions, including mobility sessions, to be
hosted by teh Data-Plane.  These sessions are referred to as Contexts.
</t>

<t>A Client utilizes a sequence or grouping of control messages to interact with the Agent, where
each control message has an unambiguous semantic, e.g. to set up a tunnel interface or to
configure a policy route in a Data-Plane node. An Agent performs a configuration action
per the semantics of the received control message or grouping of control messages. Generic messages,
i.e. create, update, query and delete, are also supported.</t>

<t>The availability of both generic and control messaging enables tailored implementation and deployment of Control-/Data-Plane
separation in mobile communication gateways, e.g. by having the Mobility Control-Plane directly communicating to
a Data-Plane node using control messages, or by the deployment of a Network Controller in between the Mobility
Control-Plane and Data-Plane nodes which may support both generic and control messages, which are under control of the Network Controller. Support for multiple deployment models
enables an operator to transition their network in incremental phases.</t>

<t>The architecture and reference interface specified in this document is not tied to any specific Control-Plane
protocol that is in use in the mobility network, or to any type of access technology. The mobility protocols in
use can be Proxy Mobile IPv6, GTP, IPSec or other protocols; and the access network can be 4G LTE, WiFi, or 5G.
These aspects have no direct implication on the FPC interface that is between Control- and Data-Plane nodes.</t>


    </section>

    <section title="Conventions and Terminology">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <xref
      target="RFC2119"></xref>.</t>


   </section>

   <section anchor="pcmodel" title="Reference Architecture and Information Model">

   <section anchor="refarch" title="Architecture for DMM Forwarding Policy Configuration">

<t>The DMM Forwarding Policy Configuration (FPC) protocol enables the separation of the mobility management Control-Plane
from the Data-Plane and provides the required control and semantics in between these two planes.
<xref target="fig_usecase"></xref> depicts an exemplary use case where IP traffic between a Correspondent Node (CN)
and a Mobile Node (MN) traverses multiple DPNs, each applying policies as per the Control-Plane's request.
Policies in the one or multiple DPNs can result in traffic steering according to a host-route, packet scheduling
and marking according to a subscriber's QoS profile, or forwarding rules (e.g. encapsulation within GRE or GTP-U tunnel).
</t>
<t>
   <figure anchor="fig_usecase"
              title="Exemplary illustration of DMM traffic steering and policy enforcement
                     at Data Plane Nodes (DPN)">
        <artwork align="center"><![CDATA[

               +--------------------------+
               |     Mobility Control     |
               +--------------------------+
                |             |         |
                |             |         |
                |             |         |
         \ /    V             V         V
+--+     -o-  +---+         +---+     +---+   +--+
|MN| ---- |---|DPN|<========|DPN|<----|DPN|<--|CN|
+--+      |   +---+         +---+     +---+   +--+
             Rules:       Rules:      Rules:
             Encap,Decap, Encap,Decap Policy-Route,
             Forward,QoS  Forward,QoS Forward

          ]]></artwork>

        <postamble></postamble>
      </figure>
</t>

<t>Mobility Control-Plane functions have the following roles in common: </t>

 <t><list style="symbols">
     <t>Tracking a mobile node's attachment, detachment from the access network.</t>
     <t>Accept requests to set up and maintain mobility-related Data-Plane paths between DPNs,
        enforcing QoS and forwarding policies. Such requests are a result of mobility signaling between different
        Mobility Control-Plane functions.</t>
     <t>Ensure that required rules to establish and maintain connectivity of an MN with its correspondent
        nodes are enforced in the Data-Plane.</t>
     <t>Participate in monitoring the DPNs' operation and support the handling of exceptions, e.g. the
        detection of a partial DPN failure and the diversion of traffic through a different DPN.</t>
     <t>Maintain consistency between multiple DPNs which enforce policy rules to ensure
        connectivity between a MN and its correspondent services.</t>
  </list></t>

<t>Mobility Data-Plane functions have the following roles in common: </t>

  <t><list style="symbols">
     <t>Forward and treat traffic according to the policies and directives sent by the Mobility Control-Plane.</t>
     <t>Provide status information (e.g. load, health, statistics and traffic volume) and events related to service failure
        upon request.</t>
     <t>Participate in the process of topology acquisition, e.g. by exposing relevant topological and
        capability information, such as support for QoS differentiation and supported encapsulation protocols.
        </t>
  </list></t>
<t>The protocol for DMM FPC applies to the interface between a FPC Client function and
a FPC Agent function, as depicted in <xref target="fig_refarch"></xref>. The FPC Client function
is associated with an application function of the mobility management Control-Plane, e.g. a Local
Mobility Anchor Control-Plane function per the Proxy Mobile IPv6 protocol.
The FPC Agent function processes the FPC protocol semantics and translates them into configuration
commands per the DPN's technology. In one example, a FPC Agent can be co-located with a Network
Controller, which enforces forwarding rules on a set of Data-plane nodes. In another example, the Agent
can be co-located with a Data-Plane node to directly interact with interface management and the
router's RIB Manager. The mapping of the common FPC semantics and policy description to the configuration
commands of a particular DPN is specific to the DPN's technology and the Agent's implementation.
</t>

<t>
 <figure anchor="fig_refarch"
              title="Functional reference architecture for DMM Forwarding Policy Configuration (FPC)">
        <artwork align="center"><![CDATA[

               +-------------------------+
               | Mobility Control-Plane  |
               |                         |
               |+--------[API]----------+|
               ||  FPC Client Function  ||
               |+----------^------------+|
               +-----------|-------------+
                           |
                           | DMM FPC protocol
                           |
               +-----------|-------------+
               |+----------v------------+|
               ||  FPC Agent Function   ||
               |+-----------------------+|
               |                         |
               |  DPN Configuration API  |
               +-------------------------+
          ]]></artwork>
        <postamble></postamble>
      </figure>
</t>
</section>
<section anchor="model1" title="Information Model">
    <t>To abstract from configuration details of an IP switch or IP router on the FPC protocol interface,
    the construct of logical ports describe sets of rules for D-Plane processing and contexts describe
    Session/Mobility based rules and congfiguration.
    </t>
    <t>A conext binds one or multiple session/mobility properties, which describe mobliity/session traffic
    treatment actions, such as a mobility QoS policy or packet encapsulation. Which traffic is treated by the
    context is determined by one or multiple traffic descriptors, which also bind to that context. A group of
    one or multiple traffic descriptors, one or multiple properties defining mobility/session based traffic
    treatment actions and the port identifier make a context. The context identifier serves as key to access
    the information.</t>
    <t>A port represents a colleciton of policy groups, a group of rules that can exists independent of the
    mobility/session lifecycle.  Policy groups are named collections of policies.  Policy groups provide a
    collection of policies, e.g. a contatenation of the rules in each policy, to provide a second level of
    rule aggregation often required to separate out technical grouping of rules, e.g. a policy, with the
    grouping of rules for use cases, e.g. a service level policy.
    </t>
    <t>Policies are a collection of rules.  A policy's rules contain traffic descriptors that describe the traffic
    to which a rule applies and associated treatment actions.  The rules are ordered to ensure an unambiguous
    traffic matching.
    </t>
    <t>Actions, descriptors, policies and policy groups can be viewed as configuration data while ports and contexts
    are akin to stuctures that are instantiatied on the DPN.  The descriptors, QoS attributes, actions and other
    structures referenced by a port or context are active, i.e. they can be applied to traffic on a DPN.
    The other structures are passive and MUST be present on a DPN but MUST also be referenced by a context or
    port in order to participate in traffic processing.
    </t>
    <t>All traffic arriving at a Data-Plane node and matching a traffic descriptor will be treated per
    the properties bound to the port or context the traffic descriptor is also bound to. For example, Traffic
    Selectors <xref target="RFC6088"></xref>, which can be bound to a context or port, can identify single or
    multiple IP flows. Aggregated IP traffic destined toward a given IP address prefix or originated from
    an address matching a particular IP address range can be described using the Traffic Selector or an IP prefix
    traffic descriptor per this specification.</t>
  <section anchor="naming" title="Naming">
    <t>Names have no official format between the Client and Agent but using unsigned 32 bit integers MUST be supported
      by Clients and Agents.  Other formats such as strings or URIs MAY be supported. The only requirement is that all
      names used to identify entities must be unique by Client/Agent pair for each entity type, e.g. Context, Port, etc.
      This is done by using binary comparison of names at the Agent. If a creation attempt occurs for an entity where the
      name already exists a NAME_ALREADY_EXISTS error is raised.
    </t>
    <t>The naming convention can be used to accommodate heirarchical structures such as virtual routing and fowarding (VRF),
      Policy Based Routing (PBR), Tunnel Interfaces, Networks, etc.  For example using a string prefix such as "mcc:01/mnc:002",
      an inteface such as "/if:1/", a VRF route, e.g. "/vrf:xxx/routeid:001" or a service id in a network
      "mcc:01/mnc:002/sr-id:internet".
    </t>
  </section>
  <section anchor="policy" title="Policies, Actions and Descriptors">
    <t>Actions specify the treatment applied to a packet. Actions are assigned an identifier and contain a type and value.</t>
    <t>Descriptor describes a filter for a packet. If the packet matches (passes) the filter it is said to be consumed by
      or taken by the Descriptor. Many specifications also used the terms Filter, Traffic Descriptor or Traffic Selector
      <xref target="RFC6088"/>. A packet that meets the criteria of a Descriptor is said to satisfy, pass or is consumed by
      the Descriptor. Descriptors are assigned an identifier and contain a type and value.</t>
    <t>Rules - are a collection of Descriptors and Actions. All Descriptors MUST be satisfied before the Actions are taken.
      This is known as an AND Descriptor list, i.e. Descriptor 1 AND Descriptor 2 AND ... Descriptor X MUST be satisfied for
      the rule to apply. These are an internal to the Policy, i.e. it is not a first class, visible object at the top level
      of an agent. Each Action and Descriptor are given Identifiers to assist in deleting individual list members of the Rule.
      Every Action also comes with an order value that specifies the execution order of Actions and simplifies DPN
      processing. A Rule references the Descriptors and Actions by their Identifiers and does not directly contain Action
      and Descriptor structures.</t>
    <t>Policies are a collection of Rules. Each Policy has a Policy Identifier and a list of Rules/Order pairs. Unlike the
      AND filter matching the Policy uses an OR matching to find the first Rule whose Descriptors are satisfied by the packet.
      The search for a Rule to apply to packet is executed according to the Order values of the Rules. This is an
      ascending order search, i.e. the Rule with the lowest Order value is tested first and if its Descriptors are not
      satisfied by the packet the Rule with the next lowest Order value is tested. Policies contain Rules as opposed to
      references to Rules.</t>
    <t>Policy Groups are an aggregation of Policies and provide a convenience mechanism for aggregation. Common applications
      include aggregating Policies that are defined by different functions, e.g. Network Address Translation, Security, etc.
      The structure has an Identifier and references the Policies via their Identifiers.</t>
  </section>
  <section anchor="portscontext" title="Ports and Context">
    <t>Ports contain Policy Groups (via reference to their Policy Group Identifiers) and have an Identifier. They may be
      instantiated on the DPN at the discretion of the Agent. Being Policy based and having the ability to specify Rules
      with Forwarding related Actions, Ports can take on functions such as network address translation, route selection, etc.</t>
    <t>Contexts provide Port functionality with a focus on hierarchically related forwarding functions such as Mobility.
      They have attributes such as uplink/downlink Quality of Service (QoS) and tunnel and assigned IP, e.g. delegating
      prefixes, as well as the ability to reference parent Contexts. When a parent Context is referenced, the descendant,
      e.g. child, can inherit required properties and policies. Contexts also have fate sharing - when a Context is deleted
      all of its descendants are deleted. They are also assigned Data Plane Nodes (DPNs).
    </t>
    <t>Although Contexts are hierarchical Ports are not. There are distinct advantages in Contexts for the hierarchical
      representation including limiting the amount of over the wire information transported and fate sharing during deletion.
      However, Client MUST avoid creating deep, arbitrary hierarchies as this creates major disadvantages. A two tier
      hierarchy is common in many mobility solutions but further depths SHOULD be avoided.</t>
  </section>
  <section anchor="toplogy" title="Topology">
    <t>Data Plane Nodes may be organized into Data Plane Groups. A Context is attached to a DPN Group indirectly (by
      reference to the DPN Group Identifier) or directly through specification of the structure in the Context.</t>
    <t>A DPN specifies the connectivity information for the Agent, supported Control Protocols and the DPN Groups
    it is a part of.</t>
    <t>DPN Groups specify the Mobility Role, supported access technologies and mobility profiles. It also specifies
    connected peer groups.</t>
  </section>
  <section anchor="monitor_descr" title="Monitors">
    <t>Monitors provide a mechanism to produce reports when events occur.  Unlike ports and contexts a Monitor will
      have a target that may be any FPC-Identity except other monitors, events by their type, or attributes of an entity.
      In such cases, the target name is a concatenation of the FPC-Identity and the relative path (separated by '/') to the
      attribute(s) to be monitored.
    </t>
    <t>Monitors MUST be registered with the Agent.  The registration specifies the monitor id, attribute to monitor and
      optional reporting configuration. When a Monitor registration is applied, the reporting configuration MUST be applicable
      to the attribute monitored, e.g. a Monitor using a Threshold configuration cannot be applied to a context but it can be
      applied to a numeric context property.
    </t>
    <t>Four report types are defined:
      <list style="numbers">
        <t>Periodic reporting specifies an interval by which a NOTIFY is sent to the Client.</t>
        <t>Event reporting specifies a list of EVENT_TYPE_IDs that, if they occur and are related to the monitored attribute,
          will result in sending a NOTIFY to the Client</t>
       <t>Scheduled reporting specifies the time (in seconds since Jan 1, 1970) when a NOTIFY for the monitor should be sent
         to the Client. Once this Monitor's NOTIFY is completed the Monitor is automatically de-registered.</t>
       <t>Threshold reporting specifies one or both of a low and high threshold. When these values are crossed a corresponding
         NOTIFY is sent to the Client.</t>
      </list>
    </t>
   <t>All monitored data can be requested by the Client at any time using the PROBE message. Thus, reporting configuration is
     optional and when not present only PROBE messages may be used for monitoring. If a SCHEDULED or PERIODIC configuration is
     provided during registration with the time related value (time or period respectively) of 0 a NOTIFY is immediately sent and
     the monitor is immediately de-registered. This method should, when a MONITOR has not been installed, result in an immediate
     NOTIFY is sufficient for the Client's needs and the Client has no further need for the monitor to be registered.
     An Agent may reject a registration if it or the DPN has insufficient resources.</t>
   <t>MONITOR_DEREG is used by a Client to remove a monitor from an Agent. The message identifies one or multiple monitors by including
     the MONITOR_ID. The message also includes an optional Boolean value that, when true, will result in NOTIFY messages being sent for
     the MONITOR_ID to the Client.</t>
   <t>When a monitor has a reporting configuration of SCHEDULED it is automatically de-registered after the NOTIFY occurs.
   An Agent or DPN may temporarily suspend monitoring if insufficient resources exist.  In such a case the Agent MUST notify the
   Client.</t>
  <t>PROBE are used by a Client to retrieve information about a previously installed monitor. The PROBE message SHOULD
   identify one or more monitors by means of including the associated monitor identifier. An Agent receiving a PROBE
   message SHOULD send the requested information in a single or multiple NOTIFY messages.</t>
  <t>NOTIFY are used by an Agent to report the status of a monitor to a Client. This message contains the MONITOR_ID, a
   NOTIFICATION_ID to permit the Client to distinguish amongst many monitoring related requests, a TRIGGER that caused
   the NOTIFY message, the timestamp of when the monitored information was record for the message along with the value
   of the monitored attribute.</t>
  </section>
</section>
    </section>
<section anchor="protocol" title="Protocol">
  <section anchor="messageandsematics" title="Protocol Messages and Semantics">
    <t>Five message types are supported:</t>
    <texttable anchor="messages" title="Client to Agent Messages">
    <ttcol align="left">Message</ttcol>
    <ttcol align="left">Type</ttcol>
    <ttcol align="left">Description</ttcol>

    <c>CONF</c>
    <c>HEADER BODY</c>
    <c>Configure processes a single operation.</c>

    <c>CONF_BUNDLES</c>
    <c>1*[HEADER BODY]</c>
    <c>Configure-bundles takes multiple operations that are to be executed as a group
          with partial failures allowed. They are executed according to the OP_ID value
          in the OP_BODY. If a CONFIGURE_BUNDLES fails, any entities provisioned in the
          CURRENT operation are removed, however, any successful operations completed prior to
          the current operation are preserved in order to reduce system load.</c>

    <c>REG_MONITOR</c>
    <c>*[ MONITOR ]</c>
    <c>Install a monitor at an Agent. The message includes information about the attribute to
      monitor and the reporting method.  Note that a MONITOR_CONFIG is required for this
      opeation.</c>

    <c>DEREG_MONITOR</c>
    <c>*[ MONITOR_ID ] [ boolean ]</c>
    <c>Remove monitors from an Agent. Monitor IDs are provided. Boolean (optional) indicates
      if a successful DEREG triggers a NOTIFY with final data.</c>

    <c>PROBE</c>
    <c>MONITOR_ID</c>
    <c>Probe the status of a registered monitor.</c>
    </texttable>
    <t>Each message contains a header with the Client Identifier, an execution delay timer,
    the state of session related entites after the operation, the adminstrative state of all
    entities, the type of operation, an optional Command Set (see <xref target="commandsets"/>) and
    the input (body) of the message.</t>
    <t>The operation input contains an operation identifier, a list of all entities and optional cloning
    instructions (see <xref target="cloning"/>).</t>
    <t>An Agent will respond with an error, ok, or an ok with indication that remaining
    data will be sent via a notify from the Agent to the Client <xref target="asyncnotification"/>. When
    returning an 'ok' of any kind, optional data may be present.</t>
    <t>Two Agent notifications are supported:</t>
    <texttable anchor="notifications" title="Agent to Client Messages (Notfications)">
      <ttcol align="left">Message</ttcol>
      <ttcol align="left">Type</ttcol>
      <ttcol align="left">Description</ttcol>

      <c>CONFIG_RESULT_NOTIFY</c>
      <c>See <xref target="ayncnotify_detail"/></c>
      <c>An asynchronous notification from Agent to Client based upon a previous CONFIG or CONFIG_BUNDLES
      request.</c>

      <c>NOTIFY</c>
      <c>See <xref target="notify_structs"/></c>
      <c>An asynchronous notification from Agent to Client based upon a registered MONITOR.</c>
    </texttable>

    <section anchor="agent-processing" title="Agent Operation Processing">
      <t>The Agent will process entities provided in an operation in the following order:
        <list style="numbers">
  <t>Clone Instructions, if the feature is supported</t>
  <t>Descriptors</t>
  <t>Actions</t>
  <t>Policies</t>
  <t>Policy-Groups</t>
  <t>Ports according to COMMAND_SET order processing</t>
  <t>Contexts according to COMMAND_SET order processing</t>
</list></t>
   <t>The following Order Processing occurs when COMMAND Sets are present
        <list style="numbers">
        <t>The Entity specific COMMAND_SET is processed according to its bit order unless
        otherwise specified by the technology specific COMMAND_SET.
        </t><t>Operation specific COMMAND_SET is processed upon all applicable entities
        (even if they had Entity specific COMMAND_SET values present) according to its bit
        order unless otherwise specified by the technology specific COMMAND_SET.
        </t><t>Operation OP_TYPE is processed for all entities.</t>
        </list>
    </t>
    <t>When deleting objects it at the top level only their name needs to be provided.</t>
    <t>When deleting an attribute, a leaf reference should be provided.  This is a path to the attibutes.</t>
  </section>
    <section anchor="cloning" title="Cloning">
      <t>Cloning is an optional feature that allows a Client to copy one structure to another
        in an operation. Cloning is always done first within the operation (see Operation
        Order of Execution for more detail). If a Client wants to build an object then Clone
        it using CONFIG_BUNDLES with the first operation being the entities to be copied and
        a second operation with the Cloning instructions. A CLONE operation takes two arguments,
        the first is the name of the target to clone and the second is the name of the newly
        created entity.</t>
    </section>
    <section anchor="commandsets" title="Command Bitsets">
<t>The COMMAND_SET is a technology specific bitset that allows for a single entity to
  be sent in an operation with the requested sub-transactions to be completed. For
  example, a Context could have the Home Network Prefix absent but it is unclear if
  the Client would like the address to be assigned by the Agent or if this is an error.
  Rather than creating a specific command for assigning the IP a bit position in a
  COMMAND_SET is reserved for Agent based IP assignment. Alternatively, an entity
  could be sent in an update operation that would be considered incomplete, e.g.
  missing some required data in for the entity, but has sufficient data to complete
  the instructions provided in the COMMAND_SET.</t>
    </section>
<section anchor="refscope" title="Reference Scope">
  <t>The Reference Scope is an optional feature that provides the scope of references
    used in a configuration command, i.e. CONFIG or CONFIG_BUNDLES. These scopes are
    defined as
    <list style="symbols">
      <t>none - all entities have no references to other entities.  This implies only
      Actions, Descriptors or Contexts are present as all other entities MUST have
      references to other entities in the model.</t>
      <t>op - All references are contained in the operation body, i.e. only intra-operaion
      references exist.</t>
      <t>bundle - All references in exist in bundle (inter-operation/intra-bundle). NOTE -
        If this value comes in CONFIG call it is equivalent to 'op'.</t>
      <t>storage - One or more references exist outside of the operation and bundle. A lookup
        to a cache / storage is required.</t>
      <t>unknown - the location of the references are unknown. This is treated as a 'storage' type.</t>
    </list>
  </t>
  <t>An agent that only accepts 'op' or 'bundle' reference scope messages is referred to as 'stateless'
    as it has no direct memory of references outside messages themselves. This permits low memory
    footprint Agents. Even when an Agent supports all message types an 'op' or 'bundle' scoped message
    can be processed quickly by the Agent as it does not require storage access. </t>
</section>
    <section anchor="response" title="Operation Response">
      <section anchor="immediateresp" title="Immediate Response">
    <t>Results will be supplied per operation input. Each result contains the
      RESULT_STATUS and OP_ID that it corresponds to. RESULT_STATUS values are:
      <list>
      <t>OK - SUCCESS
      </t><t>ERR - An Error has occurred
      </t><t>OK_NOTIFY_FOLLOWS - The Operation has been accepted by the Agent but
      further processing is required. A CONFIG_RESULT_NOTIFY will be sent once the
      processing has succeeded or failed.</t>
      </list>
    </t>
    <t>Any result MAY contain nothing or a entities created or partially fulfilled as part of the
      operation as specified in <xref target="op_respbody"/>.</t>
    <t>If an error occurs the following information is returned.
    <list>
      <t>ERROR_TYPE_ID (Unsigned 32) - The identifier of a specific error type
      </t><t>ERROR_INFORMATION - An OPTIONAL string of no more than 1024 characters.
    </t></list>
    </t>
      </section>
      <section anchor="asyncnotification" title="Asynchronous Notification">
      <t>A CONFIG_RESULT_NOTIFY occurs after the Agent has completed processing related to a
        CONFIG or CONFIG_BUNDLES request. It is an asynchronous communication from the
        Agent to the Client.</t>

        <t>The values of the CONFIG_RESULT_NOTIFY are detailed in <xref target="ayncnotify_detail"/>.</t>
      </section>
    </section>
  </section>
  <section anchor="protoperation" title="Protocol Operation">
    <section anchor="simple" title="Simple RPC Operation">
<t>An FPC Client and Agent MUST identify themself using the CLI_ID and AGT_ID respectively to ensure that for all
transactions a recipient of an FPC message can unambiguously identify the sender of the FPC message.
<!--All messages between an Agent and a Client must identify the Client and Agent using the CLI_ID and AGT_ID respectively.-->
A Client MAY direct the Agent to enforce a rule in a particular DPN by including a DPN_ID value. Otherwise the Agent
selects a suitable DPN to enforce a rule and notifies the Client about the selected DPN using the DPN_ID.</t>

<t>All messages sent from a Client to an Agent MUST be acknowledged by the Agent. The response must
include all entities as well as status information, which indicates the result of processing the message,
using the RESPONSE_BODY property. In case the processing of the message results in a failure, the Agent sets
the ERROR_TYPE_ID and ERROR_INFORMATION accordingly and MAY clear the Context or Port, which caused the failure,
in the response.</t>

<t>If based upon Agent configuration or the processing of the request may take a significant amount of time the
  Agent MAY respond with an OK_NOTIFY_FOLLOWS with an optional RESPONSE_BODY containing the paritially completed
  entities. When an OK_NOTIFY_FOLLOWS is sent the Agent will, upon completion or failure of the operation, respond with an
  asynchronous CONFIG_RESULT_NOTIFY.</t>

<t>A Client MAY add a property to a Context without providing all required details of the attribute's value. In such case
the Agent SHOULD determine the missing details and provide the completed property description back to the Client. If the
processing will take too long or based upon Agent configuration, the Agent MAY respond with an OK_NOTIFY_FOLLOWS with a
  RESPONSE_BODY containing the paritially completed entities.</t>
<t>
In case the Agent cannot determine the missing value of an attribute's value per the Client's request, it leaves the
attribute's value cleared in the RESPONSE_BODY and sets the RESULT to Error, ERROR_TYPE_ID and ERROR_INFORMATION. As example,
the Control-Plane needs to setup a tunnel configuration in the Data-Plane but has to rely on the Agent to determine the tunnel
endpoint which is associated with the DPN that enforces the rule. The Client adds the tunnel property attribute to the FPC message
and clears the value of the attribute (e.g. IP address of the local tunnel endpoint). The Agent determines the tunnel
endpoint and includes the completed tunnel property in its response to the Client.</t>

<t><xref target="fig_msc_example"></xref> illustrates an exemplary session life-cycle based on
Proxy Mobile IPv6 registration via MAG Control-Plane function 1
(MAG-C1) and handover to MAG Control-Plane function 2 (MAG-C2). Edge DPN1 represents the Proxy CoA after
attachment, whereas Edge DPN2 serves as Proxy CoA after handover. As exemplary architecture,
the FPC Agent and the network control function are assumed to be co-located with the Anchor-DPN, e.g. a Router.
</t>

<t>
 <figure anchor="fig_msc_example"
              title="Exemplary Message Sequence (focus on FPC reference point)">
        <artwork align="center"><![CDATA[
                                                +-------Router--------+
                        +-----------+           |+-------+ +---------+|
+------+ +------+     +-----+ FPC   |            | FPC   | |  Anchor |
|MAG-C1| |MAG-C2|     |LMA-C| Client|            | Agent | |   DPN   |
+------+ +------+     +-----+-------+            +-------+ +---------+
[MN attach]  |            |                          |           |
   |-------------PBU----->|                          |           |
   |         |            |---(1)--CONFIG(CREATE)--->|           |
   |         |            |   [ CONTEXT_ID,          |--tun1 up->|
   |         |            |   DOWNLINK(QOS/TUN),     |           |
   |         |            |   UPLINK(QOS/TUN),       |--tc qos-->|
   |         |            |     IP_PREFIX(HNP) ]     |           |
   |         |            |<---(2)- OK --------------|-route add>|
   |         |            |                          |           |
   |<------------PBA------|                          |           |
   |         |            |                          |           |
   | +----+  |            |                          |           |
   | |Edge|  |            |                          |           |
   | |DPN1|  |            |                          |           |
   | +----+  |            |                          |           |
   |   |                                                         |
   |   |-=======================================================-|
   |                      |                          |           |
   |   [MN handover]      |                          |           |
   |         |---PBU ---->|                          |           |
   |         |            |--(3)- CONFIG(MODIFY)---->|           |
   |         |<--PBA------|    [ CONTEXT_ID          |-tun1 mod->|
   |         |            |      DOWNLINK(TUN),      |           |
   |         |  +----+    |      UPLINK(TUN) ]       |           |
   |         |  |Edge|    |<---(4)- OK --------------|           |
   |         |  |DPN2|    |                          |           |
   |         |  +----+    |                          |           |
   |         |    |       |                          |           |
   |         |    |-============================================-|
   |         |            |                          |           |

      ]]></artwork>
        <postamble></postamble>
      </figure>
</t>

<t>After reception of the Proxy Binding Update (PBU) at the LMA Control-Plane function (LMA_C), the
LMA-C selects a suitable DPN, which serves as Data-Plane anchor to the mobile node's (MN) traffic. The LMA-C
adds a new logical Context to the DPN to treat the MN's traffic (1) and includes a Context Identifier (CONTEXT_ID)
to the CONFIGURE command. The LMA-C identifies the selected Anchor DPN by including the associated DPN identifier.
</t>

<t>The LMA-C adds properties during the creaton of the new Context. One property is added to specify the
forwarding tunnel type and endpoints (Anchor DPN, Edge DPN1) in each direction (as required). Another property is
added to specify the QoS differentiation, which the MN's traffic should experience. At reception of the Context, the
FPC Agent utilizes local configuration commands to create the tunnel (tun1) as well as the traffic control (tc)
to enable QoS differentiation. After configuration has been completed, the Agent applies a new route to forward all
traffic destined to the MN's HNP specified as a property in the Context to the configured tunnel interface (tun1).</t>

<t>During handover, the LMA-C receives an updating PBU from the handover target MAG-C2. The PBU refers to a
new Data-Plane node (Edge DPN2) to represent the new tunnel endpoints in the downlink and uplink, as requried.
The LMA-C sends a CONFIGURE message (3) to the Agent to modify the existing tunnel property of the existing Context
and to update the tunnel endpoint from Edge DPN1 to Edge DPN2. Upon reception of the CONFIGURE message, the Agent
applies updated tunnel property to the local configuration and responds to the Client (4).</t>

<t>The example below is a varition upon the previous example where the Agent has been configured or based upon
the time to complete the request, the Agent responds with an OK_NOTIFY_FOLLOWS (2) and a subsequent
CONFIG_RESULT_NOTIFY notification (3) upon completion of the DPN commands.</t>

<t>
 <figure anchor="fig_msc_delete_example"
              title="Exemplary Message Sequence (focus on FPC reference point)">
        <artwork align="center"><![CDATA[
                                                +-------Router--------+
                        +-----------+           |+-------+ +---------+|
+------+ +------+     +-----+ FPC   |            | FPC   | |  Anchor |
|MAG-C1| |MAG-C2|     |LMA-C| Client|            | Agent | |   DPN   |
+------+ +------+     +-----+-------+            +-------+ +---------+
[MN attach]  |            |                          |           |
   |-------------PBU----->|                          |           |
   |         |            |---(1)--CONFIG(MODIFY)--->|           |
   |<------------PBA------|   [ CONTEXT_ID,          |--tun1   ->|
   |         |            |   DOWNLINK(TUN delete),  |    down   |
   |         |            |   UPLINK(TUN delete) ]   |           |
   |         |            |                          |           |
   |         |            |<-(2)- OK ----------------|           |
   |         |            |                          |           |
   |         |  [ MinDelayBeforeBCEDelete expires ]  |           |
   |         |            |                          |           |
   |         |            |---(3)--CONFIG(DELETE)--->|-- tun1 -->|
   |         |            |                          |  delete   |
   |         |            |<-(4)- OK ----------------|           |
   |         |            |                          |-- route ->|
   |         |            |                          |   remove  |
   |         |            |                          |           |
      ]]></artwork>
        <postamble></postamble>
      </figure>
</t>
<t>When a teardown of the session occurs, MAG-C1 will send a PBU with a lifteime
value of zero.  The LMA-C sends a CONFIGURE message (1) to the Agent to modify the existing
tunnel property of the existing Context to delete the tunnel information.) Upon reception of the CONFIGRE message,
the Agent removes the tunnel configuration and responds to the Client (2). Per <xref target="RFC5213"/>, the PBA
is sent back immediately after the PBA is received.</t>

<t>If no valid PBA is recieved after the expiration of the MinDelayBeforeBCEDelete timer (see <xref target="RFC5213"/>),
the LMA-C will send a CONFIGURE (3) message with a deletion request for the Context.  Upon reception of the message, the
Agent deletes the tunnel and route on the DPN and responds to the Client (4).</t>

    </section>
    <section anchor="optimization" title="Optimization for Current and Subsequent Messages">
      <section anchor="bulkopexample" title="Bulk Data in a Single Operation">
        <t>A single operation MAY contain multiple entities.  This permits bundling of requests
        into a single operation.   In the example below two PMIP sessions are created via two PBU
        messages and sent to the Agent in a single CONFIGURE message (1). Upon receiveing the message,
        the Agent responds back with an OK_NOTIFY_FOLLOWS (2), completes work on the DPN to activate
        the assocaited sessions then responds to the Client wiht a CONFIG_RESULT_NOTIFY (3).</t>
<t>
 <figure anchor="fig_bulk_example"
              title="Exemplary Bulk Entity with Asynchronous Notification Sequence (focus on FPC reference point)">
        <artwork align="center"><![CDATA[
                                                +-------Router--------+
                        +-----------+           |+-------+ +---------+|
+------+ +------+     +-----+ FPC   |            | FPC   | |  Anchor |
|MAG-C1| |MAG-C2|     |LMA-C| Client|            | Agent | |   DPN   |
+------+ +------+     +-----+-------+            +-------+ +---------+
[MN1 attach] |            |                          |           |
   |-------------PBU----->|                          |           |
   |  [MN2 attach]        |                          |           |
   |         |---PBU----->|                          |           |
   |         |            |                          |           |
   |         |            |---(1)--CONFIG(CREATE)--->|           |
   |<------------PBA------|   [ CONTEXT_ID 1,        |--tun1 up->|
   |         |            |   DOWNLINK(QOS/TUN),     |           |
   |         |<--PBA------|   UPLINK(QOS/TUN),       |--tc1 qos->|
   |         |            |     IP_PREFIX(HNP) ]     |           |
   |         |            |   [ CONTEXT_ID 2,        |-route1    |
   |         |            |   DOWNLINK(QOS/TUN),     |   add>    |
   |         |            |   UPLINK(QOS/TUN),       |           |
   |         |            |     IP_PREFIX(HNP) ]     |--tun2 up->|
   |         |            |<-(2)- OK_NOTIFY_FOLLOWS--|           |
   |         |            |                          |--tc2 qos->|
   |<------------PBA------|                          |           |
   |         |            |                          |-route2    |
   |         |            |<(3) CONFIG_RESULT_NOTIFY |   add>    |
   |         |            |   [ Response Data ]      |           |
   |         |            |                          |           |
   |         |            |                          |           |
      ]]></artwork>
        <postamble></postamble>
      </figure>
</t>
      </section>
      <section anchor="bundelexample" title="Configuration Bundles">
        <t>Bundles provide transaction boundaries around work in a single message.  Operations in a bundle MUST
        be successfully executed in the order specified.  This allows references created in one operation to be
        used in a subsequent operation in the bundle. </t>
        <t>The example bundle shows in Operation 1 (OP 1) the creation of a Context 1 which is then referenced
        in Operation 2 (OP 2) by CONTEXT_ID 2.  If OP 1 fails then OP 2 will not be executed.  The advantage of the
        CONFIGURE_BUNDLES is preservation of dependency orders in a single message as opposed to sending multiple
        CONFIGURE messages and awaiting results from the Agent.</t>
        <t>When a CONFIGURE_BUNDLES fails, any entities provisioned in the CURRENT operation are removed, however, any
        successful operations completed prior to the current operation are preserved in order to reduce system load.</t>
<t>
 <figure anchor="fig_bundle_example"
              title="Exemplary Bundle Message (focus on FPC reference point)">
        <artwork align="center"><![CDATA[
                        +-------Router--------+
+-----------+           |+-------+ +---------+|
|   FPC     |            | FPC   | |  Anchor |
|  Client   |            | Agent | |   DPN   |
+-----------+            +-------+ +---------+
     |                          |           |
     |-CONFIG_BUNDLES(CREATE)-->|           |
     |   [ OP 1, [PORT X ]      |           |
     |   [ CONTEXT_ID 1,        |           |
     |   DOWNLINK(QOS/TUN),     |           |
     |   UPLINK(QOS/TUN),       |           |
     |     IP_PREFIX(HNP) ]     |           |
     |   [ OP 2,                |           |
     |    [ CONTEXT_ID 2,       |           |
     |   PARENT_CONTEXT_ID 1,   |           |
     |   UPLINK(QOS/TUN),       |           |
     |   DOWNLINK(QOS/TUN) ] ]  |           |
     |                          |           |
      ]]></artwork>
        <postamble></postamble>
      </figure>
</t>
      </section>
      <section anchor="cloningexample" title="Cloning Feature (Optional)">
        <t>Cloning provides a high speed copy/paste mechanism. The example below shows a single Context
        that will be copied two times.  A subsequent update then overrides the value.  The avoid the
        accidental activation of the Contexts on the DPN, the CONFIGURE (1) message with the cloning
        instruction has a SESSION_STATE with a value of 'incomplete' and OP_TYPE of 'CREATE'.  A second
        CONFIGURE (2) is sent with the SESSION_STATE of 'complete' and OP_TYPE of 'UPDATE'.  The second
        message includes any differences between the original (copied) Context and its Clones.</t>
<t>
 <figure anchor="fig_clone_example"
              title="Exemplary Bundle Message (focus on FPC reference point)">
        <artwork align="center"><![CDATA[
                        +-------Router--------+
+-----------+           |+-------+ +---------+|
|   FPC     |            | FPC   | |  Anchor |
|  Client   |            | Agent | |   DPN   |
+-----------+            +-------+ +---------+
     |                          |           |
     |-CONFIG_BUNDLES(CREATE)-->|           |
     |   [ OP 1,                |           |
     |    [ SESSION_STATE       |           |
     |       (incomplete) ],    |           |
     | [CLONE SRC=2, TARGET=3], |           |
     | [CLONE SRC=2, TARGET=4], |           |
     |    [ CONTEXT_ID 2,       |           |
     |   PARENT_CONTEXT_ID 1,   |           |
     |   UPLINK(QOS/TUN),       |           |
     |   DOWNLINK(QOS/TUN),     |           |
     |   IP_PREFIX(HNP)    ] ]  |           |
     |<----- OK ----------------|           |
     |                          |           |
     |-CONFIG_BUNDLES(UPDATE)-->|           |
     |    [ CONTEXT_ID 3,       |           |
     | PARENT_CONTEXT_ID(empty),|           |
     |   UPLINK(QOS/TUN),       |           |
     |   DOWNLINK(QOS/TUN) ],   |           |
     |    [ CONTEXT_ID 4,       |           |
     | PARENT_CONTEXT_ID(empty),|           |
     |   UPLINK(QOS/TUN),       |           |
     |   DOWNLINK(QOS/TUN) ] ]  |           |
     |<----- OK ----------------|           |
     |                          |           |
      ]]></artwork>
        <postamble></postamble>
      </figure>
</t>
        <t>Cloning has the added advantage of reducing the over the wire data size required to create
        multiple entities.  This can improve performance if serializaiton / deserialization of multiple
        entities incurs some form of performance penalty.</t>
      </section>
      <section anchor="commandsetexample" title="Command Bitsets (Optional)">
        <t>Command Sets permit the ability to provide a single, unified data structure, e.g.
        CONTEXT, and specify which activities are expected to be performed on the DPN.  This
        has some advantages
        <list style="symbols">
          <t>Rather than sending N messages with a single operation performed on the DPN a single
          message can be used with a Command Set that specifies the N DPN operations to be executed.</t>
          <t>Errors become more obvious.  For example, if the HNP is NOT provided but the Client did not
          specify that the HNP should be assigned by the Agent this error is easily detected.  Without
          the Command Set the default behavior of the Agent would be to assign the HNP and then respond
          back to the Client where the error would be detected and subsequent messaging would be required to
          remedy the error. Such sitations can increase the time to error detection and overall system load
          withouth the Command Set present.</t>
          <t>Unambiguous provisioning specification.  The Agent is exactily in sync with the expectations of the
          Client as opposed to guessing what DPN work could be done based upon data present at the Agent. This
          greatly increases the speed by which the Agent can complete work.</t>
          <t>Permits different technologies with different instructions to be sent in the same message.</t>
        </list>
        </t>
        <t>As Command Bitsets are technology specfic, e.g. PMIP or 3GPP Mobility, the type of work varies on the DPN and
        the amount of data present in a Context or Port will vary.  Using the technology specific instructions allows the
        Client to serve multiple technologies and MAY result in a more statless Client as the instructions are transferred
        the Agent which will match the desired, technology specific instructions with the capabilities and over the wire
        protocol of the DPN more efficiently.</t>
      </section>
      <section anchor="referenceexample" title="Reference Scope(Optional)">
        <t>Although entities MAY refer to any other entity of an appropriate type, e.g. Contexts can refer to Ports or Contexts,
        the Reference Scope gives the Agent an idea of where those references reside.  They may be in the same operation, an operation
        in the same CONFIG_BUNDLES message or in storage.  There may also be no references.  This permits the Agent to understand when it
        can stop searching for reference it cannot find.  For example, if a CONFIG_BUNDLES message uses a Reference Scope of type
        'op' then it merely needs to keep an operation level cache and consume no memory or resources searching across the many
        operations in the CONFIG_BUNDLES message or the data store.</t>
        <t>Agents can also be stateless by only supporting the 'none', 'op' and 'bundle' reference scopes.   This does not imply
        they lack storage but merely the search space they use when looking up references for an entity. The figure below shows the caching
        heirarchy provided by the Reference Scope</t>
        <t>Caches are temporarily created at each level and as the scope includes more caches the amount of
        entities that are searched increases. <xref target="fig_cache_example"/> shows an example cache where
        each Cache where a containment heirarchy is provided for all caches.</t>
<t>
        <figure anchor="fig_cache_example"
              title="Exemplary Heirarchical Cache">
        <artwork align="center"><![CDATA[
                       +---------------+
                       | Global Cache  |
                       |  (storage)    |
                       +------+--------+
                              |
                              +----------------------+
                              |                      |
                       +------+--------+      +------+--------+
                       | Bundle Cache  |      | Bundle Cache  |
                       |   (bundle)    | .... |   (bundle)    |
                       +------+--------+      +------+--------+
                              |
         +--------------------+--------------------+
         |                    |                    |
+--------+---------+ +--------+---------+ +--------+---------+
| Operation Cache  | | Operation Cache  | | Operation Cache  |
|       (op)       | |       (op)       | |       (op)       |
+------------------+ +------------------+ +------------------+

                          (no cache)
      ]]></artwork>
        <postamble></postamble>
      </figure>
</t>

      </section>
    </section>
    <section anchor="preprov" title="Pre-provisioning">
      <t>Although Contexts are used for Session based lifecycle elements, Ports may exist outside of a specific
      lifecycle and represent more general policies that may affect multiple Contexts (sessions).   The use of
      pre-provisioning of Ports permits policy and administrative use cases to be exected.  For example, creating
      tunnels to forward traffic to a trouble management platform and dropping packets to a defective web server
      can be accomplished via provisioning of Ports.</t>
      <t>The figure below shows a CONFIGURE (1) message used to accomplish dropping packets to a
        defective server prior to any Context creation.</t>
<t>
 <figure anchor="fig_policy_example"
              title="Exemplary Bundle Message (focus on FPC reference point)">
        <artwork align="center"><![CDATA[
                        +-------Router--------+
+-----------+           |+-------+ +---------+|
|   FPC     |            | FPC   | |  Anchor |
|  Client   |            | Agent | |   DPN   |
+-----------+            +-------+ +---------+
     |                          |           |
     |------CONFIG(CREATE)----->|           |
     | [ DESCRIPTOR_ID desc1,   |           |
     |     TYPE(TO_PREFIX)      |           |
     |  defective server        |           |
     |  address 32 ],           |           |
     |  [ ACTION_ID act1,       |           |
     |     TYPE(DROP)  ],       |           |
     |   [ POLICY_ID p1,        |           |
     |    [(RULE) ORDER 1       |           |
     |    [ [desc1  uplink] ]   |           |
     |    [ [act1 ORDER 1] ]]], |           |
     |  [ POLICY-GROUP_ID pg1   |           |
     |    [ p1 ] ],             |           |
     |  [ PORT_ID port1,        |           |
     |     DPN_ID X,            |           |
     |     [ pg1 ] ]            |           |
     |                          |           |
      ]]></artwork>
        <postamble></postamble>
      </figure>
</t>
      <section anchor="registry" title="Basename Registry Feature (Optional)">
        <t>The Optional BaseName Registry support feature is provided to permit Clients with common scopes,
        referred to in this specification as BaseNames, to track the state of provisioned policy information
        on an Agent. The registry records the BaseName and Checkpoint set by a Client. If a new Client
        attaches to the Agent it can query the Registry to determine the amount of work that must be
        executed to configure the Agent to a BaseName / checkpoint revision. A State value is also
        provided in the registry to help Clients coordinate work on common BaseNames.
        </t>
      </section>
    </section>
  </section>

</section>

<section anchor="proto_message_detail" title="Protocol Message Details">
<section anchor="datastructure" title="Data Structures">
  <t>A Client may add, modify or delete multiple actions, descriptors,
   policies, policy-groups, ports and contexts in a single message. This
   includes control of the operation of a rule.  As example, a rule which
   performs re-writing of an arriving packet's destination IP address
   from IP_A to IP_B matching an associated Descriptro, can be
   enforced in the Data-Plane via an Agent to implicitly consider
   matching arriving packet's source IP address against IP_B and re-
   write the source IP address to IP_A.
</t>

<t><xref target="fig_port"/> illustrates the generic policy configuration
   model as used between a FPC Client and a FPC Agent.
</t>

  <t>
<figure anchor="fig_port" title="Structure of Policies and Ports">
        <artwork align="center"><![CDATA[

  Descriptor_1 -+          +- Action_1
                |          |
  Descriptor_2 -+--<Rule>--+- Action_2
                  +------+
                  /Order#/-------------+
                  +------+             |
                                       |
  Descriptor_3 -+          +- Action_3 +-<PolicyID>
                |          |           |  ^
  Descriptor_4 -+--<Rule>--+- Action_4 |  |
                  +------+             | <PolicyGroupID>
                  /Order#/-------------+  ^
                  +------+                |
                                         <PortID>

  +-------------------+     +---------------------+
  | Bind 1..M traffic |     |  Bind 1..N traffic  |
  |  Descriptors to   | --> |  treatment actions  |
  |     a Policy,     |     |      to a Policy,   |
  | Policy-Group and  |     |   Policy-Group and  |
  |       Port        |     |       Port          |
  +-------------------+     +---------------------+

 |                                                 |
 +-------------- Data-Plane Rule ------------------+
        ]]></artwork>
        <postamble></postamble>
      </figure>
</t>

  <t>
   As depicted in <xref target="fig_port"/>, the port represents the anchor
   of rules through the policy-group, policy, rule heirarchy.  A
   Client and Agent use the identifier of the associated policy to directly
   access the rule and perform modifications of traffic descriptors or action
   references.  A Client and Agent use the identifiers to access the descriptors
   or action to perform modifications. From the viewpoint of packet processing,
   arriving packets are matched against traffic descriptors and processed according
   to the treatment actions specified in the list of properties associated with the
   port.
  </t>
  <t>
   A Client complements a rule's descriptors with a match priority
   value to allow unambiguous traffic matching on the Data-Plane.
  </t>
<t><xref target="fig_context"/> illustrates the generic context configuration
   model as used between a FPC Client and a FPC Agent.
  </t>

   <t>
<figure anchor="fig_context" title="Structure of Contexts">
        <artwork align="center"><![CDATA[

  TrafficSelector_1
           |
  profile-parameters
           |
  mobility-profile-- dl ------+
                     ^        |
                     |      qos-profile
                <ContextID1>       |
                     ^        per-mn-agg-max-dl_2
                     |
                <ContextID2>

  +-------------------+     +---------------------+
  | Bind 1..M traffic |     |  Bind 1..N traffic  |
  |    selectors to   | --> |  treatment / qos    |
  |     a Context     |     |  actions to a       |
  |                   |     |       Context       |
  +-------------------+     +---------------------+

 |                                                 |
 +-------------- Data-Plane Rule ------------------+
        ]]></artwork>
        <postamble></postamble>
      </figure>
</t>
<t>
   As depicted in <xref target="fig_context"/>, the context represents a mobiility
   session heirarchy.  A Client and Agent directly assigns values such as dowlink
   traffic descriptors, QoS information, etc.  A Client and Agent use the context
   identifiers to access the descriptors, qos information, etc. to perform modifications.
   From the viewpoint of packet processing, arriving packets are matched against traffic
   descriptors and processed according to the qos or other mobility profile related actions
   specified in the context's properties. If present, the final action is to use a context's
   tunnel information to encapsulate and forward the packet.
  </t>
<t>A second context also references context1 in the figure.  Based upon the techology a property
  in a parent context MAY be inherited by its descendants.  This permits concise over the wire
  representation.  When a Client deletes a parent context all children are also deleted.</t>

  <t>Actions defines how to apply action to classified traffic flow by descriptors,
    such as traffic management related action such as shaping, policing based on
    given bandwidth, and connectivity management actions, such as pass, drop,
    forward to given nexthop. Noted that Actions are extensibly defined by
    specific profiles which 3gpp, ietf or other SDO produced. QCI (QoS Class
    Identifier)) from 3gpp, and  rfc7222 from ietf can become action profiles. .
  </t>
  <t>The following table shows the Action fields</t>
  <texttable anchor="action_field" title="Action Fields">
    <ttcol align="left">Field</ttcol>
    <ttcol align="left">Type</ttcol>
    <ttcol align="left">Description</ttcol>
      <c>ACTION_ID </c>
      <c>FPC-Identity (<xref target="naming"/>)</c>
      <c>An Action's Identifier.</c>

      <c>TYPE</c>
      <c>[32, unsigned integer]</c>
      <c>Defines action type how to treat specified traffic flow,
        such as pass, drop, forward to given nexthop value and shape,
        police based on given bandwidth value, etc.</c>

      <c>VALUE</c>
      <c>Type specific</c>
      <c>The Action's value.</c>
  </texttable>

  <t>Descriptors define classifiers of specific traffic flow, such as based on
    source and destination addresses, protocols, port numbers of
    TCP/UDP/SCTP/DCCP and if any. Noted that Descriptors are extensibly defined
    by specific profiles which 3gpp, ietf or other SDO produced. TFT (Traffic
    flow template) from 3gpp, and  rfc6089 from ietf can become descriptor profiles.
  </t>
  <t>The following table shows the Descriptor fields</t>
  <texttable anchor="descriptor_field" title="Descriptor Fields" align="left">
    <ttcol align="left">Field</ttcol>
    <ttcol align="left">Type</ttcol>
    <ttcol align="left">Description</ttcol>
      <c>DESCRIPTOR_ID </c>
      <c>FPC-Identity (<xref target="naming"/>)</c>
      <c>A Descriptor's Identifier.</c>

      <c>TYPE</c>
      <c>[32, unsigned integer]</c>
      <c>Defines descriptor type, which classifies specific traffic flow, such as
        source and destination addresses, protocols, port numbers of
        TCP/UDP/SCTP/DCCP or if any.</c>

      <c>VALUE</c>
      <c>Type specific</c>
      <c>The Descriptor's value.</c>
  </texttable>
  <t>Policies contain a list of rules by their order value. Each rule contains descriptors with
  optional directionality and actions with order values that specifies ordering if the rule
  has multiple actions.</t>
  <t>The following table shows the Policy fields</t>
  <texttable anchor="policy_field" title="Policy Fields" align="left">
    <ttcol align="left">Field</ttcol>
    <ttcol align="left">Type</ttcol>
    <ttcol align="left">Description</ttcol>
      <c>POLICY_ID</c>
      <c>FPC-Identity (<xref target="naming"/>)</c>
      <c>A Policy's Identifier.</c>

      <c>RULES</c>
      <c>*[ RULE ]</c>
      <c>List of rules. See <xref target="rule_field"/></c>
  </texttable>
  <t>Rules consist of the following fields.</t>
  <texttable anchor="rule_field" title="Rule Fields" align="left">
    <ttcol align="left">Field</ttcol>
    <ttcol align="left">Type</ttcol>
    <ttcol align="left">Description</ttcol>
      <c>ORDER</c>
      <c>[16, INTEGER]</c>
      <c>Specifies ordering if the multiple rules are present.</c>

      <c>RULE_DESCRIPTORS</c>
      <c>*[ DESCRIPTOR_ID DIRECTION ]</c>
      <c>The DESCRIPTOR_ID refers to a DESCRIPTOR. DIRECTION [2, unsigned
        bits] is an ENUMERTION (uplink, downlink or both) that specifies
        descriptor to which direction applies, such as upstream or
        downstream.</c>

      <c>RULE_ACTIONS</c>
      <c>*[ ACTION_ID ORDER ]</c>
      <c>The ACTION_ID refers to an ACTION.  ORDER [8, unsigned integer]
        specifies action order when multiple actions are present.</c>
  </texttable>

  <t>A policy-group refers to  a set of policies which are to apply to
    ports and contexts. Policy-groups consist of the following fields.</t>
  <texttable anchor="policygroup_field" title="Policy Group Fields" align="left">
    <ttcol align="left">Field</ttcol>
    <ttcol align="left">Type</ttcol>
    <ttcol align="left">Description</ttcol>
      <c>POLICY_GROUP_ID</c>
      <c>FPC-Identity (<xref target="naming"/>)</c>
      <c>A Policy-Groups's Identifier.</c>

      <c>POLICIES</c>
      <c>*[ POLICY_ID ]</c>
      <c>Indicates each Policy which the Policy-group includes.</c>
  </texttable>

  <t>Port is a set of policies which will apply to contexts or any traffic
    in the Dataplane node. It contains a list of Policy-groups which apply
    to the port.</t>
  <texttable anchor="port_field" title="Port Fields" align="left">
    <ttcol align="left">Field</ttcol>
    <ttcol align="left">Type</ttcol>
    <ttcol align="left">Description</ttcol>
      <c>PORT_ID</c>
      <c>FPC-Identity (<xref target="naming"/>)</c>
      <c>A Port's Identifier.</c>

      <c>POLICIES</c>
      <c>*[ POLICY_GROUP_ID ]</c>
      <c>Indicates each Policy-Group in the list.</c>

      <c>DPN_GROUP_ID</c>
      <c>FPC-Identity (<xref target="naming"/>)</c>
      <c>Indicates DPN-Group in the case of the port is configured to attach
        to the DPN-group.  When a </c>

      <c>DPNS</c>
      <c>*[ DPN ]</c>
      <c>List of the DPNs which the Port accommodates. When DPN-group is indicated,
        this list is derived from the group definition.  See <xref target="context_dpn_fields"/></c>
  </texttable>

  <t>An endpoint of a mobility session is abstracted as a context. The fields
    of a context is shown in table <xref target="context_fields"/>.</t>
  <texttable anchor="context_fields" title="Context Fields" align="left">
    <ttcol align="left">Field</ttcol>
    <ttcol align="left">Type</ttcol>
    <ttcol align="left">Description</ttcol>
      <c>CONTEXT_ID</c>
      <c>FPC-Identity (<xref target="naming"/>)</c>
      <c>A Context's Identifier.</c>

      <c>PORTS</c>
      <c>*[ PORT_ID ]</c>
      <c>List of Ports. When a context is applied to port(s), the context
        is configured by policies of port(s).  IF the Port is assigned to a DPN that is different
        than the one assigned to this Context it MUST result in an error.</c>

      <c>DELEGATING IP PREFIXES</c>
      <c>*[ IP_PREFIX ]</c>
      <c>List of IP prefixes to be delegated to the mobile node of the
        context. An IP_PREFIX is an IPv4 or IPv6 PREFIX.</c>

      <c>UPLINK</c>
      <c>TUN_LOCAL_ADDRESS TUN_REMOTE_ADDRESS TUN_MTU TUN_PAYLOAD_TYPE TUN_TYPE TUN_IF
        [ MOB_PROFILE_TUN_PARAMS ] [ NEXTHOP ] [ QOS_PARAMS ]
        [ VENDOR_SPECIFIC_PARAMS ] </c>
      <c>Uplink information. See <xref target="context_link_fields"/>.</c>

      <c>DOWNLINK</c>
      <c>TUN_LOCAL_ADDRESS TUN_REMOTE_ADDRESS TUN_MTU TUN_PAYLOAD_TYPE TUN_TYPE TUN_IF
        [ MOB_PROFILE_TUN_PARAMS ] [ NEXTHOP ] [ QOS_PARAMS ]
        *[ VENDOR_SPECIFIC_PARAM ] </c>
      <c>Uplink information. See <xref target="context_link_fields"/>.</c>

      <c>PARENT_CONTEXT_ID</c>
      <c>FPC-Identity (<xref target="naming"/>)</c>
      <c>Indicates context which this context associated with. This will help to
        indicate relationships such as default/dedicated bearer relation.</c>

      <c>DPN_GROUP_ID</c>
      <c>FPC-Identity (<xref target="naming"/>)</c>
      <c>Indicates DPN-Group in the case of the context is configured to attach
        to the DPN-group.</c>

      <c>DPNS</c>
      <c>*[ DPN ]</c>
      <c>List of the DPNs which the Context accommodates. When DPN-group is indicated,
        this list is derived from the group definition.  See <xref target="context_dpn_fields"/></c>
  </texttable>

  <texttable anchor="context_link_fields" title="Context Downlink/Uplink Field Definitions" align="left">
    <ttcol align="left">Field</ttcol>
    <ttcol align="left">Type</ttcol>
    <ttcol align="left">Description</ttcol>
      <c>TUN_LOCAL_ADDRESS</c>
      <c>IP Address</c>
      <c>Endpoint address of the DPN. [NOTE 1]</c>

      <c>TUN_REMOTE_ADDRESS</c>
      <c>IP Address</c>
      <c>Endpoint address of the remote DPN. [NOTE 1]</c>

      <c>TUN_MTU</c>
      <c>[32, unsigned integer]</c>
      <c>Specifies profile specific direction (uplink/downlink) tunnel's MTU.</c>

      <c>TUN_PAYLOAD_TYPE</c>
      <c>[2, bits]</c>
      <c>An enumeraiton of the tunnel payload type: payload_ipv4(0), payload_ipv6(1) or payload_dual(2).</c>

      <c>TUN_TYPE</c>
      <c>[8, unsigned integer]</c>
      <c>An enumeration that specifies the tunnel subtype. Current values include IP-in-IP(0), UDP(1)
         GRE(2) and GTP(3).</c>

      <c>INPUT_IF</c>
      <c>[16, unsigned integer]</c>
      <c>Input interface index.</c>

      <c>MOB_PROFILE_TUN_PARAMS</c>
      <c>[ IETF_PMIP_MOB_PROFILE |
           3GPP_MOB_PROFILE ]</c>
      <c>Specifies profile specific direction (uplink/downlink) tunnel parameters to the
        DPN. The profiles includes GTP/TEID for 3gpp profile, GRE/Key for ietf-pmip profile,
        or new profile if anyone will define it. [NOTE 1]</c>

      <c>NEXTHOP</c>
      <c>[ IP Address | MAC Address | SPI | MPLS Label | SID | Interface Index ] (See <xref target="nexthop_subtypes"/>).</c>
      <c>Indicates nexthop information of downlink in access network or the uplink in external
        network, such as IP address, MAC address, SPI of service function chain, SID of segment
        routing, or if any. [NOTE 1]</c>

      <c>QOS_PARAMS</c>
      <c>[ 3GPP_QOS | PMIP_QOS ]</c>
      <c>Specifies profile specific QoS parameter of downlink/uplink, such as QCI/TFT for 3gpp profile,
        rfc6089/7222 for ietf-pmip, or extensions of this specification. [NOTE 1]</c>

      <c>VENDOR_SPECIFIC_PARAM</c>
      <c> Varies </c>
      <c>Vendor specific parameter. [NOTE 1]</c>
      <postamble>
        NOTE 1 - These parameters are extensible.  The Types may be extended for Field value by
        future specifications or in the case of Vendor Specific Attributes by enterprises.
      </postamble>
  </texttable>

  <texttable anchor="context_dpn_fields" title="Context DPN Fields" align="left">
    <ttcol align="left">Field</ttcol>
    <ttcol align="left">Type</ttcol>
    <ttcol align="left">Description</ttcol>

    <c>DPN_ID</c>
    <c>FPC-Identity (<xref target="naming"/>)</c>
    <c>DPN Identifier.</c>

    <c>DIRECTION</c>
    <c>[2, bits]</c>
    <c>Indicates if the DPN serves uplink(0), downlink(1) or
    both(2).</c>

    <c>MOB_PROFILE_PARAMS</c>
    <c>TUN_LOCAL_ADDRESS TUN_REMOTE_ADDRESS TUN_MTU
        TUN_PAYLOAD_TYPE TUN_TYPE
        [ MOB_PROFILE_TUN_PARAMS ] [ NEXTHOP ] [ QOS_PARAMS ]
        [ VENDOR_SPECIFIC_PARAMS ] [ TUN_IF ]</c>
    <c>Mobility Profile information. See <xref target="context_link_fields"/>.</c>

    <c>DPN_PARAMS</c>
    <c> Varies </c>
    <c>Specific parameters, such like if-index, tunnel-if-number
      that must be unique in the DPN.</c>
  </texttable>

  <section anchor="topology" title="Topology Structures">
  <t>This section defines topology structures such as DPNs and DPN Groups.</t>
  <texttable anchor="dpn_fields" title="DPN Fields" align="left">
    <ttcol align="left">Field</ttcol>
    <ttcol align="left">Type</ttcol>
    <ttcol align="left">Description</ttcol>

    <c>DPN_ID</c>
    <c>FPC-Identity. See <xref target="naming"/></c>
    <c>DPN Identifier.</c>

    <c>IP_ADRRESS</c>
    <c>IP Address</c>
    <c>DPN's IP Address.</c>

    <c>CONTROL_PROTOCOL</c>
    <c>Enumeration</c>
    <c>Specifies control protocol, such as BGP, Netconf, Restconf, FORCES, XMPP,
      Openflow, if any.</c>

    <c>DPN_GROUPS</c>
    <c>FPC-Identity. See <xref target="naming"/></c>
    <c>Indicates DPN-Groups where DPN works as a member of the DPN-Group.</c>
  </texttable>

  <texttable anchor="dpn_groups" title="DPN Groups" suppress-title="false" align="left">
    <ttcol align="left">Field</ttcol>
    <ttcol align="left">Type</ttcol>
    <ttcol align="left">Description</ttcol>

    <c>DPN_GROUP_ID</c>
    <c>FPC-Identity. See <xref target="naming"/></c>
    <c>DPN Group Identifier.</c>

    <c>FORWARDING_PLANE_ROLE</c>
    <c>Enumeration</c>
    <c>Defines forwarding-plane role of the DPN-Group, such as access-dpn, L2/L3 anchor-dpn.</c>

    <c>ACCESS_TYPE</c>
    <c>Enumeration</c>
    <c>Defines access type which the DPN-Group capable, such as ethernet(802.3/11), 3gpp cellular(S1,
      RAB), if any. </c>

    <c>MOBILITY_PROFILE</c>
    <c><xref target="context_link_fields"/></c>
    <c>Defines supporting mobility profile, such as ietf-pmip, 3gpp, or new profile if anyone will define
      it. When those profiles are correctly defined, some or all of forwarding-plane parameters of
      contexts can be automatically derived from the profile by FPC agent.</c>

    <c>PEER_DPN_GROUPS</c>
    <c>DPN_GROUP_ID REMOTE_ENDPOINT_ADDRESS LOCAL_ENDPOINT_ADDRESS
    TUN_MTU MOB_PROFILE_TUN_PARAMS FORWARDING_PLANE_ROLE</c>
    <c>Indicates DPN-Groups where DPN works as a member of the DPN-Group.</c>

    <c>REMOTE_ENDPOINT_ADDRESS</c>
    <c>IP Address</c>
    <c>Defines Endpoint address of the peering DPN-Group.</c>

    <c>LOCAL_ENDPOINT_ADDRESS</c>
    <c>IP Address</c>
    <c>Defines Endpoint address of its own DPN-Group to peer the remote DPN-Group. </c>
  </texttable>
  </section>

  <section anchor="mess_notifications" title="Monitors">
    <texttable anchor="monitor_structs" title="Monitor Structures and Attributes" align="left">
      <ttcol align="left">Field</ttcol>
      <ttcol align="left">Type</ttcol>
      <ttcol align="left">Description</ttcol>

      <c>MONITOR_ID</c>
      <c>FPC-Identity. See <xref target="naming"/></c>
      <c>Identifies a registered monitor.</c>

      <c>EVENT_TYPE_ID</c>
      <c>[8, Event Type ID]</c>
      <c>Identifies an event type (unsigned integer).</c>

      <c>MONITOR</c>
      <c>MONITOR_ID TARGET [REPORT_CONFIG]</c>
      <c>A Monitor.</c>

      <c>TARGET</c>
      <c>FPC-Identity. See <xref target="naming"/></c>
      <c>A Target MAY be an entity, e.g. Context, port, etc. or it may be the attribute of an entity.  When
      it is an attribute the fully qualified path (instance identifier) is reuqired.  This is equal to the
      FPC-Identity of the top level structure concatenated by a '/' and the relative path to the attribute.</c>

      <c>REPORT_CONFIG</c>
      <c>[8, REPORT-TYPE] [TYPE_SPECIFIC_INFO]</c>
      <c>The type of report and type-specific configuration.</c>

      <c>PERIODIC_CONFIG</c>
      <c>[32, period]</c>
      <c>period specifies the report interval (ms).</c>

      <c>THRESHOLD_CONFIG</c>
      <c>[32, low] [32, hi]</c>
      <c>low and high thresholds (at least one value must be present)</c>

      <c>SCHEDULED_CONFIG</c>
      <c>[32, time]</c>
      <c>time specifies when the report must be sent.</c>

      <c>EVENTS_CONFIG</c>
      <c>*[EVENT_TYPE_ID]</c>
      <c>List of events that triggers a report.</c>
    </texttable>
    <texttable anchor="notify_structs" title="Monitor Notifications" align="left">
      <ttcol align="left">Field</ttcol>
      <ttcol align="left">Type</ttcol>
      <ttcol align="left">Description</ttcol>

      <c>NOTIFICATION_ID</c>
      <c>[32, unsiged integer]</c>
      <c>Notifiction Identifier.</c>

      <c>TRIGGER</c>
      <c>[32, unsigned integer]</c>
      <c>The trigger for this notification.</c>

      <c>NOTIFY</c>
      <c>NOTIFICATION_ID MONITOR_ID TRIGGER [32, timestamp] [NOTIFICATION_DATA]</c>
      <c>A Notification. timestamp notes when the event occurred. Notification Data is
      specific to the TRIGGER and Monitor type.</c>
    </texttable>
    <t>TRIGGERS include but are not limited to the following values:
      <list style="symbols">
        <t>Events specified in the Event List of an EVENTS CONFIG</t>
        <t>LOW_THRESHOLD_CROSSED</t>
        <t>HIGH_THRESHOLD_CROSSED</t>
        <t>PERIODIC_REPORT</t>
        <t>SCHEDULED_REPORT</t>
        <t>PROBED</t>
        <t>DEREG_FINAL_VALUE</t>
      </list>
    </t>
  </section>
 </section>

  <section anchor="mess_attributes" title="Message Attributes">
    <section anchor="op-header" title="Header">
      <t>Each operation contains a header with the following fields:</t>
    <texttable anchor="op-header-tables" title="Message Header Fields">
    <ttcol align="left">Field</ttcol>
    <ttcol align="left">Type</ttcol>
    <ttcol align="left">Description</ttcol>

    <c>CLIENT_ID</c>
    <c>FPC-Identity (<xref target="naming"/>)</c>
    <c>FPC Client Identifier</c>

    <c>DELAY</c>
    <c>[32, unsigned integer]</c>
    <c>Delay, in milliseconds, from the time the operation is received by the Agent for the
      operation(s) to take effect.</c>

    <c>SESSION_STATE</c>
    <c>[8, session state] </c>
    <c>Sets the expected state of the entities embedded in the operation body after successful
      completion of the operation. This can be 'complete', 'incomplete' or 'outdated'. Any operation
      that is 'incomplete' MAY NOT result in communication between the Agent and DPN. If the result is
      'outdated' any new operations on these entities or new references to these entities have unpredictable
      results.</c>

    <c>ADMIN_STATE </c>
    <c>[8, admin state]</c>
    <c>Sets the administrative status for all entities. If the status is set to virtual, any existing data on the
      DPN is removed. If the value is set to disabled, then an operation will occur on the DPN IF the entity
      exists on the DPN. If set to 'active' the DPN will be provisioned. Values are 'enabled', 'disabled' or
      'virtual'.</c>

    <c>OP_TYPE</c>
    <c>[8, op type]</c>
    <c>The type of operation. Valid values are 'create', 'update', 'query' or 'delete'.</c>

    <c>COMMAND_SET</c>
    <c>FPC Command Bitset</c>
    <c>If supported by the Agent. See <xref target="commandsets"/>.</c>
    </texttable>
    </section>

    <section anchor="op-body" title="Body">
    <t>An operation body contains an operation identifier an lists of entities.</t>
    <texttable anchor="op_input" title="Message Body Fields">
    <ttcol align="left">Field</ttcol>
    <ttcol align="left">Type</ttcol>
    <ttcol align="left">Description</ttcol>

    <c>OP_ID</c>
    <c>[64, unsigned integer]</c>
    <c>Operation identifier which is used in responses and related notifications.</c>

    <c>CLONES</c>
    <c>*[ FPC-Identity FPC-Identity ] (<xref target="naming"/>)</c>
    <c>If supported by the Agent, this is a list of clone instructions.  The first argument
      is the entity to be cloned and the second argument is the name of the newly cloned entity.
      See <xref target="cloning"/></c>

    <c>DESCRIPTORS</c>
    <c>*[ DESCRIPTOR ]</c>
    <c>List of descriptors.</c>

    <c>ACTIONS</c>
    <c>*[ ACTION ]</c>
    <c>List of actions.</c>

    <c>POLICIES</c>
    <c>*[ POLICY ]</c>
    <c>List of policies.</c>

    <c>POLICY_GROUPS</c>
    <c>*[ POLICY_GROUP ]</c>
    <c>List of policy-groups.</c>

    <c>PORTS</c>
    <c>*[ PORT [ COMMAND_SET ] ]</c>
    <c>List of ports that may optionally come with Command bitsets, if Command Sets are
      supported by the Agent. See <xref target="commandsets"/>.</c>

    <c>CONTEXTS</c>
    <c>*[ CONTEXT [ COMMAND_SET ] ]</c>
    <c>List of contexts that may optionally come with Command bitsets, if Command Sets are
      supported by the Agent. See <xref target="commandsets"/>.</c>
    </texttable>
    </section>
  </section>
    <section anchor="response_detail" title="Operation Response">
      <section anchor="immediateresp_detail" title="Immediate Response">
    <t>A RESPONSE_BODY consists of the following fields.</t>
    <texttable anchor="op_respbody" title="RESPONSE_BODY Fields">
    <ttcol align="left">Field</ttcol>
    <ttcol align="left">Type</ttcol>
    <ttcol align="left">Operation Types Create(C), Update(U), Query(Q) and Delete(D)</ttcol>
    <ttcol align="left">Description</ttcol>

    <c>DESCRIPTORS</c>
    <c>*[ DESCRIPTOR ]</c>
    <c>C,U</c>
    <c>List of Descriptors</c>

    <c>ACTIONS</c>
    <c>*[ ACTION ]</c>
    <c>C,U</c>
    <c>List of actions.</c>

    <c>POLICIES</c>
    <c>*[ POLICY ]</c>
    <c>C,U</c>
    <c>List of Policies</c>

    <c>POLICY_GROUPS</c>
    <c>*[ POLICY_GROUP ]</c>
    <c>C,U</c>
    <c>List of Policy-groups.</c>

    <c>PORTS</c>
    <c>*[ PORT [ COMMAND_SET ] ]</c>
    <c>C,U</c>
    <c>List of Ports that may optionally come with Command bitsets, if Command Sets are
      supported by the Agent. See <xref target="commandsets"/>.</c>

    <c>CONTEXTS</c>
    <c>*[ CONTEXT [ COMMAND_SET ] ]</c>
    <c>C,U</c>
    <c>List of Contexts that may optionally come with Command bitsets, if Command Sets are
      supported by the Agent. See <xref target="commandsets"/>.</c>

    <c>TARGETS</c>
    <c>*[ FPC-Identity (<xref target="naming"/>) *[DPN_ID] ]</c>
    <c>Q,D</c>
    <c>List of targets for the operation and assocated DPN_IDs (optional).  If no DPN_IDs are
      present the Agent MUST locate all associated DPNs via internal mechanisms to delete the
      target.</c>
    </texttable>

    <t>If an error occurs the following information is returned.
    <list>
      <t>ERROR_TYPE_ID (Unsigned 32) - The identifier of a specific error type
      </t><t>ERROR_INFORMATION - An OPTIONAL string of no more than 1024 characters.
    </t></list>
    </t>
      </section>
      <section anchor="asyncnotification_detail" title="Asynchronous Notification">
      <t>A CONFIG_RESULT_NOTIFY includes the following data</t>
    <texttable anchor="ayncnotify_detail" title="CONFIG_RESULT_NOTIFY Fields">
    <ttcol align="left">Field</ttcol>
    <ttcol align="left">Type</ttcol>
    <ttcol align="left">Description</ttcol>
      <c>AGENT_ID </c>
      <c>FPC-Identity (<xref target="naming"/>)</c>
      <c>FPC Agent Identifier</c>

      <c>NOTIFICATION_ID </c>
      <c>[32, unsigned integer]</c>
      <c>A Notification Identifier used to determ;ine notification order.</c>

      <c>TIMESTAMP</c>
      <c>[32, unsigned integer]</c>
      <c>The time that the notification originated from the Agent.</c>

      <c>DATA</c>
      <c>*[ OP_ID RESPONSE_BODY ]</c>
      <c>A list of OP_ID / RESPONSE_BODY (<xref target="op_respbody"/>) pairs.</c>
      </texttable>
      </section>
    </section>
  </section>

<section title="Security Considerations">

<t>Detailed protocol implementations for DMM Forwarding Policy Configuration must ensure integrity
of the information exchanged between an FPC Client and an FPC Agent. Required Security Associations
may be derived from co-located functions, which utilize the FPC Client and FPC Agent respectively.
</t>

  </section>

<section anchor="derived_attrs" title="Derived and Subtype Attributes">
<t>This section notes derived attributes.</t>
  <texttable anchor="descriptor_subtypes" title="Descriptor Subtypes" align="left">
    <ttcol align="left">Field</ttcol>
    <ttcol align="left">Type Value</ttcol>
    <ttcol align="left">Type</ttcol>
    <ttcol align="left">Description</ttcol>

    <c>TO_PREFIX</c>
    <c>0</c>
    <c>[IP Address] [ Prefix Len ]</c>
    <c>Aggregated or per-host destination IP address/prefix descriptor.</c>

    <c>FROM_PREFIX</c>
    <c>1</c>
    <c>[IP Address] [ Prefix Len ]</c>
    <c>Aggregated or per-host source IP address/prefix descriptor.</c>

    <c>TRAFFIC_SELECTOR</c>
    <c>2</c>
    <c>Format per specification <xref target="RFC6088"/>.</c>
    <c>Traffic Selector, format as per <xref target="RFC6088"/>.</c>
  </texttable>

  <texttable anchor="action_subtypes" title="Action Subtypes" align="left">
    <ttcol align="left">Field</ttcol>
    <ttcol align="left">Type Value</ttcol>
    <ttcol align="left">Type</ttcol>
    <ttcol align="left">Description</ttcol>

    <c>DROP</c>
    <c>0</c>
    <c>Empty</c>
    <c>Drop the associated packets.</c>

    <c>REWRITE</c>
    <c>1</c>
    <c>[in_src_ip] [out_src_ip]
       [in_dst_ip] [out_dst_ip]
       [in_src_port] [out_src_port]
       [in_dst_port] [out_dst_port]</c>
    <c>Rewrite IP Address (NAT) or IP Address / Port (NAPT).</c>

    <c>COPY_FORWARD</c>
    <c>2</c>
    <c>FPC-Identity. See <xref target="naming"/>.</c>
    <c>Copy all packets and forward them to the provided identity.  The value of the
    identity MUST be a port or context.</c>
  </texttable>

  <texttable anchor="nexthop_subtypes" title="Next Hop Subtypes" align="left">
    <ttcol align="left">Field</ttcol>
    <ttcol align="left">Type Value</ttcol>
    <ttcol align="left">Type</ttcol>
    <ttcol align="left">Description</ttcol>

    <c>IP_ADDR</c>
    <c>0</c>
    <c>IP Address</c>
    <c>An IP Address.</c>

    <c>MAC_ADDR</c>
    <c>1</c>
    <c>MAC Address</c>
    <c>A MAC Address.</c>

    <c>SERVICE_PATH_ID</c>
    <c>2</c>
    <c>[24, unsigned integer]</c>
    <c>Service Path Identifier (SPI)</c>

    <c>MPLS_LABEL</c>
    <c>3</c>
    <c>[20, unsigned integer]</c>
    <c>MPLS Label</c>

    <c>NSH</c>
    <c>4</c>
    <c>[SERVICE_PATH_ID] [8, unsigned integer]</c>
    <c>Included NSH which is a SPI and Service Index (8 bits).</c>

    <c>INTERFACE_INDEX</c>
    <c>5</c>
    <c>[16, unsigned integer]</c>
    <c>Interface Index (an unsigned integer).</c>
  </texttable>

  <texttable anchor="qos_subtypes" title="QoS Subtypes" align="left">
    <ttcol align="left">Field</ttcol>
    <ttcol align="left">Type Value</ttcol>
    <ttcol align="left">Type</ttcol>
    <ttcol align="left">Description</ttcol>

    <c>QOS</c>
    <c>0</c>
    <c>[qos index type] [index] [DSCP]</c>
    <c>Refers to a single index and DSCP to write to the packet.</c>

    <c>GBR</c>
    <c>1</c>
    <c>[32, unsigned integer]</c>
    <c>Guaranteed bit rate.</c>

    <c>MBR</c>
    <c>2</c>
    <c>[32, unsigned integer]</c>
    <c>Maximum bit rate.</c>

    <c>PMIP_QOS</c>
    <c>3</c>
    <c>Varies by Type</c>
    <c>A non-traffic selector PMIP QoS Attribute per <xref target="RFC7222"/></c>
  </texttable>

  <texttable anchor="tunnel_subtypes" title="Tunnel Subtypes" align="left">
    <ttcol align="left">Field</ttcol>
    <ttcol align="left">Type Value</ttcol>
    <ttcol align="left">Type</ttcol>
    <ttcol align="left">Description</ttcol>

    <c>IPIP_TUN</c>
    <c>0</c>
    <c></c>
    <c>IP in IP Configuration</c>

    <c>UDP_TUN</c>
    <c>1</c>
    <c>[src_port] [dst_port]</c>
    <c>UDP Tunnel - source and/or destination port</c>

    <c>GRE_TUN</c>
    <c>2</c>
    <c>[32, GRE Key]</c>
    <c>GRE Tunnel.</c>
  </texttable>

  <t>The following COMMAND_SET values are supported for IETF_PMIP.
    <list style="symbols">
      <t>assign-ip - Assign the IP Address for the mobile session.</t>
      <t>assign-dpn - Assign the Dataplane Node.</t>
      <t>session - Assign values for the Session Level.</t>
      <t>uplink - Command applies to uplink.</t>
      <t>downlink - Command applies to downlink.</t>
    </list>
  </t>

 <section anchor="thregpp" title="3GPP Specific Extenstions">
  <t>3GPP support is optional and detailed in this section.</t>
  <texttable anchor="threegpp_attributes" title="3GPP Attributes and Structures">
    <ttcol align="left">Field</ttcol>
    <ttcol align="left">Type Value</ttcol>
    <ttcol align="left">Namespace / Entity Extended</ttcol>
    <ttcol align="left">Type</ttcol>
    <ttcol align="left">Description</ttcol>

    <c>GTPV1</c>
    <c>3</c>
    <c>Tunnel Subtypes namespace.</c>
    <c>LOCAL_TEID REMOTE_TEID SEQ_NUMBER</c>
    <c>Local and Remote Tunnel Endpoint Identifier (TEID).</c>

    <c>GTPV2</c>
    <c>4</c>
    <c>Tunnel Subtypes namespace.</c>
    <c>LOCAL_TEID REMOTE_TEID SEQ_NUMBER</c>
    <c>Local and Remote Tunnel Endpoint Identifier (TEID).</c>

    <c>LOCAL_TEID</c>
    <c>N/A</c>
    <c>N/A</c>
    <c>[32, unisgned integer]</c>
    <c>Local Tunnel Endpoint Identifier (TEID).</c>

    <c>REMOTE_TEID</c>
    <c>N/A</c>
    <c>N/A</c>
    <c>[32, unisgned integer]</c>
    <c>Remote Tunnel Endpoint Identifier (TEID).</c>

    <c>SEQ_NUMBER</c>
    <c>N/A</c>
    <c>N/A</c>
    <c>[32, unisgned integer]</c>
    <c>GTP Sequence Number. Used in failover and handover.</c>

    <c>TFT</c>
    <c>3</c>
    <c>Descriptors Subtypes namespace.</c>
    <c>Format per TS 24.008 Section 10.5.6.12.</c>
    <c>Traffic Flow Template (TFT).</c>

    <c>IMSI</c>
    <c>N/A</c>
    <c>Context (new attribute)</c>
    <c>[64, unsigned integer]</c>
    <c>International Mobile Subscriber Identity (IMSI).</c>

    <c>EBI</c>
    <c>N/A</c>
    <c>Context (new attribute)</c>
    <c>[4, unsigned integer]</c>
    <c>EPS Bearer Identity (EBI).</c>

    <c>3GPP_QOS</c>
    <c>4</c>
    <c>QoS Subtypes namespace.</c>
    <c>[8, qci] [32, gbr] [32, mbr] [32, apn_ambr] [32, ue_ambr] ARP</c>
    <c>3GPP QoS Structure with QoS Class Identifier (QCI), Guaranteed Bit Rate (GBR), Maximum Bit Rate (MBR),
    Access Point Name Aggregate Maximum Bit Rate (APN-AMBR), User Equipment Aggregate Maximum Bit Rate (UE-AMBR)
    and Allocation of Retention Priority (ARP).</c>

    <c>ARP</c>
    <c>N/A</c>
    <c>N/A</c>
    <c>See Allocation-Retention-Priority from <xref target="RFC7222"/></c>
    <c>Allocation of Retention Priority (ARP)</c>
  </texttable>

  <t>The following COMMAND_SET values are supported for 3GPP.
    <list style="symbols">
      <t>assign-ip - Assign the IP Address for the mobile session.</t>
      <t>assign-dpn - Assign the Dataplane Node.</t>
      <t>assign-fteid-ip - Assign the Fully Qualified TEID (F-TEID) LOCAL IP address.</t>
      <t>assign-fteid-teid - Assign the Fully Qualified TEID (F-TEID) LOCAL TEID.</t>
      <t>session - Assign values for the Session Level.  When this involves 'assign-fteid-ip' and 'assign-fteid-teid' this implies the values are part
        of the default bearer.</t>
      <t>uplink - Command applies to uplink.</t>
      <t>downlink - Comman applies to downlink.</t>
    </list>
  </t>
 </section>
</section>

<section anchor="IANA" title="IANA Considerations">

<t>This document provides a data model and protocol operation for DMM Forwarding Policy Configuration.
YANG models are currently included in the Appendix and will be updated per the next revision of this document
to specify the data model as well as to enable an implementation of the FPC protocol using RPC.</t>

<t>No actions from IANA are required. In case the semantics of this specification will be mapped
to a particular wire protocol, authors of an associated separate document will approach IANA for
the associated action to create a registry or add registry entries.
</t>

<!--
<t>
Detailed protocol specifications for DMM Forwarding Policy Configuration will follow the information
model as per this document and can be based on, for example, ReST-like or binary protocol formats.
Such protocol-specific details will be described in separate documents and may require IANA actions.
</t>
-->

</section>

    <section title="Work Team Participants">

    <t>Participants in the FPSM work team discussion include Satoru Matsushima, Danny Moses, Sri Gundavelli, Marco Liebsch,
       Pierrick Seite, Alper Yegin, Carlos Bernardos, Charles Perkins and Fred Templin.
    </t>

    </section>


  </middle>

  <back>
    <references title="Normative References">
    &rfc2119;
    &RFC7333;
    &RFC7429;
    &RFC6088;

    </references>

    <references title="Informative References">

    &RFC5213;
    &RFC3344;
    &RFC7222;

</references>

<!--

<reference anchor="3GPP-PCRFFR" target="http://www.3gpp.org">
        <front>
            <title>3GPP TS 29.816  3GPP TS 29.272 Study on PRCF Failure and Restoration</title>
            <author initials="" surname="" fullname="">
                <organization />
            </author>
        </front>
    </reference>

<reference anchor="3GPP-DIAM" target="http://www.3gpp.org">
        <front>
            <title>3GPP TS 29.272  Mobility Management Entity (MME) and Serving
	      GPRS Support Node (SGSN) related interfaces based on Diameter protocol </title>
            <author initials="" surname="" fullname="">
                <organization />
            </author>
        </front>
    </reference>


    </references>
-->

<section anchor="yangmodel" title="YANG Data Model for the FPC protocol">


<t>These modules define YANG definitions. Seven modules are defined:</t>

<t><list style="symbols">
<t>ietf-dmm-fpcbase (fpcbase) - Defines the base model for model as defined in this document</t>
<t>ietf-dmm-fpcagent (fpcagent) - Defines the FPC Agent entites and messages as defined in this document</t>

<t>ietf-pmip-qos (pmip-qos) - Defines proxy mobile IPv6 QoS parameters per RFC 7222</t>
<t>ietf-traffic-selectors-types (traffic-selectors) - Defines Traffic Selectors per RFC 6088</t>
<t>ietf-dmm-threegpp - Defines the base structures for 3GPP based IP mobility and augments fpcagent
  to support these parameters.</t>
<t>ietf-dmm-fpc-pmip - Augments fpcp-base to include PMIP Traffic Selectors as a Traffic Descriptor
subtype and pmip-qos QoS parameters, where applicable, as properties.</t>

<t>ietf-dmm-fpc-policyext - defines basic policy extensions, e.g. Actions and Descriptors, to fpcbase and
as defined in this document.</t>

</list></t>

<!-- template for YANG model, start -->
<section anchor="yangmodels" title="YANG Models">
  <section anchor="ietf-dmm-fpcbase" title="FPC Base YANG Model">
<t>
 <figure anchor="fig-ietf-dmm-fpcbase"
              title="FPC YANG base">
<artwork align="center"><![CDATA[
module ietf-dmm-fpcbase {
    namespace "urn:ietf:params:xml:ns:yang:fpcbase";
    prefix fpcbase;

    import ietf-inet-types { prefix inet; revision-date 2013-07-15; }

    organization "IETF DMM Working Group";
    contact "Satoru Matsushima <satoru.matsushima@g.softbank.co.jp>";

    description
    "This module contains YANG definition for
     Forwarding Policy Configuration Protocol.(FPCP)";

    revision 2016-08-03 {
        description "Changes based on -04 version of FPC draft.";
        reference "draft-ietf-dmm-fpc-cpdp-04";
    }

    typedef fpc-identity {
        type union {
            type uint32;
            type string;
            type instance-identifier;
        }
    }

    grouping target-value {
      leaf target {
          type fpc-identity;
      }
    }

    grouping targets-value {
      list targets {
          key "target";
          leaf target {
            type fpc-identity;
          }
          leaf dpn-id {
                type fpcbase:fpc-dpn-id;
          }
      }
    }

    // Descriptor Structure
    typedef fpc-descriptor-id {
        type fpcbase:fpc-identity;
        description "Descriptor-ID";
    }
    identity fpc-descriptor-type {
        description "A traffic descriptor";
    }
    grouping fpc-descriptor {
        leaf descriptor-id {
              type fpcbase:fpc-descriptor-id;
        }
        leaf descriptor-type {
          type identityref {
            base "fpc-descriptor-type";
          }
          description "Descriptor Type";
        }
        choice descriptor-value {
          case all-traffic {
            leaf all-traffic {
              type empty;
            }
          }
        }
    }

    // Action Structure
    typedef fpc-action-id {
        type fpcbase:fpc-identity;
        description "Action-ID";
    }
    identity fpc-action-type {
        description "Action Type";
    }
    grouping fpc-action {
        leaf action-id {
            type fpcbase:fpc-action-id;
        }
        leaf action-type {
          type identityref {
            base "fpc-action-type";
          }
          description "Action Type";
        }
        choice action-value {
          case drop {
            leaf drop {
              type empty;
            }
          }
        }
    }

    // Rule Structure
    grouping fpc-rule {
        description
          "FPC Rule";
        list action {
          key action-id;
          leaf order {
              type uint32;
          }
          uses fpcbase:fpc-action;
        }
        list descriptor {
          key descriptor-id;
          uses fpcbase:fpc-descriptor;
        }
    }

    // Policy Structures
    typedef fpc-policy-id {
        type fpcbase:fpc-identity;
    }
    grouping fpc-policy {
        leaf policy-id {
            type fpcbase:fpc-policy-id;
        }
        list rule {
            key order;
            leaf order {
              type uint32;
            }
            uses fpcbase:fpc-rule;
        }
    }

    // Policy Group
    typedef fpc-policy-group-id {
        type fpcbase:fpc-identity;
    }
    grouping fpc-policy-group {
        leaf policy-group-id {
            type fpcbase:fpc-policy-group-id;
        }
        leaf-list policy {
            type fpcbase:fpc-policy-id;
        }
    }

    // Mobility Structures
    // Port Group
    typedef fpc-port-id {
        type fpcbase:fpc-identity;
    }
    grouping fpc-port {
        leaf port-id {
            type fpcbase:fpc-port-id;
        }
        list policy-groups {
            key policy-group-id;
            uses fpcbase:fpc-policy-group;
        }
    }

    // Context Group
    typedef fpc-context-id {
        type fpcbase:fpc-identity;
    }
    grouping fpc-context-profile {
        description "A profile that applies to a specific direction";
        leaf remote-address {
            type inet:ip-address;
            description "Uplink endpoint address of the DPN which agent exists.";
        }
        leaf local-address {
            type inet:ip-address;
            description "Uplink endpoint address of the DPN which agent exists.";
        }
        leaf mtu {
            type uint32;
            description "Tunnel MTU size";
        }
        container mobility-profile {
            description "Specifies profile specific uplink tunnel parameters to the DPN which the agent exists. The profiles includes GTP/TEID for 3gpp profile, GRE/Key for ietf-pmip profile, or new profile if anyone will define it.";
            uses fpcbase:mobility-info;
        }
        container nexthop {
            uses fpcbase:fpc-nexthop;
        }
        container qos-profile {
            uses fpcbase:fpc-qos-profile;
        }
        container dpn-parameters {
        }
        list vendor-params {
            key "vendor-id vendor-type";
            uses fpcbase:vendor-attributes;
        }
    }

    typedef fpc-direction {
       type enumeration {
         enum uplink;
         enum downlink;
       }
    }
    grouping assignable-dpns {
        list dpns {
            key dpn-id;
            leaf dpn-id {
                type fpcbase:fpc-dpn-id;
            }
            leaf direction {
                type fpcbase:fpc-direction;
            }
            uses fpcbase:fpc-context-profile;
        }
    }
    grouping fpc-context {
        leaf context-id {
            type fpcbase:fpc-context-id;
        }
        leaf-list ports {
            type fpcbase:fpc-port-id;
        }
        leaf-list delegating-ip-prefixes {
            type inet:ip-prefix;
        }
        container ul {
            uses fpcbase:fpc-context-profile;
        }
        container dl {
            uses fpcbase:fpc-context-profile;
        }
        leaf parent-context {
            type fpcbase:fpc-context-id;
        }
        uses fpcbase:assignable-dpns;
    }

    // Mobility (Tunnel) Information
    grouping mobility-info {
        choice profile-parameters {
        }
    }

    // Next Hop Structures
    typedef fpcp-service-path-id {
        type uint32 {
            range "0..33554431";
        }
        description "SERVICE_PATH_ID";
    }

    identity fpc-nexthop-type {
        description "Next Hop Type";
    }
    identity fpc-nexthop-ip {
        base "fpcbase:fpc-nexthop-type";
    }
    identity fpc-nexthop-servicepath {
        base "fpcbase:fpc-nexthop-type";
    }
    grouping fpc-nexthop {
        leaf nexthop-type {
            type identityref {
              base "fpcbase:fpc-nexthop-type";
            }
        }
        choice nexthop-value {
            case ip {
                leaf ip {
                  type inet:ip-address;
                }
            }
            case servicepath {
                leaf servicepath {
                    type fpcbase:fpcp-service-path-id;
                }
            }
        }
    }

    // QoS Information
    identity fpc-qos-type {
        description "Base identity from which specific uses of QoS types are derived.";
    }
    grouping fpc-qos-profile {
        leaf qos-type {
            type identityref {
                base fpcbase:fpc-qos-type;
            }
            description "the profile type";
        }
        choice value {
        }
    }

    // Vendor Specific Attributes
    identity vendor-specific-type {
        description "Vendor Specific Attribute Type";
    }
    grouping vendor-attributes {
        leaf vendor-id {
            type fpcbase:fpc-identity;
        }
        leaf vendor-type {
            type identityref {
                base "fpcbase:vendor-specific-type";
            }
        }
        choice value {
            case empty-type {
                leaf empty-type {
                    type empty;
                }
            }
        }
    }

    // Topology
    typedef fpc-dpn-id {
        type fpcbase:fpc-identity;
        description "DPN Identifier";
    }
    identity fpc-dpn-control-protocol {
        description "DPN Control Protocol";
    }
    grouping fpc-dpn {
        leaf dpn-id {
            type fpcbase:fpc-dpn-id;
        }
        leaf address {
            type inet:ip-address;
        }
        leaf-list control-protocols {
            type identityref {
                base "fpcbase:fpc-dpn-control-protocol";
            }
        }
        leaf-list dpn-groups {
            type fpcbase:fpc-dpn-group-id;
        }
    }

    typedef fpc-dpn-group-id {
        type fpcbase:fpc-identity;
        description "DPN Group Identifier";
    }
    identity fpc-forwaridingplane-role {
        description "Role of DPN Group in the Forwarding Plane";
    }
    identity fpc-access-type {
        description "Access Type of the DPN Group";
    }
    identity fpc-mobility-profile-type {
        description "Mobility Profile Type";
    }

    grouping fpc-dpn-peer-group {
        leaf remote-dpn-group-id {
            type fpcbase:fpc-dpn-group-id;
        }
        leaf remote-endpoint-address {
            type inet:ip-address;
        }
        leaf local-endpoint-address {
            type inet:ip-address;
        }
        leaf mtu-size {
            type uint32;
        }
        uses fpcbase:mobility-info;
        leaf fowarding-role {
            type identityref {
                base "fpcbase:fpc-forwaridingplane-role";
            }
        }
    }

    // Events, Probes & Notifications
    identity event-type {
        description "Base Event Type";
    }

    typedef event-type-id {
        type uint32;
    }

    grouping monitor-id {
      leaf monitor-id {
        type fpcbase:fpc-identity;
      }
    }

    identity report-type {
      description "Type of Report";
    }
    identity periodic-report {
      base "fpcbase:report-type";
    }
    identity threshold-report {
      base "fpcbase:report-type";
    }
    identity scheduled-report {
      base "fpcbase:report-type";
    }
    identity events-report {
      base "fpcbase:report-type";
    }

    grouping report-config {
      choice event-config-value {
        case periodic-config {
            leaf period {
              type uint32;
            }
        }
        case threshold-config {
            leaf lo-thresh {
              type uint32;
            }
            leaf hi-thresh {
              type uint32;
            }
        }
        case scheduled-config {
            leaf report-time {
              type uint32;
            }
        }
        case events-config-ident {
            leaf-list event-identities {
              type identityref {
                base "fpcbase:event-type";
              }
            }
        }
        case events-config {
            leaf-list event-ids {
              type uint32;
            }
        }
      }
    }

    grouping monitor-config {
      uses fpcbase:monitor-id;
      uses fpcbase:target-value;
      uses fpcbase:report-config;
    }

    grouping report {
      uses fpcbase:monitor-config;
      choice report-value {
        leaf trigger {
          type fpcbase:event-type-id;
        }
        case simple-empty {
          leaf nothing {
            type empty;
          }
        }
        case simple-val32 {
          leaf val32 {
            type uint32;
          }
        }
      }
    }
}
     ]]></artwork>
        <postamble></postamble>
      </figure>
</t>
  </section>
  <section anchor="ietf-dmm-fpcagent" title="FPC Agent YANG Model">
<t>
 <figure anchor="fig-ietf-dmm-fpcagent"
              title="FPC YANG agent">
<artwork align="center"><![CDATA[
module ietf-dmm-fpcagent {
    namespace "urn:ietf:params:xml:ns:yang:fpcagent";
    prefix fpcagent;

    import ietf-dmm-fpcbase { prefix fpcbase; revision-date 2016-08-03; }
    import ietf-inet-types { prefix inet; revision-date 2013-07-15; }

    organization "IETF DMM Working Group";
    contact "Satoru Matsushima <satoru.matsushima@g.softbank.co.jp>";

    description
    "This module contains YANG definition for
     Forwarding Policy Configuration Protocol.(FPCP)";

    revision 2016-08-03 {
        description "Changes based on -04 version of FPC draft.";
        reference "draft-ietf-dmm-fpc-cpdp-04";
    }

    feature fpc-basic-agent {
        description "This is an agent co-located with a DPN.  In this case
        only DPN Peer Groups, the DPN Id and Control Protocols are exposed
        along with the core structures.";
    }
    feature fpc-multi-dpn {
        description "The agent supports multiple DPNs.";
    }
    feature fpc-cloning {
      description "An ability to support cloning in the RPC.";
    }
    feature fpc-basename-registry {
      description "Ability to track Base Names already provisioned on the Agent";
    }
    feature fpc-bundles {
      description "Ability for Client to send multiple bundles of actions to
        an Agent";
    }
    feature fpc-client-binding {
      description "Allows a FPC Client to bind a DPN to an Topology Object";
    }
    feature fpc-auto-binding {
      description "Allows a FPC Agent to advertise Topology Objects that could be DPNs";
    }
    feature instruction-bitset {
      description "Allows the expression of instructions (bit sets) over FPC.";
    }
    feature operation-ref-scope {
      description "Provides the scope of refeneces in an operation.  Used to optmize
        the Agent processing.";
    }

    typedef agent-identifier {
        type fpcbase:fpc-identity;
    }

    typedef client-identifier {
        type fpcbase:fpc-identity;
    }

    // Top Level Structures
    container fpc-entities {
      list contexts {
          key context-id;
          uses fpcbase:fpc-context;
      }
      list ports {
          key port-id;
          uses fpcbase:fpc-port;
      }
      list policy-groups {
          key "policy-group-id";
          uses fpcbase:fpc-policy-group;
      }
      list policies {
          key "policy-id";
          uses fpcbase:fpc-policy;
      }
      list descriptors {
        key descriptor-id;
        uses fpcbase:fpc-descriptor;
      }
      list actions {
          key action-id;
          uses fpcbase:fpc-action;
      }
    }

    container fpc-agent-info {
      // General Agent Structures
      leaf-list supported-features {
        type string;
      }

      // Common Agent Info
      list supported-events {
        key event;
        leaf event {
          type identityref {
            base "fpcbase:event-type";
          }
        }
        leaf event-id {
          type fpcbase:event-type-id;
        }
      }

      list supported-error-types {
        key error-type;
        leaf error-type {
          type identityref {
            base "fpcagent:error-type";
          }
        }
        leaf error-type-id {
          type fpcagent:error-type-id;
        }
      }

      // Base Name Registry Feature
      list basename-registry {
          description "A registy for multiple clients operating upon the same base,
            e.g. '/mcc:01/mnc:01' to determine if a Client has already provisioned
            common Policy on the Agent / DPN";
          if-feature fpcagent:fpc-basename-registry;
          key basename;
          leaf basename {
              type fpcbase:fpc-identity;
          }
          leaf state {
              type string;
          }
          leaf checkpoint {
              type string;
          }
      }
    }


    // Multi-DPN Agent Structures
    grouping fpc-dpn-group {
        leaf group-id {
            type fpcbase:fpc-dpn-group-id;
        }
        leaf fowarding-role {
            type identityref {
                base "fpcbase:fpc-forwaridingplane-role";
            }
        }
        leaf access-type {
            type identityref {
                base "fpcbase:fpc-access-type";
            }
        }
        leaf mobility-profile {
            type identityref {
                base "fpcbase:fpc-mobility-profile-type";
            }
        }
        list dpn-group-peers {
            key "remote-dpn-group-id";
            uses fpcbase:fpc-dpn-peer-group;
        }
    }

    container fpc-topology {
      // Basic Agent Topology Structures
      list dpn-group-peers {
          if-feature fpc-basic-agent;
          key "remote-dpn-group-id";
          uses fpcbase:fpc-dpn-peer-group;
      }
      leaf dpn-id {
        if-feature fpc-basic-agent;
        type fpcbase:fpc-dpn-id;
      }
      leaf-list control-protocols {
        if-feature fpc-basic-agent;
        type identityref {
          base "fpcbase:fpc-dpn-control-protocol";
        }
      }

      list dpn-groups {
          if-feature fpc-multi-dpn;
          key group-id;
          uses fpcagent:fpc-dpn-group;
      }
      list dpns {
          if-feature fpc-multi-dpn;
          key dpn-id;
          uses fpcbase:fpc-dpn;
      }
    }

    // RPC
    // RPC Specific Structures
    //Input Structures
    typedef admin-status {
        type enumeration {
            enum enabled { value 0; }
            enum disabled { value 1; }
            enum virtual { value 2; }
        }
    }

    typedef session-status {
        type enumeration {
            enum complete { value 0; }
            enum incomplete { value 1; }
            enum outdated { value 2; }
        }
    }

    typedef op-delay {
        type uint32;
    }

    typedef op-identifier {
        type uint64;
    }

    typedef ref-scope {
      description "Search scope for references in the operation.
        op - All references are contained in the operation body (intra-op)
        bundle - All references in exist in bundle (inter-operation/intra-bundle).
          NOTE - If this value comes in CONFIG call it is equivalen to 'op'.
        storage - One or more references exist outside of the operation and bundle.
          A lookup to a cache / storage is required.
        unknown - the location of the references are unknown.  This is treated as
          a 'storage' type.";
      type enumeration {
        enum op { value 0; }
        enum bundle { value 1; }
        enum storage { value 2; }
        enum unknown { value 3; }
      }
    }

    grouping instructions {
      container instructions {
        if-feature instruction-bitset;
        choice instr-type {
        }
      }
    }

    grouping op-header {
      leaf client-id {
        type fpcagent:client-identifier;
      }
      leaf delay {
        type op-delay;
      }
      leaf session-state {
        type session-status;
      }
      leaf admin-state {
        type admin-status;
      }
      leaf op-type {
        type enumeration {
          enum create { value 0; }
          enum update { value 1; }
          enum query { value 2; }
          enum delete { value 3; }
        }
      }
      leaf op-ref-scope {
          if-feature operation-ref-scope;
          type fpcagent:ref-scope;
      }
      uses fpcagent:instructions;
    }

    grouping clone-ref {
      leaf entity {
        type fpcbase:fpc-identity;
      }
      leaf source {
        type fpcbase:fpc-identity;
      }
    }

    identity command-set {
      description "protocol specific commands";
    }

    grouping context-operation {
      uses fpcbase:fpc-context;
      uses fpcagent:instructions;
    }

    grouping port-operation {
      uses fpcbase:fpc-port;
      uses fpcagent:instructions;
    }

    // Output Structure
    grouping payload {
      list descriptors {
        uses fpcbase:fpc-descriptor;
      }
      list actions {
        uses fpcbase:fpc-action;
      }
      list policies {
        uses fpcbase:fpc-policy;
      }
      list policy-groups {
        uses fpcbase:fpc-policy-group;
      }
      list ports {
        uses fpcagent:port-operation;
      }
      list contexts {
        uses fpcagent:context-operation;
      }
    }

    grouping op-input {
      uses fpcagent:op-header;
      leaf op-id {
        type op-identifier;
      }
      choice op_body {
        case create_or_update {
          list clones {
            if-feature fpc-cloning;
            key entity;
            uses fpcagent:clone-ref;
          }
          uses fpcagent:payload;
        }
        case delete_or_query {
          uses fpcbase:targets-value;
        }
      }
    }

    typedef result {
      type enumeration {
        enum ok { value 0; }
        enum err { value 1; }
        enum ok-notify-follows { value 2; }
      }
    }

    identity error-type {
      description "Base Error Type";
    }
    identity name-already-exists {
      description "Notification that an entity of the same name already exists";
    }

    typedef error-type-id {
      description "Integer form of the Error Type";
      type uint32;
    }

    grouping op-status-value {
      leaf op-status {
        type enumeration {
          enum ok { value 0; }
          enum err { value 1; }
        }
      }
    }

    grouping result-body {
      leaf op-id {
        type op-identifier;
      }
      choice result-type {
        case err {
          leaf error-type-id {
            type fpcagent:error-type-id;
          }
          leaf error-info {
            type string {
              length "1..1024";
            }
          }
        }
        case config-success {
          uses fpcagent:payload;
        }
        case empty-case {
        }
      }
    }

    // Common RPCs
    rpc configure {
      input {
        uses fpcagent:op-input;
      }
      output {
        leaf result {
          type result;
        }
        uses fpcagent:result-body;
      }
    }

    rpc configure-bundles {
      if-feature fpcagent:fpc-bundles;
      input {
        list bundles {
          key op-id;
          uses fpcagent:op-input;
        }
      }
      output {
        list bundles {
          key op-id;
          uses fpcagent:result-body;
        }
      }
    }

    rpc bind-dpn {
      if-feature fpcagent:fpc-client-binding;
      input {
        leaf node-id {
          type inet:uri;
        }
        uses fpcbase:fpc-dpn;
      }
      output {
        uses fpcagent:result-body;
      }
    }
    rpc unbind-dpn {
      if-feature fpcagent:fpc-client-binding;
      input {
        leaf dpn-id {
          type fpcbase:fpc-dpn-id;
        }
      }
      output {
        uses fpcagent:result-body;
      }
    }

    // Notification Messages & Structures
    typedef notification-id {
      type uint32;
    }

    grouping notification-header {
      leaf notification-id {
          type fpcagent:notification-id;
      }
      leaf timestamp {
          type uint32;
      }
    }

    notification config-result-notification {
      uses fpcagent:notification-header;
      choice value {
        case config-result {
          uses fpcagent:op-status-value;
          uses fpcagent:result-body;
        }
        case config-bundle-result {
          list bundles {
            uses fpcagent:op-status-value;
            uses fpcagent:result-body;
          }
        }
      }
    }

    rpc event_register {
        description "Used to register monitoring of parameters/events";
        input {
          uses fpcbase:monitor-config;
        }
        output {
          leaf monitor-result {
            type fpcagent:result;
          }
        }
    }

    rpc event_deregister {
        description "Used to de-register monitoring of parameters/events";
        input {
          list monitors {
            uses fpcbase:monitor-id;
          }
        }
        output {
          leaf monitor-result {
            type fpcagent:result;
          }
        }
    }

    rpc probe {
        description "Probe the status of a registered monitor";
        input {
          uses fpcbase:targets-value;
        }
        output {
          leaf monitor-result {
            type fpcagent:result;
          }
        }
    }

    notification notify {
        uses fpcagent:notification-header;
        choice value {
            case dpn-candidate-available {
              if-feature fpcagent:fpc-auto-binding;
              leaf node-id {
                type inet:uri;
              }
              leaf-list access-types {
                type identityref {
                  base "fpcbase:fpc-access-type";
                }
              }
              leaf-list mobility-profiles {
                type identityref {
                  base "fpcbase:fpc-mobility-profile-type";
                }
              }
              leaf-list forwarding-plane-roles {
                type identityref {
                  base "fpcbase:fpc-forwaridingplane-role";
                }
              }
            }
            case monitor-notification {
              choice monitor-notification-value {
                case simple-monitor {
                  uses fpcbase:report;
                }
                case bulk-monitors {
                  list reports {
                    uses fpcbase:report;
                  }
                }
              }
            }
        }
    }
}
     ]]></artwork>
        <postamble></postamble>
      </figure>
</t>
  </section>
  <section anchor="ietf-pmip-qos" title="PMIP QoS Model">
<t>
 <figure anchor="fig-ietf-pmip-qos"
              title="FPC YANG PMIP QoS">
<artwork align="center"><![CDATA[
module ietf-pmip-qos {
    yang-version 1;

    namespace
      "urn:ietf:params:xml:ns:yang:ietf-pmip-qos";

    prefix "qos-pmip";

    import ietf-inet-types {
    	prefix inet;
    	revision-date 2013-07-15;
    }
    import ietf-traffic-selector-types { prefix traffic-selectors; }

    organization
      "IETF DMM (Dynamic Mobility Management) Working Group";

    contact
      "WG Web:   <https://datatracker.ietf.org/wg/dmm/>
     WG List:  <mailto:dmm@ietf.org>

     WG Chair: Dapeng Liu
               <mailto:maxpassion@gmail.com>

     WG Chair: Jouni Korhonen
               <mailto:jouni.nospam@gmail.com>

     Editor:
               <mailto:>";

    description
      "This module contains a collection of YANG definitions for
     quality of service paramaters used in Proxy Mobile IPv6.

     Copyright (c) 2015 IETF Trust and the persons identified as
     authors of the code.  All rights reserved.

     Redistribution and use in source and binary forms, with or
     without modification, is permitted pursuant to, and subject
     to the license terms contained in, the Simplified BSD License
     set forth in Section 4.c of the IETF Trust's Legal Provisions
     Relating to IETF Documents
     (http://trustee.ietf.org/license-info).

     This version of this YANG module was created as part of the IETF
    	DMM FPC YANG modules; see the RFC itself for full legal notices.";

    revision 2016-02-10 {
        description "Initial revision";
        reference
         "RFC 7222: Quality-of-Service Option for Proxy Mobile IPv6";
    }

    // Type Definitions

    // QoS Option Field Type Definitions
	typedef sr-id {
		type uint8;
	    description
	     "An 8-bit unsigned integer used
	      for identifying the QoS Service Request.  Its uniqueness is within
	      the scope of a mobility session.  The local mobility anchor always
	      allocates the Service Request Identifier.  When a new QoS Service
	      Request is initiated by a mobile access gateway, the Service
	      Request Identifier in the initial request message is set to a
	      value of (0), and the local mobility anchor allocates a Service
	      Request Identifier and includes it in the response.  For any new
	      QoS Service Requests initiated by a local mobility anchor, the
	      Service Request Identifier is set to the allocated value.";
	  }

    typedef traffic-class {
    	type inet:dscp;
    	description
    		"Traffic Class consists of a 6-bit DSCP field followed by a 2-bit
    		reserved field.";
	   reference
		     "RFC 3289: Management Information Base for the Differentiated
		                Services Architecture
		      RFC 2474: Definition of the Differentiated Services Field
		                (DS Field) in the IPv4 and IPv6 Headers
		      RFC 2780: IANA Allocation Guidelines For Values In
		                the Internet Protocol and Related Headers";
    }

    typedef operational-code {
    	type enumeration {
    		enum RESPONSE { value 0; }
    		enum ALLOCATE { value 1; }
    		enum DE-ALLOCATE { value 2; }
    		enum MODIFY { value 3; }
    		enum QUERY { value 4; }
    		enum NEGOTIATE { value 5; }
    	}
    	description
    		"1-octet Operational code indicates the type of QoS request.

    	      RESPONSE:   (0)
    	         Response to a QoS request

    	      ALLOCATE:   (1)
    	         Request to allocate QoS resources

    	      DE-ALLOCATE:   (2)
    	         Request to de-Allocate QoS resources

    	      MODIFY:   (3)
    	         Request to modify QoS parameters for a previously negotiated
    	         QoS Service Request

    	      QUERY:   (4)
    	         Query to list the previously negotiated QoS Service Requests
    	         that are still active

    	      NEGOTIATE:   (5)
                Response to a QoS Service Request with a counter QoS proposal

              Reserved:   (6) to (255)
                Currently not used.  Receiver MUST ignore the option received
                with any value in this range.";
    }

    // QoS Attribute Types

    //The enumeration value for mapping - don't confuse with the identities
    typedef qos-attrubite-type-enum {
    	type enumeration {
    		enum Reserved { value 0; }
    		enum Per-MN-Agg-Max-DL-Bit-Rate { value 1; }
	        enum Per-MN-Agg-Max-UL-Bit-Rate { value 2; }
	        enum Per-Session-Agg-Max-DL-Bit-Rate { value 3; }
	        enum Per-Session-Agg-Max-UL-Bit-Rate { value 4; }
          enum Allocation-Retention-Priority { value 5; }
	      	enum Aggregate-Max-DL-Bit-Rate { value 6; }
	        enum Aggregate-Max-UL-Bit-Rate { value 7; }
	        enum Guaranteed-DL-Bit-Rate { value 8; }
	        enum Guaranteed-UL-Bit-Rate { value 9; }
	        enum QoS-Traffic-Selector { value 10; }
	        enum QoS-Vendor-Specific-Attribute { value 11; }
    	}
 		description
		"8-bit unsigned integer indicating the type of the QoS
	      attribute.  This specification reserves the following values.
	      (0) -  Reserved
	         This value is reserved and cannot be used

	      (1) -  Per-MN-Agg-Max-DL-Bit-Rate
	         Per-Mobile-Node Aggregate Maximum Downlink Bit Rate.

	      (2) -  Per-MN-Agg-Max-UL-Bit-Rate
	         Per-Mobile-Node Aggregate Maximum Uplink Bit Rate.

	      (3) -  Per-Session-Agg-Max-DL-Bit-Rate
	         Per-Mobility-Session Aggregate Maximum Downlink Bit Rate.

		    (4) -  Per-Session-Agg-Max-UL-Bit-Rate
              Per-Mobility-Session Aggregate Maximum Uplink Bit Rate.

 	      (5) -  Allocation-Retention-Priority
 	         Allocation and Retention Priority.

 	      (6) -  Aggregate-Max-DL-Bit-Rate
 	         Aggregate Maximum Downlink Bit Rate.

 	      (7) -  Aggregate-Max-UL-Bit-Rate
 	         Aggregate Maximum Uplink Bit Rate.

 	      (8) -  Guaranteed-DL-Bit-Rate
 	         Guaranteed Downlink Bit Rate.

 	      (9) -  Guaranteed-UL-Bit-Rate
 	         Guaranteed Uplink Bit Rate.

 	      (10) -  QoS-Traffic-Selector
 	         QoS Traffic Selector.

 	      (11) -  QoS-Vendor-Specific-Attribute
 	        QoS Vendor-Specific Attribute.

 	      (12) to (254) -  Reserved
 	         These values are reserved for future allocation.

 	      (255) -  Reserved
 	         This value is reserved and cannot be used.";
    }

    // Attribute Type as Identities
    // Added for convenience of inclusion and extension in other YANG modules.
    identity qos-attribute-type {
    	description
    		"Base type for Quality of Service Attributes";
    }

    identity Per-MN-Agg-Max-DL-Bit-Rate-type {
    	base qos-attribute-type;
    	description
    		"Per-Mobile-Node Aggregate Maximum Downlink Bit Rate.";
	}

 	identity Per-MN-Agg-Max-UL-Bit-Rate-type {
    	base qos-attribute-type;
    	description
    		"Per-Mobile-Node Aggregate Maximum Uplink Bit Rate";
 	}

 	identity Per-Session-Agg-Max-DL-Bit-Rate-type {
    	base qos-attribute-type;
    	description
    		"Per-Mobility-Session Aggregate Maximum Downlink Bit Rate.";
 	}

 	identity Per-Session-Agg-Max-UL-Bit-Rate-type {
    	base qos-attribute-type;
    	description
    		"Per-Mobility-Session Aggregate Maximum Uplink Bit Rate.";
 	}

 	identity Allocation-Retention-Priority-type {
    	base qos-attribute-type;
    	description
    		"Allocation and Retention Priority.";
 	}

 	identity Aggregate-Max-DL-Bit-Rate-type {
	  	base qos-attribute-type;
	  	description "Aggregate Maximum Downlink Bit Rate.";
 	}

  identity Aggregate-Max-UL-Bit-Rate-type {
      base qos-attribute-type;
      description "Aggregate Maximum Uplink Bit Rate.";
  }

  identity Guaranteed-DL-Bit-Rate-type {
      base qos-attribute-type;
      description "Guaranteed Downlink Bit Rate.";
  }

  identity Guaranteed-UL-Bit-Rate-type {
      base qos-attribute-type;
      description "Guaranteed Uplink Bit Rate.";
  }

  identity QoS-Traffic-Selector-type {
      base qos-attribute-type;
      description "QoS Traffic Selector.";
  }

  identity QoS-Vendor-Specific-Attribute-type {
      base qos-attribute-type;
      description "QoS Vendor-Specific Attribute.";
  }

  //value definitions
  typedef Per-MN-Agg-Max-DL-Bit-Rate-Value {
      type uint32;
      description
          "This is a 32-bit unsigned integer that
          indicates the aggregate maximum downlink bit rate that is
          requested/allocated for all the mobile node's IP flows.  The
          measurement units for Per-MN-Agg-Max-DL-Bit-Rate are bits per
          second.";
	}

 	typedef Per-MN-Agg-Max-UL-Bit-Rate-Value {
    	type uint32;
    	description
    		"This is a 32-bit unsigned integer that
    	      indicates the aggregate maximum uplink bit rate that is requested/
    	      allocated for the mobile node's IP flows.  The measurement units
    	      for Per-MN-Agg-Max-UL-Bit-Rate are bits per second.";
 	}

 	// Generic Structure for the uplink and downlink
 	grouping Per-Session-Agg-Max-Bit-Rate-Value {
 		leaf max-rate {
 			type uint32;
 			mandatory true;
 			description
 				"This is a 32-bit unsigned integer
 			      that indicates the aggregate maximum bit rate that is requested/allocated
 				  for all the IP flows associated with that mobility session.  The measurement
 				  units for Per-Session-Agg-Max-UL/DL-Bit-Rate are bits per second.";
 		}
 		leaf service-flag {
			type boolean;
			mandatory true;
			description
				"This flag is used for extending the scope of the
			      target flows for Per-Session-Agg-Max-UL/DL-Bit-Rate from(UL)/to(DL) the mobile
			      node's other mobility sessions sharing the same Service
			      Identifier. 3GPP Access Point Name (APN) is an example of a
			      Service Identifier, and that identifier is carried using the
			      Service Selection mobility option [RFC5149].

			      *  When the (S) flag is set to a value of (1), then the Per-
			         Session-Agg-Max-Bit-Rate is measured as an aggregate across
			         all the mobile node's other mobility sessions sharing the same
			         Service Identifier associated with this mobility session.

			      *  When the (S) flag is set to a value of (0), then the target
			         flows are limited to the current mobility session.

			      *  The (S) flag MUST NOT be set to a value of (1) when there is no
			         Service Identifier associated with the mobility session.";
			reference
				"RFC 5149 - Service Selection mobility option";
 		}
 		leaf exclude-flag {
 			type boolean;
 			mandatory true;
 			description
 				"This flag is used to request that the uplink/downlink
 			      flows for which the network is providing Guaranteed-Bit-Rate
 			      service be excluded from the target IP flows for which Per-
 			      Session-Agg-Max-UL/DL-Bit-Rate is measured.

 			      *  When the (E) flag is set to a value of (1), then the request is
 			         to exclude the IP flows for which Guaranteed-UL/DL-Bit-Rate
 			         is negotiated from the flows for which Per-Session-Agg-Max-UL/DL-Bit-Rate
 				     is measured.

 			      *  When the (E) flag is set to a value of (0), then the request is
 			         not to exclude any IP flows from the target IP flows for which
 			         Per-Session-Agg-Max-UL/DL-Bit-Rate is measured.

 			      *  When the (S) flag and (E) flag are both set to a value of (1),
 			         then the request is to exclude all the IP flows sharing the
 			         Service Identifier associated with this mobility session from
 			         the target flows for which Per-Session-Agg-Max-UL/DL-Bit-Rate is
 			         measured.";
 		}
 	}

 	grouping Allocation-Retention-Priority-Value {
 		leaf prioirty-level {
 			type uint8 {
 				range "0..15";
 			}
 			mandatory true;
 			description
 				"This is a 4-bit unsigned integer value.  It
 			      is used to decide whether a mobility session establishment or
 			      modification request can be accepted; this is typically used for
 			      admission control of Guaranteed Bit Rate traffic in case of
 			      resource limitations.  The priority level can also be used to

 			      decide which existing mobility session to preempt during resource
 			      limitations.  The priority level defines the relative timeliness
 			      of a resource request.

 			      Values 1 to 15 are defined, with value 1 as the highest level of
 			      priority.

 			      Values 1 to 8 should only be assigned for services that are
 			      authorized to receive prioritized treatment within an operator
 			      domain.  Values 9 to 15 may be assigned to resources that are
 			      authorized by the home network and thus applicable when a mobile
 			      node is roaming.";
 		}
 		leaf premption-capability {
 			type enumeration {
				enum enabled { value 0; }
				enum disabled { value 1; }
				enum reserved1 { value 2; }
				enum reserved2 { value 3; }
 			}
 			mandatory true;
 			description
 				"This is a 2-bit unsigned integer
 			      value.  It defines whether a service data flow can get resources
 			      that were already assigned to another service data flow with a
 			      lower priority level.  The following values are defined:

 			         Enabled (0): This value indicates that the service data flow is
 			         allowed to get resources that were already assigned to another
 			         IP data flow with a lower priority level.

 			         Disabled (1): This value indicates that the service data flow
 			         is not allowed to get resources that were already assigned to
 			         another IP data flow with a lower priority level.  The values
 			         (2) and (3) are reserved.";
 		}
 		leaf premption-vulnerability {
 			type enumeration {
				enum enabled { value 0; }
				enum disabled { value 1; }
				enum reserved1 { value 2; }
				enum reserved2 { value 3; }
 			}
 			mandatory true;
 			description
				"This is a 2-bit unsigned integer
 			      value.  It defines whether a service data flow can lose the
 			      resources assigned to it in order to admit a service data flow
 			      with a higher priority level.  The following values are defined:

 			         Enabled (0): This value indicates that the resources assigned
 			         to the IP data flow can be preempted and allocated to a service
 			         data flow with a higher priority level.

 			         Disabled (1): This value indicates that the resources assigned
 			         to the IP data flow shall not be preempted and allocated to a
 			         service data flow with a higher priority level.  The values (2)
 			         and (3) are reserved.";
 		}
 	}

 	typedef Aggregate-Max-DL-Bit-Rate-Value {
	  	type uint32;
	  	description
	  		"This is a 32-bit unsigned integer that
	        indicates the aggregate maximum downlink bit rate that is
	        requested/allocated for downlink IP flows.  The measurement units
	        for Aggregate-Max-DL-Bit-Rate are bits per second.";
 	}

  	typedef Aggregate-Max-UL-Bit-Rate-Value {
    	type uint32;
    	description
    		"This is a 32-bit unsigned integer that
    	      indicates the aggregate maximum downlink bit rate that is
    	      requested/allocated for downlink IP flows.  The measurement units
    	      for Aggregate-Max-DL-Bit-Rate are bits per second.";
  	}

  	typedef Guaranteed-DL-Bit-Rate-Value {
	  	type uint32;
	  	description
	  		"This is a 32-bit unsigned integer that
	        indicates the guaranteed bandwidth in bits per second for downlink
	        IP flows.  The measurement units for Guaranteed-DL-Bit-Rate are
	        bits per second.";
  	}

  	typedef Guaranteed-UL-Bit-Rate-Value {
    	type uint32;
    	description
    		"This is a 32-bit unsigned integer that
    	      indicates the guaranteed bandwidth in bits per second for uplink
    	      IP flows.  The measurement units for Guaranteed-UL-Bit-Rate are
    	      bits per second.";
  	}

  	grouping QoS-Vendor-Specific-Attribute-Value-Base {
  		leaf vendorid {
  			type uint32;
  			mandatory true;
  			description
  				"The Vendor ID is the SMI (Structure of Management
  		      Information) Network Management Private Enterprise Code of the
  		      IANA-maintained 'Private Enterprise Numbers' registry [SMI].";
  			reference
  				"'PRIVATE ENTERPRISE NUMBERS', SMI Network Management
                Private Enterprise Codes, April 2014,
                <http://www.iana.org/assignments/enterprise-numbers>";
  		}
  		leaf subtype {
  			type uint8;
  			mandatory true;
  			description
  				"An 8-bit field indicating the type of vendor-specific
  		      information carried in the option.  The namespace for this sub-
  		      type is managed by the vendor identified by the Vendor ID field.";
  		}
    	description
    		"QoS Vendor-Specific Attribute.";
  	}

    //NOTE - We do NOT add the Status Codes or other changes in PMIP in this module

  	//Primary Structures (groupings)
    grouping qosattribute {
        leaf attributetype {
            type identityref {
                base qos-attribute-type;
            }
            mandatory true;
            description "the attribute type";
        }

  		  //All of the sub-types by constraint
        choice attribute-choice {
            case per-mn-agg-max-dl-case {
                when "../attributetype = 'Per-MN-Agg-Max-DL-Bit-Rate-type'";
                leaf per-mn-agg-max-dl {
                    type qos-pmip:Per-MN-Agg-Max-DL-Bit-Rate-Value;
                }
            }
            case per-mn-agg-max-ul-case {
                when "../attributetype = 'Per-MN-Agg-Max-UL-Bit-Rate-type'";
                leaf per-mn-agg-max-ul {
                    type qos-pmip:Per-MN-Agg-Max-UL-Bit-Rate-Value;
                }
            }
            case per-session-agg-max-dl-case {
                when "../attributetype = 'Per-Session-Agg-Max-DL-Bit-Rate-type'";
                container per-session-agg-max-dl {
                    uses qos-pmip:Per-Session-Agg-Max-Bit-Rate-Value;
                }
            }
            case per-session-agg-max-ul-case {
                when "../attributetype = 'Per-Session-Agg-Max-UL-Bit-Rate-type'";
                container per-session-agg-max-ul {
                    uses qos-pmip:Per-Session-Agg-Max-Bit-Rate-Value;
                }
            }
            case allocation-retention-priority-case {
                when "../attributetype = 'Allocation-Retention-Priority-type'";
                uses qos-pmip:Allocation-Retention-Priority-Value;
            }
            case agg-max-dl-case {
                when "../attributetype = 'Aggregate-Max-DL-Bit-Rate-type'";
                leaf agg-max-dl {
                    type qos-pmip:Aggregate-Max-DL-Bit-Rate-Value;
                }
            }
            case agg-max-ul-case {
                when "../attributetype = 'Aggregate-Max-UL-Bit-Rate-type'";
                leaf agg-max-ul {
                    type qos-pmip:Aggregate-Max-UL-Bit-Rate-Value;
                }
            }
            case gbr-dl-case {
                when "../attributetype = 'Guaranteed-DL-Bit-Rate-type'";
                leaf gbr-dl {
                    type qos-pmip:Guaranteed-DL-Bit-Rate-Value;
                }
            }
            case gbr-ul-case {
                when "../attributetype = 'Guaranteed-UL-Bit-Rate-type'";
                leaf gbr-ul {
                    type qos-pmip:Guaranteed-UL-Bit-Rate-Value;
                }
            }
            case traffic-selector-case {
                when "../attributetype = 'QoS-Traffic-Selector-type'";
                container traffic-selector {
                    uses traffic-selectors:traffic-selector;
                }
            }
        }
    }

  	grouping qosoption {
        leaf srid {
            type sr-id;
            mandatory true;
        }
        leaf trafficclass {
            type traffic-class;
            mandatory true;
        }
        leaf operationcode {
            type operational-code;
            mandatory true;
        }
        list attributes {
            unique "attributetype";
            uses qosattribute;
            min-elements 1;
        }
  	}
}
     ]]></artwork>
        <postamble></postamble>
      </figure>
</t>
  </section>
  <section anchor="ietf-traffic-selectors-types" title="Traffic Selectors YANG Model">
<t>
 <figure anchor="fig-ietf-traffic-selectors-types"
              title="FPC YANG Traffic Selectors">
<artwork align="center"><![CDATA[
module ietf-traffic-selector-types {
    yang-version 1;

    namespace
      "urn:ietf:params:xml:ns:yang:ietf-traffic-selector-types";

    prefix "ietf-traffic-selectors";

    import ietf-inet-types {
    	prefix inet;
    	revision-date 2013-07-15;
    }

    organization
      "IETF DMM (Dynamic Mobility Management) Working Group";

    contact
      "WG Web:   <https://datatracker.ietf.org/wg/dmm/>
     WG List:  <mailto:dmm@ietf.org>

     WG Chair: Dapeng Liu
               <mailto:maxpassion@gmail.com>

     WG Chair: Jouni Korhonen
               <mailto:jouni.nospam@gmail.com>

     Editor:
               <mailto:>";

    description
      "This module contains a collection of YANG definitions for
     traffic selectors for flow bindings.

     Copyright (c) 2015 IETF Trust and the persons identified as
     authors of the code.  All rights reserved.

     Redistribution and use in source and binary forms, with or
     without modification, is permitted pursuant to, and subject
     to the license terms contained in, the Simplified BSD License
     set forth in Section 4.c of the IETF Trust's Legal Provisions
     Relating to IETF Documents
     (http://trustee.ietf.org/license-info).

     This version of this YANG module was created as part of the IETF
    	DMM FPC YANG modules; see the RFC itself for full legal notices.";

    revision 2016-01-14 {
    	description "Updated for IETF-PACKET-FIELDS module alignment";
    	reference
    		"draft-ietf-netmod-acl-model-06";
    }

    revision 2016-01-12 {
        description "Initial revision";
        reference
        	"RFC 6088: Traffic Selectors for Flow Bindings";
    }

    // Identities
  	identity traffic-selector-format {
  		description "The base type for Traffic-Selector Formats";
  	}

  	identity ipv4-binary-selector-format {
  		base traffic-selector-format;
  		description
  			"IPv4 Binary Traffic Selector Format";
  	}

  	identity ipv6-binary-selector-format {
  		base traffic-selector-format;
  		description
  			"IPv6 Binary Traffic Selector Format";
  	}

  	// Type definitions and groupings
  	typedef ipsec-spi {
  		type uint32;
  		description "This type defines the first 32-bit IPsec Security Parameter
				Index (SPI) value on data packets sent from a corresponding
				node to the mobile node as seen by the home agent. This field
				is defined in [RFC4303].";
  			reference
  				"RFC 4303: IP Encapsulating Security Payload (ESP)";
  	}

  	grouping traffic-selector-base {
  		description "A grouping of the commen leaves between the v4 and v6 Traffic Selectors";
  	    container ipsec-spi-range {
  	      presence "Enables setting ipsec spi range";
  	      description
  	        "Inclusive range representing IPSec Security Parameter Indices to be used.
  	        When only start-spi is present, it represents a single spi.";
	  		leaf start-spi {
	  			type ipsec-spi;
	  			mandatory true;
	  			description
	  				"This field identifies the first 32-bit IPsec SPI value, from the
	  		      range of SPI values to be matched, on data packets sent from a
	  		      corresponding node to the mobile node as seen by the home agent.
	  		      This field is defined in [RFC4303].";
	  		}
	  		leaf end-spi {
	  			type ipsec-spi;
	  	        must ". >= ../start-spi" {
	  	          error-message
	  	            "The end-spi must be greater than or equal to start-spi";
	  	        }
	  			description
	  				"If more than one contiguous SPI value needs to be matched, then
	  		      this field can be used to indicate the end value of a range
	  		      starting from the value of the Start SPI field.  This field
	  		      MUST NOT be included unless the Start SPI field is included
	  			  and has a value less than or equal to this field.

	  		      When this field is included, the receiver will match all of the
	  		      SPI values between fields start-spi and end-spi,
	  			  inclusive of start-spi and end-spi.";
	  		}
  	    }
  	    container source-port-range {
  	      presence "Enables setting source port range";
  	      description
  	        "Inclusive range representing source ports to be used.
  	        When only start-port is present, it represents a single port.";
	  		leaf start-port {
	  			type inet:port-number;
	  			mandatory true;
	  			description
	  				"This field identifies the first 16-bit source port number, from
	  		      the range of port numbers to be matched, on data packets sent from
	  		      a corresponding node to the mobile node as seen by the home agent.
	  		      This is from the range of port numbers defined by IANA
	  		      (http://www.iana.org).";
	  		}
	  		leaf end-port {
	  			type inet:port-number;
	  			must ". >= ../start-port" {
	  	          error-message
	  	          "The end-port must be greater than or equal to start-port";
	  	        }
	  			description
	  				"If more than one contiguous source port number needs to be
	  		      matched, then this field can be used to indicate the end value of
	  		      a range starting from the value of the Start Port field.
	  		      This field MUST NOT be included unless the Start Port field
	  		      is included and has a value less than or equal to this field.

	  			  When this field is included, the receiver will match
	  		      all of the port numbers between fields start-port and
	  			  end-port, inclusive of start-port and end-port.";
	  		}
  	   }
  	  container destination-port-range {
  	      presence "Enables setting destination port range";
  	      description
  	        "Inclusive range representing destination ports to be used. When
  	  		 only start-port is present, it represents a single port.";
	  		leaf start-port {
	  			type inet:port-number;
	  			mandatory true;
	  			description
	  				"This field identifies the first 16-bit destination port number,
	  		      from the range of port numbers to be matched, on data packets sent
	  		      from a corresponding node to the mobile node as seen by the home
	  		      agent.";
	  		}
	  		leaf end-port {
	  			type inet:port-number;
	  	        must ". >= ../start-port" {
	  	          error-message
	  	            "The end-port must be greater than or equal to start-port";
	  	        }
	  			description
	  				"If more than one contiguous destination port number needs to be
	  		      matched, then this field can be used to indicate the end value of
	  		      a range starting from the value of the Start Destination Port
	  		      field.  This field MUST NOT be included unless the Start
	  		      Port field is included and has a value less than or equal to this
	  			  field.

	  			  When this field is included, the receiver will match all of the
	  			  port numbers between fields start-port and end-port, inclusive of
	  			  start-port and end-port.";
	  		}
  	  }
  	}

  	grouping ipv4-binary-traffic-selector {
	  container source-address-range-v4 {
  	      presence "Enables setting source IPv4 address range";
  	      description
  	        "Inclusive range representing IPv4 addresses to be used. When
  	  		 only start-address is present, it represents a single address.";
	  		leaf start-address {
	  			type inet:ipv4-address;
	  			mandatory true;
	  			description
	  				"This field identifies the first source address, from the range of
	  		      32-bit IPv4 addresses to be matched, on data packets sent from a
	  		      corresponding node to the mobile node as seen by the home agent.
	  		      In other words, this is one of the addresses of the correspondent
	  		      node.";
	  		}
	  		leaf end-address {
	  			type inet:ipv4-address;
	  			description
	  				"If more than one contiguous source address needs to be matched,
	  		      then this field can be used to indicate the end value of a range
	  		      starting from the value of the Start Address field.  This
	  		      field MUST NOT be included unless the Start Address field
	  		      is included.  When this field is included, the receiver will match
	  		      all of the addresses between fields start-address and
	  			  end-address, inclusive of start-address and end-address.";
	  		}
	  }
	  container destination-address-range-v4 {
  	      presence "Enables setting destination IPv4 address range";
  	      description
  	        "Inclusive range representing IPv4 addresses to be used. When
  	  		 only start-address is present, it represents a single address.";
	  		leaf start-address {
	  			type inet:ipv4-address;
	  			mandatory true;
	  			description
	  				"This field identifies the first destination address, from the
	  		      range of 32-bit IPv4 addresses to be matched, on data packets sent
	  		      from a corresponding node to the mobile node as seen by the home
	  		      agent.  In other words, this is one of the registered home
	  		      addresses of the mobile node.";
	  		}
	  		leaf end-address {
	  			type inet:ipv4-address;
	  			description
	  				"If more than one contiguous destination address needs to be
	  		      matched, then this field can be used to indicate the end value of
	  		      a range starting from the value of the Start Destination Address
	  		      field.  This field MUST NOT be included unless the Start
	  		      Address field is included.  When this field is included, the receiver
	  			  will match all of the addresses between fields start-address and
	  			  end-address, inclusive of start-address and end-address.";
	  		}
	  }
	  container ds-range {
  	      presence "Enables setting dscp range";
  	      description
  	        "Inclusive range representing DiffServ Codepoints to be used. When
  	  		 only start-ds is present, it represents a single Codepoint.";
  	      leaf start-ds {
  			type inet:dscp;
  			mandatory true;
  			description
  				"This field identifies the first differential services value, from
  		      the range of differential services values to be matched, on data
  		      packets sent from a corresponding node to the mobile node as seen
  		      by the home agent.  Note that this field is called a 'Type of
  		      Service field' in [RFC0791].  [RFC3260] then clarified that the
  		      field has been redefined as a 6-bit DS field with 2 bits reserved,
  		      later claimed by Explicit Congestion Notification (ECN) [RFC3168].
  		      For the purpose of this specification, the Start DS field is 8
  		      bits long, where the 6 most significant bits indicate the DS field
  		      to be matched and the 2 least significant bits' values MUST be
  		      ignored in any comparison.";
	  		}
	  		leaf end-ds {
	  			type inet:dscp;
	  	        must ". >= ../start-ds" {
	  	          error-message
	  	            "The end-ds must be greater than or equal to start-ds";
	  	        }
	  			description
	  				"If more than one contiguous DS value needs to be matched, then
	  		      this field can be used to indicate the end value of a range
	  		      starting from the value of the Start DS field.  This field MUST
	  		      NOT be included unless the Start DS field is included.  When this
	  		      field is included, it MUST be coded the same way as defined for
	  		      start-ds.  When this field is included, the receiver will match all of
	  		      the values between fields start-ds and end-ds, inclusive of start-ds
	  			  and end-ds.";
	  		}
	  }
	  container protocol-range {
		presence "Enables setting protocol range";
		description
			"Inclusive range representing IP protocol(s) to be used. When
		   	 only start-protocol is present, it represents a single protocol.";
  		leaf start-protocol {
  			type uint8;
  			mandatory true;
  			description
  				"This field identifies the first 8-bit protocol value, from the
  		      range of protocol values to be matched, on data packets sent from
  		      a corresponding node to the mobile node as seen by the home agent.";
  		}
  		leaf end-protocol {
  			type uint8;
  	        must ". >= ../start-protocol" {
  	          error-message
  	            "The end-protocol must be greater than or equal to start-protocol";
  	        }
  			description
  				"If more than one contiguous protocol value needs to be matched,
  		      then this field can be used to indicate the end value of a range
  		      starting from the value of the Start Protocol field.  This field
  		      MUST NOT be included unless the Start Protocol field is included.
  		      When this field is included, the receiver will match all of the
  		      values between fields start-protocol and end-protocol, inclusive
  			  of start-protocol and end-protocol.";
  		}
	  }
  	}

	grouping ipv6-binary-traffic-selector {
	 container source-address-range-v6 {
  	      presence "Enables setting source IPv6 address range";
  	      description
  	        "Inclusive range representing IPv6 addresses to be used. When
  	  		 only start-address is present, it represents a single address.";
	  		leaf start-address {
	  			type inet:ipv6-address;
	  			mandatory true;
	  			description
	  				"This field identifies the first source address, from the range of
	  		      128-bit IPv6 addresses to be matched, on data packets sent from a
	  		      corresponding node to the mobile node as seen by the home agent.
	  		      In other words, this is one of the addresses of the correspondent
	  		      node.";
	  		}
	  		leaf end-address {
	  			type inet:ipv6-address;
	  			description
	  				"If more than one contiguous source address needs to be matched,
	  		      then this field can be used to indicate the end value of a range
	  		      starting from the value of the Start Address field.  This
	  		      field MUST NOT be included unless the Start Address field is included.
	  			  When this field is included, the receiver will match all of the addresses
	  			  between fields start-address and end-address, inclusive of start-address
	  			  and end-address .";
	  		}
	  }
  	  container destination-address-range-v6 {
  	      presence "Enables setting destination IPv6 address range";
  	      description
  	        "Inclusive range representing IPv6 addresses to be used. When
  	  		 only start-address is present, it represents a single address.";
	  		leaf start-address {
	  			type inet:ipv6-address;
	  			mandatory true;
	  			description
	  				"This field identifies the first destination address, from the
	  		      range of 128-bit IPv6 addresses to be matched, on data packets
	  		      sent from a corresponding node to the mobile node as seen by the
	  		      home agent.  In other words, this is one of the registered home
	  		      addresses of the mobile node.";
	  		}
	  		leaf end-address {
	  			type inet:ipv6-address;
	  			description
	  				"If more than one contiguous destination address needs to be
	  		      matched, then this field can be used to indicate the end value of
	  		      a range starting from the value of the Start Address field. This
	  			  field MUST NOT be included unless the Start Address field is included.
	  			  When this field is included, the receiver will match all of the
	  			  addresses between fields start-address and end-address, inclusive of
	  			  start-address and end-address.";
	  		}
  	  }
  	 container flow-label-range {
      presence "Enables setting Flow Label range";
      description
        "Inclusive range representing IPv4 addresses to be used. When
  		 only start-flow-label is present, it represents a single flow label.";
  		leaf start-flow-label {
  			type inet:ipv6-flow-label;
  			description
  				"This field identifies the first flow label value, from the range
  		      of flow label values to be matched, on data packets sent from a
  		      corresponding node to the mobile node as seen by the home agent.
  		      According to [RFC2460], the flow label is 24 bits long.  For the
  		      purpose of this specification, the sender of this option MUST
  		      prefix the flow label value with 8 bits of '0' before inserting it
  		      in the start-flow-label field.  The receiver SHOULD ignore the
  		      first 8 bits of this field before using it in comparisons with
  		      flow labels in packets.";
  		}
  		leaf end-flow-label {
  			type inet:ipv6-flow-label;
  	        must ". >= ../start-flow-label" {
  	          error-message
  	            "The end-flow-lable must be greater than or equal to start-flow-label";
  	        }
  			description
  				"If more than one contiguous flow label value needs to be matched,
  		      then this field can be used to indicate the end value of a range
  		      starting from the value of the Start Flow Label field.  This field
  		      MUST NOT be included unless the Start Flow Label field is
  		      included.  When this field is included, the receiver will match
  		      all of the flow label values between fields start-flow-label
  			  and end-flow-label, inclusive of start-flow-label and end-flow-label.
  			  When this field is included, it MUST be coded the same way as defined
  			  for end-flow-label.";
  		}
  	 }
  	 container traffic-class-range {
      presence "Enables setting the traffic class range";
      description
        "Inclusive range representing IPv4 addresses to be used. When
  		 only start-traffic-class is present, it represents a single traffic class.";
  		leaf start-traffic-class {
  			type inet:dscp;
  			description
  				"This field identifies the first traffic class value, from the
  		      range of traffic class values to be matched, on data packets sent
  		      from a corresponding node to the mobile node as seen by the home
  		      agent.  This field is equivalent to the Start DS field in the IPv4
  		      traffic selector in Figure 1.  As per RFC 3260, the field is
  		      defined as a 6-bit DS field with 2 bits reserved, later claimed by
  		      Explicit Congestion Notification (ECN) RFC 3168.  For the purpose
  		      of this specification, the start-traffic-class field is 8 bits long, where
  		      the 6 most significant bits indicate the DS field to be matched
  		      and the 2 least significant bits' values MUST be ignored in any
  		      comparison.";
  			reference
  				"RFC 3260: New Terminology and Clarifications for Diffserv
  				 RFC 3168: The Addition of Explicit Congestion Notification (ECN) to IP";
  		}
  		leaf end-traffic-class {
  			type inet:dscp;
  	        must ". >= ../start-traffic-class" {
  	          error-message
  	            "The end-traffic-class must be greater than or equal to start-traffic-class";
  	        }
  			description
  				"If more than one contiguous TC value needs to be matched, then
  		      this field can be used to indicate the end value of a range
  		      starting from the value of the Start TC field.  This field MUST
  		      NOT be included unless the Start TC field is included.  When this
  		      field is included, it MUST be coded the same way as defined for
  			  start-traffic-class.  When this field is included, the receiver
  			  will match all of the values between fields start-traffic-class
  			  and end-traffic-class, inclusive of start-traffic-class and
  		      end-traffic-class.";
  		}
  	 }
  	 container next-header-range {
      presence "Enables setting Next Header range";
      description
        "Inclusive range representing Next Headers to be used. When
  		 only start-next-header is present, it represents a single Next Header.";
  		leaf start-next-header {
  			type uint8;
  			description
  				"This field identifies the first 8-bit next header value, from the
  		      range of next header values to be matched, on data packets sent
  		      from a corresponding node to the mobile node as seen by the home
  		      agent.";
  		}
  		leaf end-next-header {
  			type uint8;
  	        must ". >= ../start-next-header" {
  	          error-message
  	            "The end-next-header must be greater than or equal to start-next-header";
  	        }
  			description
  				"If more than one contiguous next header value needs to be matched,
  		      then this field can be used to indicate the end value of a range
  		      starting from the value of the Start NH field.  This field MUST
  		      NOT be included unless the Start next header field is included.
  		      When this field is included, the receiver will match all of the
  		      values between fields start-next-header and end-next-header,
  			  inclusive of start-next-header and end-next-header.";
  		}
  	 }
	}

	grouping traffic-selector {
		leaf ts-format {
 			type identityref {
  				base traffic-selector-format;
  			}
  			description "Traffic Selector Format";
  		}
		uses traffic-selector-base {
			when "boolean(../ts-format/text() = 'ipv6-binary-selector-format') | boolean(../ts-format/text() = 'ipv4-binary-selector-format')";
		}
		uses ipv4-binary-traffic-selector {
			when "boolean(../ts-format/text() = 'ipv4-binary-selector-format')";
		}
		uses ipv6-binary-traffic-selector {
			when "boolean(../ts-format/text() = 'ipv6-binary-selector-format')";
		}
		description
			"The traffic selector includes the parameters used to match
			   packets for a specific flow binding.";
		reference
			"RFC 6089: Flow Bindings in Mobile IPv6 and Network Mobility (NEMO) Basic Support";
	}

	grouping ts-list {
		list selectors {
			key index;
			leaf index {
				type uint64;
			}
			uses traffic-selector;
		}
	}
}
     ]]></artwork>
        <postamble></postamble>
      </figure>
</t>
  </section>
  <section anchor="ietf-dmm-threegpp" title="FPC 3GPP Mobility YANG Model">
<t>
 <figure anchor="fig-ietf-dmm-threegpp"
              title="FPC YANG 3GPP Mobility">
<artwork align="center"><![CDATA[
module ietf-dmm-threegpp {
    namespace "urn:ietf:params:xml:ns:yang:threegpp";
    prefix threegpp;

    import ietf-inet-types { prefix inet; revision-date 2013-07-15; }
    import ietf-dmm-fpcagent { prefix fpcagent; }
    import ietf-dmm-fpcbase { prefix fpcbase; revision-date 2016-08-03; }
    import ietf-traffic-selector-types { prefix traffic-selectors; revision-date 2016-01-14; }
    import ietf-pmip-qos { prefix pmipqos; revision-date 2016-02-10; }


    organization "IETF DMM Working Group";
    contact "Satoru Matsushima <satoru.matsushima@g.softbank.co.jp>";

    description
    "This module contains YANG definition for
     3GPP Related Mobility Structures";

    revision 2016-08-03 {
        description "Initial";
        reference "draft-ietf-dmm-fpc-cpdp-04";
    }

    // Profile Type
    identity threeGPP-mobility {
        base "fpcbase:fpc-mobility-profile-type";
    }

    // Tunnel Types
    identity threeGPP-tunnel-type {
        description "Base Tunnel Type";
    }

    identity gtpv1 {
        base "threegpp:threeGPP-tunnel-type";
    }

    identity gtpv2 {
        base "threegpp:threeGPP-tunnel-type";
    }

    grouping teid-value {
         leaf tunnel-identifier {
            description "TEID";
            type uint32;
        }
    }

    grouping threeGPP-tunnel {
        leaf tunnel-type {
            type identityref  {
              base "threegpp:threeGPP-tunnel-type";
            }
        }
        uses threegpp:teid-value;
    }

    // QoS Profile
    identity threeGPP-QoS-Profile {
        base "fpcbase:fpc-qos-type";
    }

    typedef fpc-qos-class-identifier {
        type uint8 {
            range "1..9";
        }
        description "QCI";
    }

    grouping threeGPP-QoS {
        leaf qci {
            type fpc-qos-class-identifier;
        }
        leaf gbr {
            type uint32;
        }
        leaf mbr {
            type uint32;
        }
        leaf apn-ambr {
            type uint32;
        }
        leaf ue-ambr {
            type uint32;
        }
        container arp {
            uses pmipqos:Allocation-Retention-Priority-Value;
        }
    }

    typedef ebi-type {
      type uint8 {
        range "0..15";
      }
    }

   // From 3GPP TS 24.008 version 13.5.0 Release 13
   typedef component-type-enum {
        type enumeration {
            enum ipv4RemoteAddress { value 16; }
            enum ipv4LocalAddress  { value 17; }
            enum ipv6RemoteAddress { value 32; }
            enum ipv6RemoteAddressPrefix { value 33; }
            enum ipv6LocalAddressPrefix { value 35; }
            enum protocolNextHeader { value 48; }
            enum localPort { value 64; }
            enum localPortRange { value 65; }
            enum reomotePort { value 80; }
            enum remotePortRange { value 81; }
            enum secParamIndex { value 96; }
            enum tosTraffClass { value 112; }
            enum flowLabel { value 128; }
        }
    }

    typedef packet-filter-direction {
        type enumeration {
          enum preRel7Tft { value 0; }
          enum uplink { value 1; }
          enum downlink { value 2; }
          enum bidirectional { value 3; }
        }
    }

    typedef component-type-id {
        type uint8 {
          range "16 | 17 | 32 | 33 | 35 | 48 | 64 | 65 | 80 | 81 | 96 | 112 | 128";
        }
    }

    grouping packet-filter {
      leaf direction {
          type threegpp:packet-filter-direction;
      }
      leaf identifier {
          type uint8 {
            range "1..15";
          }
      }
      leaf evaluation-precedence {
          type uint8;
      }
      list contents {
        key component-type-identifier;
        leaf component-type-identifier {
            type threegpp:component-type-id;
        }
        choice value {
          case ipv4-local {
            leaf ipv4-local {
              type inet:ipv4-address;
            }
          }
          case ipv6-prefix-local {
            leaf ipv6-prefix-local {
              type inet:ipv6-prefix;
            }
          }
          case ipv4-ipv6-remote {
            leaf ipv4-ipv6-remote {
              type inet:ip-address;
            }
          }
          case ipv6-prefix-remote {
            leaf ipv6-prefix-remote {
              type inet:ipv6-prefix;
            }
          }
          case next-header {
            leaf next-header {
              type uint8;
            }
          }
          case local-port {
            leaf local-port {
              type inet:port-number;
            }
          }
          case local-port-range {
            leaf local-port-lo {
              type inet:port-number;
            }
            leaf local-port-hi {
              type inet:port-number;
            }
          }
          case remote-port {
            leaf remote-port {
              type inet:port-number;
            }
          }
          case remote-port-range {
            leaf remote-port-lo {
              type inet:port-number;
            }
            leaf remote-port-hi {
              type inet:port-number;
            }
          }
          case ipsec-index {
            leaf ipsec-index {
              type traffic-selectors:ipsec-spi;
            }
          }
          case traffic-class {
            leaf traffic-class {
              type inet:dscp;
            }
          }
          case traffic-class-range {
              leaf traffic-class-lo {
                type inet:dscp;
              }
              leaf traffic-class-hi {
                type inet:dscp;
              }
          }
          case flow-label-type {
            leaf-list flow-label-type {
              type inet:ipv6-flow-label;
            }
          }
        }
      }
    }

    grouping tft {
      list packet-filters {
          key identifier;
          uses threegpp:packet-filter;
      }
    }

    typedef imsi-type {
        type uint64;
    }

    typedef threegpp-instr {
      description "Instruction Set for 3GPP R11";
      type bits {
        bit assign-ip {
          position 0;
        }
        bit assign-fteid-ip {
          position 1;
        }
        bit assign-fteid-teid {
          position 2;
        }
        bit session {
          position 3;
        }
        bit uplink {
          position 4;
        }
        bit downlink {
          position 5;
        }
        bit assign-dpn {
          position 6;
        }
      }
    }

    // Descriptors update - goes to Entities, Configure and Configure Bundles
    augment "/fpcagent:fpc-entities/fpcagent:descriptors/fpcagent:descriptor-value" {
      case threegpp-tft {
          uses threegpp:tft;
      }
    }
    augment "/fpcagent:configure/fpcagent:input/fpcagent:op_body/fpcagent:create_or_update/fpcagent:descriptors/fpcagent:descriptor-value" {
      case threegpp-tft {
          uses threegpp:tft;
      }
    }
    augment "/fpcagent:configure-bundles/fpcagent:input/fpcagent:bundles/fpcagent:op_body/fpcagent:create_or_update/fpcagent:descriptors/fpcagent:descriptor-value" {
      case threegpp-tft {
          uses threegpp:tft;
      }
    }

    // Topology
    augment "/fpcagent:fpc-topology/fpcagent:dpn-groups/fpcagent:dpn-group-peers/fpcagent:profile-parameters" {
      case threegpp-tunnel {
          uses threegpp:threeGPP-tunnel;
          uses threegpp:tft;
      }
    }

    // Contexts Update - Contexts / UL / mob-profile, Contexts / DL / mob-profile and Contexts / dpns / mobility-profile
    augment "/fpcagent:fpc-entities/fpcagent:contexts/fpcagent:ul/fpcagent:mobility-profile/fpcagent:profile-parameters" {
      case threegpp-tunnel {
          uses threegpp:threeGPP-tunnel;
          uses threegpp:tft;
      }
    }
    augment "/fpcagent:configure/fpcagent:input/fpcagent:op_body/fpcagent:create_or_update/fpcagent:contexts/fpcagent:ul/fpcagent:mobility-profile/fpcagent:profile-parameters" {
      case threegpp-tunnel {
          uses threegpp:threeGPP-tunnel;
          uses threegpp:tft;
      }
    }
    augment "/fpcagent:configure-bundles/fpcagent:input/fpcagent:bundles/fpcagent:op_body/fpcagent:create_or_update/fpcagent:contexts/fpcagent:ul/fpcagent:mobility-profile/fpcagent:profile-parameters" {
      case threegpp-tunnel {
          uses threegpp:threeGPP-tunnel;
          uses threegpp:tft;
      }
    }

    augment "/fpcagent:fpc-entities/fpcagent:contexts/fpcagent:dl/fpcagent:mobility-profile/fpcagent:profile-parameters" {
      case threegpp-tunnel {
          uses threegpp:threeGPP-tunnel;
          uses threegpp:tft;
      }
    }
    augment "/fpcagent:configure/fpcagent:input/fpcagent:op_body/fpcagent:create_or_update/fpcagent:contexts/fpcagent:dl/fpcagent:mobility-profile/fpcagent:profile-parameters" {
      case threegpp-tunnel {
          uses threegpp:threeGPP-tunnel;
          uses threegpp:tft;
      }
    }
    augment "/fpcagent:configure-bundles/fpcagent:input/fpcagent:bundles/fpcagent:op_body/fpcagent:create_or_update/fpcagent:contexts/fpcagent:dl/fpcagent:mobility-profile/fpcagent:profile-parameters" {
      case threegpp-tunnel {
          uses threegpp:threeGPP-tunnel;
          uses threegpp:tft;
      }
    }

    augment "/fpcagent:fpc-entities/fpcagent:contexts/fpcagent:dpns/fpcagent:mobility-profile/fpcagent:profile-parameters" {
      case threegpp-tunnel {
          uses threegpp:threeGPP-tunnel;
          uses threegpp:tft;
      }
    }
    augment "/fpcagent:configure/fpcagent:input/fpcagent:op_body/fpcagent:create_or_update/fpcagent:contexts/fpcagent:dpns/fpcagent:mobility-profile/fpcagent:profile-parameters" {
      case threegpp-tunnel {
          uses threegpp:threeGPP-tunnel;
          uses threegpp:tft;
      }
    }
    augment "/fpcagent:configure-bundles/fpcagent:input/fpcagent:bundles/fpcagent:op_body/fpcagent:create_or_update/fpcagent:contexts/fpcagent:dpns/fpcagent:mobility-profile/fpcagent:profile-parameters" {
      case threegpp-tunnel {
          uses threegpp:threeGPP-tunnel;
          uses threegpp:tft;
      }
    }

    // QoS Updates - Context / UL / qosprofile, Context / DL / QoS Profile
    augment "/fpcagent:fpc-entities/fpcagent:contexts/fpcagent:ul/fpcagent:qos-profile/fpcagent:value" {
      case threegpp-qos {
          uses threegpp:threeGPP-QoS;
      }
    }
    augment "/fpcagent:configure/fpcagent:input/fpcagent:op_body/fpcagent:create_or_update/fpcagent:contexts/fpcagent:ul/fpcagent:qos-profile/fpcagent:value" {
      case threegpp-qos {
          uses threegpp:threeGPP-QoS;
      }
    }
    augment "/fpcagent:configure-bundles/fpcagent:input/fpcagent:bundles/fpcagent:op_body/fpcagent:create_or_update/fpcagent:contexts/fpcagent:ul/fpcagent:qos-profile/fpcagent:value" {
      case threegpp-qos {
          uses threegpp:threeGPP-QoS;
      }
    }

    augment "/fpcagent:fpc-entities/fpcagent:contexts/fpcagent:dl/fpcagent:qos-profile/fpcagent:value" {
      case threegpp-qos {
          uses threegpp:threeGPP-QoS;
      }
    }
    augment "/fpcagent:configure/fpcagent:input/fpcagent:op_body/fpcagent:create_or_update/fpcagent:contexts/fpcagent:dl/fpcagent:qos-profile/fpcagent:value" {
      case threegpp-qos {
          uses threegpp:threeGPP-QoS;
      }
    }
    augment "/fpcagent:configure-bundles/fpcagent:input/fpcagent:bundles/fpcagent:op_body/fpcagent:create_or_update/fpcagent:contexts/fpcagent:dl/fpcagent:qos-profile/fpcagent:value" {
      case threegpp-qos {
          uses threegpp:threeGPP-QoS;
      }
    }

    grouping threegpp-properties {
      leaf imsi {
        type threegpp:imsi-type;
      }
      leaf ebi {
        type threegpp:ebi-type;
      }
      leaf lbi {
        type threegpp:ebi-type;
      }
    }

    augment "/fpcagent:fpc-entities/fpcagent:contexts" {
      uses threegpp:threegpp-properties;
    }
    augment "/fpcagent:configure/fpcagent:input/fpcagent:op_body/fpcagent:create_or_update/fpcagent:contexts" {
      uses threegpp:threegpp-properties;
    }
    augment "/fpcagent:configure-bundles/fpcagent:input/fpcagent:bundles/fpcagent:op_body/fpcagent:create_or_update/fpcagent:contexts" {
       uses threegpp:threegpp-properties;
    }

    grouping threegpp-commandset {
      leaf instr-3gpp-mob {
        type threegpp:threegpp-instr;
      }
    }

    augment "/fpcagent:configure/fpcagent:input/fpcagent:instructions/fpcagent:instr-type" {
      case instr-3gpp-mob {
        uses threegpp:threegpp-commandset;
      }
    }
    augment "/fpcagent:configure/fpcagent:input/fpcagent:op_body/fpcagent:create_or_update/fpcagent:contexts/fpcagent:instructions/fpcagent:instr-type" {
      case instr-3gpp-mob {
        uses threegpp:threegpp-commandset;
      }
    }
    augment "/fpcagent:configure/fpcagent:output/fpcagent:result-type/fpcagent:config-success/fpcagent:contexts/fpcagent:instructions/fpcagent:instr-type" {
      case instr-3gpp-mob {
        uses threegpp:threegpp-commandset;
      }
    }
    augment "/fpcagent:configure/fpcagent:input/fpcagent:op_body/fpcagent:create_or_update/fpcagent:ports/fpcagent:instructions/fpcagent:instr-type" {
      case instr-3gpp-mob {
        uses threegpp:threegpp-commandset;
      }
    }
    augment "/fpcagent:configure/fpcagent:output/fpcagent:result-type/fpcagent:config-success/fpcagent:ports/fpcagent:instructions/fpcagent:instr-type" {
      case instr-3gpp-mob {
        uses threegpp:threegpp-commandset;
      }
    }

    augment "/fpcagent:configure-bundles/fpcagent:input/fpcagent:bundles/fpcagent:instructions/fpcagent:instr-type" {
      case instr-3gpp-mob {
        uses threegpp:threegpp-commandset;
      }
    }
    augment "/fpcagent:configure-bundles/fpcagent:input/fpcagent:bundles/fpcagent:op_body/fpcagent:create_or_update/fpcagent:contexts/fpcagent:instructions/fpcagent:instr-type" {
      case instr-3gpp-mob {
        uses threegpp:threegpp-commandset;
      }
    }
    augment "/fpcagent:configure-bundles/fpcagent:output/fpcagent:bundles/fpcagent:result-type/fpcagent:config-success/fpcagent:contexts/fpcagent:instructions/fpcagent:instr-type" {
      case instr-3gpp-mob {
        uses threegpp:threegpp-commandset;
      }
    }
    augment "/fpcagent:configure-bundles/fpcagent:input/fpcagent:bundles/fpcagent:op_body/fpcagent:create_or_update/fpcagent:ports/fpcagent:instructions/fpcagent:instr-type" {
      case instr-3gpp-mob {
        uses threegpp:threegpp-commandset;
      }
    }
    augment "/fpcagent:configure-bundles/fpcagent:output/fpcagent:bundles/fpcagent:result-type/fpcagent:config-success/fpcagent:ports/fpcagent:instructions/fpcagent:instr-type" {
      case instr-3gpp-mob {
        uses threegpp:threegpp-commandset;
      }
    }

    // Deletion Augments - We add the TEID to speed up deletion
    augment "/fpcagent:configure/fpcagent:input/fpcagent:op_body/fpcagent:delete_or_query/fpcagent:targets" {
      uses threegpp:teid-value;
    }
    augment "/fpcagent:configure-bundles/fpcagent:input/fpcagent:bundles/fpcagent:op_body/fpcagent:delete_or_query/fpcagent:targets" {
      uses threegpp:teid-value;
    }
}
     ]]></artwork>
        <postamble></postamble>
      </figure>
</t>
  </section>
  <section anchor="ietf-dmm-fpc-pmip" title="FPC / PMIP Integration YANG Model">
<t>
 <figure anchor="fig-ietf-dmm-fpc-pmip"
              title="FPC YANG FPC / PMIP Integration">
<artwork align="center"><![CDATA[
module ietf-dmm-fpc-pmip {
    namespace "urn:ietf:params:xml:ns:yang:ietf-dmm-fpc-pmip";
    prefix fpc-pmip;

    import ietf-dmm-fpcbase { prefix fpcbase; }
    import ietf-dmm-fpcagent { prefix fpcagent; }
    import ietf-pmip-qos { prefix qos-pmip; }
    import ietf-traffic-selector-types { prefix traffic-selectors; }

    organization "IETF DMM Working Group";
    contact "Satoru Matsushima <satoru.matsushima@g.softbank.co.jp>";

    description
    "This module contains YANG definition for
     Forwarding Policy Configuration Protocol.(FPCP)";

    revision 2016-01-19 {
        description "Changes based on -01 version of FPCP draft.";
        reference "draft-ietf-dmm-fpc-cpdp-01";
    }

    identity fpcp-qos-index-pmip {
        base "fpcbase:fpc-qos-type";
    }
    identity traffic-selector-mip6 {
        base "fpcbase:fpc-descriptor-type";
    }
    identity ietf-pmip {
        base "fpcbase:fpc-mobility-profile-type";
    }

    identity pmip-tunnel-type {
        description "PMIP Tunnel Type";
    }
    identity grev1 {
        base "fpc-pmip:pmip-tunnel-type";
    }
    identity grev2 {
        base "fpc-pmip:pmip-tunnel-type";
    }
    identity ipinip {
        base "fpc-pmip:pmip-tunnel-type";
    }
    grouping pmip-mobility {
        leaf type {
            type identityref {
                base "fpc-pmip:pmip-tunnel-type";
            }
        }
        choice value {
            case gre {
                leaf key {
                    type uint32;
                    description "GRE_KEY";
                }
            }
        }
    }

    typedef pmip-instr {
      description "Instruction Set for PMIP";
      type bits {
        bit assign-ip {
          position 0;
        }
        bit assign-dpn {
          position 1;
        }
        bit session {
          position 2;
        }
        bit uplink {
          position 3;
        }
        bit downlink {
          position 4;
        }
      }
    }

    // Descriptors update - goes to Entities, Configure and Configure Bundles
    augment "/fpcagent:fpc-entities/fpcagent:descriptors/fpcagent:descriptor-value" {
      case pmip-selector {
          uses traffic-selectors:traffic-selector;
      }
    }
    augment "/fpcagent:configure/fpcagent:input/fpcagent:op_body/fpcagent:create_or_update/fpcagent:descriptors/fpcagent:descriptor-value" {
      case pmip-selector {
          uses traffic-selectors:traffic-selector;
      }
    }
    augment "/fpcagent:configure-bundles/fpcagent:input/fpcagent:bundles/fpcagent:op_body/fpcagent:create_or_update/fpcagent:descriptors/fpcagent:descriptor-value" {
      case pmip-selector {
          uses traffic-selectors:traffic-selector;
      }
    }

    // Topology
    augment "/fpcagent:fpc-topology/fpcagent:dpn-groups/fpcagent:dpn-group-peers/fpcagent:profile-parameters" {
      case pmip-tunnel {
        uses fpc-pmip:pmip-mobility;
        uses traffic-selectors:traffic-selector;
      }
    }

    // Contexts Update - Contexts / UL / mob-profile, Contexts / DL / mob-profile and Contexts / dpns / mobility-profile
    augment "/fpcagent:fpc-entities/fpcagent:contexts/fpcagent:ul/fpcagent:mobility-profile/fpcagent:profile-parameters" {
      case pmip-tunnel {
        uses fpc-pmip:pmip-mobility;
        uses traffic-selectors:traffic-selector;
      }
    }
    augment "/fpcagent:configure/fpcagent:input/fpcagent:op_body/fpcagent:create_or_update/fpcagent:contexts/fpcagent:ul/fpcagent:mobility-profile/fpcagent:profile-parameters" {
      case pmip-tunnel {
        uses fpc-pmip:pmip-mobility;
        uses traffic-selectors:traffic-selector;
      }
    }
    augment "/fpcagent:configure-bundles/fpcagent:input/fpcagent:bundles/fpcagent:op_body/fpcagent:create_or_update/fpcagent:contexts/fpcagent:ul/fpcagent:mobility-profile/fpcagent:profile-parameters" {
      case pmip-tunnel {
        uses fpc-pmip:pmip-mobility;
        uses traffic-selectors:traffic-selector;
      }
    }

    augment "/fpcagent:fpc-entities/fpcagent:contexts/fpcagent:dl/fpcagent:mobility-profile/fpcagent:profile-parameters" {
      case pmip-tunnel {
        uses fpc-pmip:pmip-mobility;
        uses traffic-selectors:traffic-selector;
      }
    }
    augment "/fpcagent:configure/fpcagent:input/fpcagent:op_body/fpcagent:create_or_update/fpcagent:contexts/fpcagent:dl/fpcagent:mobility-profile/fpcagent:profile-parameters" {
      case pmip-tunnel {
        uses fpc-pmip:pmip-mobility;
        uses traffic-selectors:traffic-selector;
      }
    }
    augment "/fpcagent:configure-bundles/fpcagent:input/fpcagent:bundles/fpcagent:op_body/fpcagent:create_or_update/fpcagent:contexts/fpcagent:dl/fpcagent:mobility-profile/fpcagent:profile-parameters" {
      case pmip-tunnel {
        uses fpc-pmip:pmip-mobility;
        uses traffic-selectors:traffic-selector;
      }
    }

    augment "/fpcagent:fpc-entities/fpcagent:contexts/fpcagent:dpns/fpcagent:mobility-profile/fpcagent:profile-parameters" {
      case pmip-tunnel {
        uses fpc-pmip:pmip-mobility;
        uses traffic-selectors:traffic-selector;
      }
    }
    augment "/fpcagent:configure/fpcagent:input/fpcagent:op_body/fpcagent:create_or_update/fpcagent:contexts/fpcagent:dpns/fpcagent:mobility-profile/fpcagent:profile-parameters" {
      case pmip-tunnel {
        uses fpc-pmip:pmip-mobility;
        uses traffic-selectors:traffic-selector;
      }
    }
    augment "/fpcagent:configure-bundles/fpcagent:input/fpcagent:bundles/fpcagent:op_body/fpcagent:create_or_update/fpcagent:contexts/fpcagent:dpns/fpcagent:mobility-profile/fpcagent:profile-parameters" {
      case pmip-tunnel {
        uses fpc-pmip:pmip-mobility;
        uses traffic-selectors:traffic-selector;
      }
    }

    // QoS Updates - Context / UL / qosprofile, Context / DL / QoS Profile
    augment "/fpcagent:fpc-entities/fpcagent:contexts/fpcagent:ul/fpcagent:qos-profile/fpcagent:value" {
      case qos-pmip {
          uses qos-pmip:qosattribute;
      }
    }
    augment "/fpcagent:configure/fpcagent:input/fpcagent:op_body/fpcagent:create_or_update/fpcagent:contexts/fpcagent:ul/fpcagent:qos-profile/fpcagent:value" {
      case qos-pmip {
          uses qos-pmip:qosattribute;
      }
    }
    augment "/fpcagent:configure-bundles/fpcagent:input/fpcagent:bundles/fpcagent:op_body/fpcagent:create_or_update/fpcagent:contexts/fpcagent:ul/fpcagent:qos-profile/fpcagent:value" {
      case qos-pmip {
          uses qos-pmip:qosattribute;
      }
    }

    augment "/fpcagent:fpc-entities/fpcagent:contexts/fpcagent:dl/fpcagent:qos-profile/fpcagent:value" {
      case qos-pmip {
          uses qos-pmip:qosattribute;
      }
    }
    augment "/fpcagent:configure/fpcagent:input/fpcagent:op_body/fpcagent:create_or_update/fpcagent:contexts/fpcagent:dl/fpcagent:qos-profile/fpcagent:value" {
      case qos-pmip {
          uses qos-pmip:qosattribute;
      }
    }
    augment "/fpcagent:configure-bundles/fpcagent:input/fpcagent:bundles/fpcagent:op_body/fpcagent:create_or_update/fpcagent:contexts/fpcagent:dl/fpcagent:qos-profile/fpcagent:value" {
      case qos-pmip {
          uses qos-pmip:qosattribute;
      }
    }

    grouping pmip-commandset {
      leaf instr-pmip {
        type fpc-pmip:pmip-instr;
      }
    }

    // Instructions Update - OP BODY, Context, Port
    augment "/fpcagent:configure/fpcagent:input/fpcagent:instructions/fpcagent:instr-type" {
      case pmip-instr {
        uses fpc-pmip:pmip-commandset;
      }
    }
    augment "/fpcagent:configure/fpcagent:input/fpcagent:op_body/fpcagent:create_or_update/fpcagent:contexts/fpcagent:instructions/fpcagent:instr-type" {
      case pmip-instr {
        uses fpc-pmip:pmip-commandset;
      }
    }
    augment "/fpcagent:configure/fpcagent:output/fpcagent:result-type/fpcagent:config-success/fpcagent:contexts/fpcagent:instructions/fpcagent:instr-type" {
      case pmip-instr {
        uses fpc-pmip:pmip-commandset;
      }
    }
    augment "/fpcagent:configure/fpcagent:input/fpcagent:op_body/fpcagent:create_or_update/fpcagent:ports/fpcagent:instructions/fpcagent:instr-type" {
      case pmip-instr {
        uses fpc-pmip:pmip-commandset;
      }
    }
    augment "/fpcagent:configure/fpcagent:output/fpcagent:result-type/fpcagent:config-success/fpcagent:ports/fpcagent:instructions/fpcagent:instr-type" {
      case pmip-instr {
        uses fpc-pmip:pmip-commandset;
      }
    }

    augment "/fpcagent:configure-bundles/fpcagent:input/fpcagent:bundles/fpcagent:instructions/fpcagent:instr-type" {
      case pmip-instr {
        uses fpc-pmip:pmip-commandset;
      }
    }
    augment "/fpcagent:configure-bundles/fpcagent:input/fpcagent:bundles/fpcagent:op_body/fpcagent:create_or_update/fpcagent:contexts/fpcagent:instructions/fpcagent:instr-type" {
      case pmip-instr {
        uses fpc-pmip:pmip-commandset;
      }
    }
    augment "/fpcagent:configure-bundles/fpcagent:output/fpcagent:bundles/fpcagent:result-type/fpcagent:config-success/fpcagent:contexts/fpcagent:instructions/fpcagent:instr-type" {
      case pmip-instr {
        uses fpc-pmip:pmip-commandset;
      }
    }

    augment "/fpcagent:configure-bundles/fpcagent:input/fpcagent:bundles/fpcagent:op_body/fpcagent:create_or_update/fpcagent:ports/fpcagent:instructions/fpcagent:instr-type" {
      case pmip-instr {
        uses fpc-pmip:pmip-commandset;
      }
    }
    augment "/fpcagent:configure-bundles/fpcagent:output/fpcagent:bundles/fpcagent:result-type/fpcagent:config-success/fpcagent:ports/fpcagent:instructions/fpcagent:instr-type" {
      case pmip-instr {
        uses fpc-pmip:pmip-commandset;
      }
    }
}
     ]]></artwork>
        <postamble></postamble>
      </figure>
</t>
  </section>
  <section anchor="ietf-dmm-fpc-policyext" title="FPC Policy Extension YANG Model">
<t>
 <figure anchor="fig-ietf-dmm-fpc-policyext"
              title="FPC YANG 3GPP FPC Policy Extensions">
<artwork align="center"><![CDATA[
module ietf-dmm-fpc-policyext {
    namespace "urn:ietf:params:xml:ns:yang:fpcpolicyext";
    prefix fpcpolicyext;

    import ietf-dmm-fpcbase { prefix fpcbase; revision-date 2016-08-03; }
    import ietf-dmm-fpcagent { prefix fpcagent; revision-date 2016-08-03; }
    import ietf-inet-types { prefix inet; revision-date 2013-07-15; }

    organization "IETF DMM Working Group";
    contact "Satoru Matsushima <satoru.matsushima@g.softbank.co.jp>";

    description
    "This module contains YANG definition for
     Forwarding Policy Configuration Protocol (FPCP)
     common Policy Action and Descriptor extensions";

    revision 2016-08-03 {
        description "Changes based on -04 version of FPC draft.";
        reference "draft-ietf-dmm-fpc-cpdp-04";
    }

    identity service-function {
        base "fpcbase:fpc-descriptor-type";
        description "Base Identifier for Service Functions.";
    }

    identity napt-service {
        base "service-function";
    }
    grouping simple-nat {
      leaf outbound-nat-address {
        type inet:ip-address;
      }
    }

    identity nat-service {
        base "service-function";
    }
    grouping simple-napt {
      leaf source-port {
        type inet:port-number;
      }
      leaf outbound-napt-address {
        type inet:ip-address;
      }
      leaf destination-port {
        type inet:port-number;
      }
    }

    identity copy-forward {
      base "fpcbase:fpc-descriptor-type";
      description "Copies a packet then forwards to a specific destination";
    }
    grouping copy-forward {
      container destination {
        choice value {
          case port-ref {
            leaf port-ref {
              type leafref {
                path "/fpcagent:fpc-entities/fpcagent:ports/fpcagent:port-id";
              }
            }
          }
          case context-ref {
            leaf context-ref {
              type leafref {
                path "/fpcagent:fpc-entities/fpcagent:contexts/fpcagent:context-id";
              }
            }
          }
        }
      }
    }

    augment "/fpcagent:fpc-entities/fpcagent:actions/fpcagent:action-value" {
      case simple-nat {
          uses fpcpolicyext:simple-nat;
      }
      case simple-napt {
          uses fpcpolicyext:simple-napt;
      }
      case copy-forward {
          uses fpcpolicyext:copy-forward;
      }
    }

    grouping prefix-traffic-descriptor {
        description
        "Traffic descriptor group collects parameters to
         identify target traffic flow.  It represents
         source/destination as IP prefixes";

        leaf destination-ip {
            type inet:ip-prefix;
            description "Rule of destination IP";
        }
        leaf source-ip {
            type inet:ip-prefix;
            description "Rule of source IP";
        }
    }

    augment "/fpcagent:fpc-entities/fpcagent:descriptors/fpcagent:descriptor-value" {
      case prefix-descriptor {
          uses fpcpolicyext:prefix-traffic-descriptor;
      }
    }
}
     ]]></artwork>
        <postamble></postamble>
      </figure>
</t>
  </section>
</section>
<!-- template for YANG model, end -->
<section anchor="yangtrees" title="YANG Trees">
  <section anchor="ietf-dmm-fpcbase-tree" title="FPC Base YANG Tree">
  </section>
  <section anchor="ietf-dmm-fpcagent-tree" title="FPC Agent YANG Tree">
<t>
 <figure anchor="fig-ietf-dmm-fpc-fpcagent-tree"
              title="FPC YANG FPC Agent Tree">
<artwork align="center"><![CDATA[
     ]]></artwork>
        <postamble></postamble>
      </figure>
</t>
  </section>
  <section anchor="ietf-pmip-qos-tree" title="PMIP QoS Tree">
  </section>
  <section anchor="ietf-traffic-selectors-types-tree" title="Traffic Selectors YANG Tree">
  </section>
  <section anchor="ietf-dmm-threegpp-tree" title="FPC 3GPP Mobility YANG Tree">
  </section>
  <section anchor="ietf-dmm-fpc-pmip-tree" title="FPC / PMIP Integration YANG Tree">
  </section>
  <section anchor="ietf-dmm-fpc-policyext-tree" title="FPC Policy Extension YANG Tree">
  </section>
</section>


</section>

<!--
<section anchor="changenotes" title="Change Notes">

<t>No changes yet in the initial version.</t>

  <t><list style="symbols">

     <t>Nothing to report yet.</t>
     <t>Nothing to report yet.</t>

  </list></t>
-->
<!--
<t>Changes in version 02:</t>

 <t><list style="symbols">

     <t>Consistently refer to communication between MN and CN, not between
        two MNs </t>
     <t>Adopt text to the result of the roaming model discussion and refer to
        provider domain, not PMIPv6 domain</t>
     <t>Revision of Terms section according to comments</t>
     <t>Revision of text in Section 3.1 about network entities, which
        perform signaling for localized routing (clarification)</t>
     <t>Revision of text in Section 3.1 to clarify about localized routing
        benefits</t>
     <t>Revision of text in Section 3.2 to clarify about signaling race condition
        in multi-LMA case</t>
     <t>Add more text to <xref target="secroaming"></xref> about the roaming model
        for localized routing, relevance of the PMIPv6 domain concept and associated
        issues with localized routing in roaming case</t>
     <t>Modified heading of Section 3.3.1 to avoid confusion with localized routing
        between IPv4 Proxy-CoAs</t>

 </list></t>

-->
<!--
  </section>
-->
  </back>
</rfc>
