<?xml version="1.0" encoding="US-ASCII"?>
<!-- edited with XMLSPY v5 rel. 3 U (http://www.xmlspy.com)
     by Daniel M Kohn (private) -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY rfc2119 SYSTEM
    "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC3775 SYSTEM
    "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3775.xml">
<!ENTITY RFC4225 SYSTEM
    "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4225.xml">
<!ENTITY RFC4866 SYSTEM
    "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4866.xml">
<!ENTITY RFC5213 SYSTEM
    "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5213.xml">
<!ENTITY RFC3588 SYSTEM
    "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3588.xml">
<!ENTITY RFC3688 SYSTEM
    "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3688.xml">
<!ENTITY RFC4005 SYSTEM
    "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4005.xml">
<!ENTITY RFC4006 SYSTEM
    "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4006.xml">
<!ENTITY RFC4601 SYSTEM
    "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4601.xml">
<!ENTITY RFC4605 SYSTEM
    "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4605.xml">
<!ENTITY RFC6224 SYSTEM
    "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6224.xml">
<!ENTITY RFC7333 SYSTEM
    "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7333.xml">
<!ENTITY RFC6088 SYSTEM
    "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6088.xml">
<!ENTITY RFC6089 SYSTEM
    "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6089.xml">
<!ENTITY RFC6241 SYSTEM
    "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6241.xml">
<!ENTITY RFC6242 SYSTEM
    "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6242.xml">
<!ENTITY RFC6991 SYSTEM
    "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6991.xml">
<!ENTITY RFC7222 SYSTEM
    "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7222.xml">
    <!ENTITY RFC8040 SYSTEM
    "http://xml.resource.org/public/rfc/bibxml/reference.RFC.8040.xml">
<!ENTITY I-D.bertz-dime-policygroups SYSTEM
    "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.bertz-dime-policygroups.xml">
<!ENTITY I-D.ietf-dmm-requirements SYSTEM
    "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-dmm-requirements.xml">
<!ENTITY I-D.ietf-dmm-deployment-models SYSTEM
    "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-dmm-deployment-models.xml">
<!ENTITY I-D.ietf-netconf-restconf SYSTEM
    "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-netconf-restconf.xml">
<!ENTITY I-D.ietf-sfc-nsh SYSTEM
    "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-sfc-nsh.xml">
<!ENTITY I-D.ietf-6man-segment-routing-header SYSTEM
    "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-6man-segment-routing-header.xml">
<!ENTITY I-D.ietf-spring-segment-routing-mpls SYSTEM
    "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-spring-segment-routing-mpls.xml">
]>

<rfc category="std" docName="draft-ietf-dmm-fpc-cpdp-10"
     ipr="trust200902">
  <?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

  <?rfc toc="yes" ?>

  <?rfc symrefs="yes" ?>

  <?rfc sortrefs="yes"?>

  <?rfc iprnotified="no" ?>

  <?rfc strict="yes" ?>

  <front>
    <title abbrev="DMM FPC Protocol">Protocol for Forwarding Policy Configuration (FPC) in DMM</title>

     <author fullname="Satoru Matsushima" initials="S." surname="Matsushima">
      <organization abbrev="SoftBank">SoftBank</organization>

      <address>
        <postal>

          <street>1-9-1,Higashi-Shimbashi,Minato-Ku</street>

          <city>Tokyo  105-7322</city>

          <region></region>

          <code></code>

          <country>Japan</country>
        </postal>

        <phone></phone>

        <email>satoru.matsushima@g.softbank.co.jp</email>
      </address>
    </author>

    <author initials="L." surname="Bertz" fullname="Lyle Bertz">
    <organization abbrev="Sprint"></organization>
    <address>
    <postal>
              <street>6220 Sprint Parkway</street>

              <city>Overland Park  KS, 66251</city>

              <region></region>

              <code></code>

              <country>USA</country>
            </postal>

            <phone></phone>

            <email>lylebe551144@gmail.com</email>

    </address>
    </author>

    <author fullname="Marco Liebsch" initials="M." surname="Liebsch">
      <organization abbrev="NEC">NEC Laboratories Europe</organization>

      <address>
        <postal>
          <street>NEC Europe Ltd.</street>

          <street>Kurfuersten-Anlage 36</street>

          <city>D-69115 Heidelberg</city>

          <region></region>

          <code></code>

          <country>Germany</country>
        </postal>

        <phone>+49 6221 4342146</phone>

        <email>liebsch@neclab.eu</email>
      </address>
    </author>

   <author fullname="Sri Gundavelli" initials="S" surname="Gundavelli">
      <organization abbrev="">Cisco</organization>

      <address>
        <postal>
          <street>170 West Tasman Drive</street>

          <city>San Jose</city>

          <region>CA</region>

          <code>95134</code>

          <country>USA</country>
        </postal>

        <email>sgundave@cisco.com</email>
      </address>
    </author>



<author initials="D." surname="Moses" fullname="Danny Moses">
<organization abbrev="Intel Corporation"></organization>
<address>
<postal>
          <street></street>

          <city></city>

          <region></region>

          <code></code>

          <country></country>
        </postal>

        <phone></phone>

        <email>danny.moses@intel.com</email>

</address>
</author>

    <author fullname="Charles E. Perkins" initials="C.E." surname="Perkins">
       <organization abbrev="Futurewei">Futurewei Inc. </organization>
       <address>
         <postal>
           <street>2330 Central Expressway</street>
           <city>Santa Clara</city>
           <code>95050</code>
           <region>CA</region>
           <country>USA</country>
         </postal>
         <phone>+1-408-330-4586</phone>
         <email>charliep@computer.org</email>
       </address>
    </author>


    <date year="2017" />

    <workgroup>DMM Working Group</workgroup>

    <abstract>
      <t>
        This document describes a way, called Forwarding Policy Configuration
        (FPC) to manage the separation of data-plane and control-plane. FPC
        defines a flexible mobility management system using FPC agent and FPC
        client functions. An FPC agent provides an abstract interface to the
        data-plane. The FPC client configures data-plane nodes by using the
        functions and abstractions provided by the FPC agent for that data-plane
        nodes. The data-plane abstractions presented in this document is
        extensible, in order to support many different types of mobility
        management systems and data-plane functions.
      </t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">

        <t>This document describes Forwarding Policy Configuration (FPC), a
        system for managing the separation of data-plane and control-plane. FPC
        enables flexible mobility management using FPC agent and FPC client
        functions. An FPC agent exports an abstract interface to the data-plane.
        To configure data-plane nodes and functions, the FPC client uses the
        interface to the data-plane offered by the FPC agent.</t>

        <t>Control planes of mobility management systems, or other applications
        which require data-plane control, can utilize the FPC client at various
        granularities of operation. The operations are capable of configuring a
        single Data-Plane Node (DPN) directly, as well as multiple DPNs as
        determined by abstracted data-plane models on the FPC agent.</t>

        <t>A FPC agent provides data-plane abstraction in the following three
        areas: </t>

        <t>
        <list style="hanging">
            <t hangText="Topology:"> DPNs are grouped and abstracted according
            to well-known concepts of mobility management such as access
            networks, anchors and domains. A FPC agent provides an interface to
            the abstract DPN-groups that enables definition of a topology for
            the forwarding plane. For example, access nodes may be assigned to a
            DPN-group which peers to a DPN-group of anchor nodes. </t>

            <t hangText="Policy:">
            A Policy embodies the mechanisms for processing specific traffic flows
            or packets. This is needed for QoS, for packet processing to rewrite
            headers, etc. A Policy consists of one or more rules. Each rule is
            composed of Descriptors and Actions. Descriptors
            in a rule identify traffic flows, and Actions apply
            treatments to packets that match the Descriptors in the
            rule. An arbitrary set of policies can applied to a particular 
            collection of flows throgh the use of a Configurable-Policy.</t>

            <t hangText="Mobility:">A mobility session which is active on a mobile node
            is abstracted as a Mobility-Context with associated runtime
            concrete attributes, such as tunnel endpoints, tunnel
            identifiers, delegated prefix(es), routing information,
            etc. Mobility-Contexts are attached to DPNs via DPN-References.
            The References assign pre-defined Policies that were requested to be
            enforced as part of the mobility signaling request.  Policy may also 
            be realized by Embedded-Rules in the DPN-Reference.  Such policies are 
            typically highly specialized (e.g. negotiated as a part of signaling), 
            were not pre-provisioned or designed as a template.  Hence, they are not 
            reusable across Mobility-Contexts.</t>
            
            <t>Monitors provide a mechanism to produce reports when events regarding
            Configurable Policies, Mobility Contexts, DPNs or the Agent occur.</t>

        </list>
        </t>

        <t>The Agent assembles applicable sets of forwarding policies for the
        mobility sessions from the data model, and then renders those policies
        into specific configurations for each DPN to which the sessions
        attached. The specific protocols and configurations to configure DPN
        from a FPC Agent are outside the scope of this document.</t>

        <t> The data-plane abstractions may be extended to support many
        different mobility management systems and data-plane functions. The
        architecture and protocol design of FPC is not tied to specific types of
        access technologies and mobility protocols. </t>

    </section>

    <!-- <section anchor="pcmodel" title="Reference Architecture and Information Model"> -->

    <section anchor="terminology" title="Terminology">
      <t> The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
          "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
          document are to be interpreted as described in <xref
          target="RFC2119"></xref>.</t>

        <t><list hangIndent="24" style="hanging">
            <t hangText="DPN:">A data-plane node (DPN) is capable of
            deploying data-plane features. DPNs may be switches or routers
            regardless of their realiziation, i.e. whether they are hardware
            or software based.</t>

            <t hangText="FPC Agent:"> A functional entity in FPC that
            manages DPNs and provides abstracted data-plane networks to
            mobility management systems and/or applications through FPC
            Clients. </t>

            <t hangText="FPC Client:">A functional entity in FPC that
            is integrated with mobility management systems and/or
            applications to control forwarding policy, mobility sessions
            and DPNs. </t>

            <t hangText="Tenant:">An operational entity that manages
            mobility management systems or applications which require
            data-plane functions. </t>

            <t hangText="Domain:">One or more DPNs that form a
            data-plane network. A mobility management system or an
            application in a tenant may utilize a single or multiple
            domains.</t>

            <t hangText="Configurable Policy:">
                A set of Rules (forwarding policies) installed upon a DPN.</t>

            <t hangText="Mobility Context:">An abstracted endpoint of a mobility
            session associated with runtime attributes.
            </t>
        </list></t>

    </section>

    <section anchor="refarch" title="FPC Design Objectives and Deployment">

        <t> To fulfill the requirements described in <xref target="RFC7333"/>,
            FPC enables mobility control-planes and applications to configure
            DPNs with various roles of the mobility management as described
            in <xref target="I-D.ietf-dmm-deployment-models"/>. </t>

        <t> FPC defines building blocks of FPC Agent and FPC Client, as well as
            data models for the necessary data-plane abstractions.  The
            attributes defining those data models serve as protocol elements
            for the interface between the FPC Agent and the FPC Client.</t>

        <t> Mobility control-planes and applications integrate the FPC
            Client function.  The FPC Client connects to FPC Agent functions.
            The Client and the Agent communicate based on information models
            for the data-plane abstractions described in
            <xref target="model1"/>.  The data models allow the control-plane
            and the applications to support forwarding policies on the Agent
            for their mobility sessions. </t>

        <t> The FPC Agent carries out the required configuration and management
            of the DPN(s). The Agent determines DPN configurations according to
            the forwarding policies requested by the FPC Client.  The DPN
            configurations could be specific to each DPN implementation such that
            how FPC Agent determines implementation specific configuration for
            a DPN is outside of the scope of this document. Along with the models,
            the control-plane and the applications put Policies to the Agent
            prior to creating their mobility sessions. </t>

        <t> Once the Topology of DPN(s) and domains are defined for a data
            plane on an Agent, the data-plane nodes (DPNs) are available for
            further configuration. The FPC Agent connects those DPNs to manage
            their configurations.</t>

        <t> This architecture is illustrated in <xref target="fig_refarch"/>.
            An FPC Agent may be implemented in a network controller that handles
            multiple DPNs, or there is a simple case where another FPC Agent
            may itself be integrated into a DPN.</t>

        <t> This document does not adopt a specific protocol for the FPC interface
            protocol and it is out of scope. However it must be capable of
            supporting FPC protocol messages and transactions described in <xref
            target="protocol"/>. </t>


        <t>
        <figure anchor="fig_refarch"
          title="Reference Forwarding Policy Configuration (FPC) Architecture">
            <artwork align="center"><![CDATA[
                    +-------------------------+
                    | Mobility Control-Plane  |
                    |          and            |
                    |      Applications       |
                    |+-----------------------+|
                    ||      FPC Client       ||
                    |+----------^------------+|
                    +-----------|-------------+
        FPC interface protocol  |
                +---------------+-----------------+
                |                                 |
  Network       |                                 |
  Controller    |                      DPN        |
    +-----------|-------------+        +----------|---------+
    |+----------v------------+|        |+---------v--------+|
    ||   [Data-plane model]  ||        ||[Data-plane model]||
    ||       FPC Agent       ||        ||    FPC Agent     ||
    |+-----------------------+|        |+------------------+|
    |+------------+----------+|        |                    |
    ||SB Protocols|FPC Client||        |  DPN Configuration |
    ||   Modules  |  Module  ||        +--------------------+
    |+------^-----+----^-----+|
    +-------|----------|------+
            |          |
  Other     |          | FPC interface
  Southband |          | Protocol
  Protocols |          |
            |          +-----------------+
            |                            |
DPN         |                 DPN        |
 +----------|---------+       +----------|---------+
 |+---------v--------+|       |+---------v--------+|
 ||  Configuration   ||       ||[Data-plane model]||
 || Protocol module  ||       ||     FPC Agent    ||
 |+------------------+|       |+------------------+|
 |                    |       |                    |
 | DPN Configuration  |       |  DPN Configuration |
 +--------------------+       +--------------------+
              ]]></artwork>
            <postamble></postamble>
          </figure>
        </t>

        <t> The FPC architecture supports multi-tenancy; an FPC enabled
            data-plane supports tenants of multiple mobile operator networks
            and/or applications. It means that the FPC Client of each tenant
            connects to the FPC Agent and it MUST partition namespace and data
            for their data-planes. DPNs on the data-plane may fulfill multiple
            data-plane roles which are defined per session, domain and
            tenant.</t>

        <t> Note that all FPC models SHOULD be configurable. The FPC interface
            protocol in <xref target="fig_refarch"/> is only required to handle
            runtime data in the Mobility model. The rest of the FPC models,
            namely Topology and Policy, may be pre-configured, and in that case
            real-time protocol exchanges would not be required for them.
            Operators that are tenants in the FPC data-plane could configure
            Topology and Policy on the Agent through other means, such as <xref
            target="I-D.ietf-netconf-restconf">Restconf</xref> or <xref
            target="RFC6241">Netconf</xref>. </t>

    </section>

    <section anchor="model1" title="FPC Mobility Information Model">

    <section anchor="notation" title="Model Notation and Conventions">

    <t>In order to clarify the description of the information model, this draft uses the convention describe in the below.</t>

    <t>Information model entities, e.g. DPNs, Rules, etc., are listed in a hierarchical notation where all entities with the same hierarchical level are located on the same left-justified position one after the other. When entities are composed of sub-entities, they will appear shifted to the right.</t>

    <t>
        <figure anchor="fig-modelnotation"
                  title="Model Notation - An Example">
            <artwork align="center"><![CDATA[
         |             
         +-[entity2]
         |         +-[entity2.1]
         |         +-[entity2.2]
              ]]></artwork>
            <postamble></postamble>
          </figure>
    </t>
 
    <t>Some entities MAY have one or more sub-types placed on the right hand side of the element definition
       in pointing brackets. Common types include:
        <list style="hanging">
            <t hangText="List:">A collection of entities (some could be of the same kind)</t>
            <t hangText="Set:">A collection of entities without duplications</t>
            <t hangText="Name:">a human-readable string</t>
            <t hangText="Key:">a unique value. There are 3 types of keys:
            <list>
            <t hangText="U-Key:">a universally unique key across all tenants. U-Key spaces are typically involve the 
            use of registries or language specific mechanisms that guarantee universal uniqueness of values. </t>
            <t hangText="G-Key:">a globally unique key - unique within a tenant</t>
            <t hangText="L-Key:">a unique key within the set of values in local namespace.  For example, there exist 
            interfaces with teh same name, e.g. "interface0", in two different DPNs within the same tenant but there can
            only be one "interface0" within each DPN, i.e. its local Interface-Id L-Key space.</t>
            </list></t>
        </list></t>

	<t>The Settings pattern, i.e. attributes whose names contain the word 'Settings', is a genera set that holds
	unique properties.  If multiple values of a property are present they are held in a List for the property within
	the settings container.  The container acts as an extensible placeholder for properties (attribute/value pairs).</t>

<t>Each entity or its subtype may be optional (O) or mandatory (M). Entities that are not marked as optional are mandatory.</t>

       <t><figure anchor="fig-modelnotation_example">
            <artwork align="center"><![CDATA[
     Example: The following example shows 3 entities:
              - Entity1 is a globally unique key and has an 
                      optional, associated Name
              - Entity2 is a list
              - Entity3 is a set and is optional
         +
         | 
         +-[entity1] <G-Key> (M), <Name> (O)
         +-[entity2] <List>
         +-[entity3] <Set> (O)
         |
         +
            ]]></artwork>
             <postamble></postamble>
          </figure>
        </t>


    <t>When expanding entity1 into an information model such as YANG it would result in two values: entity1-GKey and entity1-Name.</t>


    </section>

    <section anchor="corestructure" title="Core Structure - Information Model Components">

    <t>The substructures that comprise the information model are:
    <list style="hanging">
            <t hangText="Topology: ">defines the different DPNs and links between them.</t>
            <t hangText="Policy-Definitions: ">describes how to handle flows: how to identify traffic and what actions are performed on data packets</t>
            <t hangText="Configurable-Policy: ">policies that are relatively static. These policies are usually pre-provisioned and are modified only
            when the network configuration is updated or when new policy rules are configured</t>
            <t hangText="Mobility-Context: "> policies that are created or modified during the network's operation. In most cases, on a per-flow or per session basis</t>
            <t hangText="Monitor: "> a list of events that trigger notification messages from FPC Agents to FPC Clients</t>
    </list></t>

    <t><figure anchor="fig-mobility-core-structure" title="Mobility Information Model - Core Structure">
            <artwork align="center"><![CDATA[
     :
     |
     +-[Mobility]
     |          +
     |          |
     :          +-[Topology]
                |
                +-[Policy]
                |
                +-[Configurable-Policy] <Set>
                |
                +-[Mobility-Context] <Set>
                |
                +-[Monitor] <Set>
    ]]></artwork>
            <postamble></postamble>
          </figure>
        </t>

    </section>        <!-- end section Core Structure" -->


    <section anchor="topology" title="Topology">

    <t>The Topology sub-structure specifies virtual DPNs and the relations between them. It is used by the network
       management entity to select the most appropriate DPN resources for handling specific session flows.</t>

    <t>A virtual DPN is a logical entity that performs DPN functionality (packet movement and management). It may
       represent a physical DPN unit, a sub-function of a physical DPN or a collection of physical DPNs. The motivation
       to refer to virtual DPNs in the information model rather than physical DPNs is to provide flexibility for network
       architects to define which DPN-selection capabilities are performed by the FPC Agent (distributed) and which by the FPC
       client (centralized).</t>

    <t>When a virtual DPN is mapped to a physical DPN, the FPC client has maximum knowledge of the DPN architecture and uses
       it to perform DPN selection for specific sessions. When a virtual DPN is mapped to a collection of physical DPNs, the
       FPC client cannot select a specific physical DPN because it is hidden by the abstraction and only the FPC Agent can
       address the specific associated physical DPNs.</t>

    <t>The Topology sub-structure is comprised of the following sub-structures:
    <list style="hanging">
     <t hangText="DPN-Set: "> the set of virtual DPNs in a network configuration</t>
     <t hangText="DPN-Type-Set: "> a set of DPN-Type entities</t>
     <t hangText="DPN-Group-Set: "> a set of virtual DPNs that supports a specific administrative purpose (in/out bound, roaming,
        subnetwork with common specific configuration etc.)</t>
     <t hangText="Domain: "> a set of Domains tha represent a logical partition of network resources</t>
    </list></t>

    <t><figure anchor="fig-topology-substructure" title="Topology Substructure">
            <artwork align="center"><![CDATA[
        |
        +-[Topology]
        |          +-[DPN] <Set>
        |          +-[DPN-Type] <Set>
        |          +-[DPN-Group] <Set>
        |          +-[Domain] <Set>
    ]]></artwork>
            <postamble></postamble>
          </figure>
        </t>


    <section anchor="dpn" title="DPN">

    <t>The DPN set sub-structure specifies a subset of virtual DPNs in the network . Some of
       the DPNs may be identical in functionality and only differ by their key.</t>


    <t><figure anchor="fig-dpn-substructure" title="DPN Substructure">
            <artwork align="center"><![CDATA[
        |
        +-[DPN] <Set>
        |     +-[DPN-Id] <G-Key>, <Name> (O)
        |     +-[DPN-Resource-Mapping-Reference] (O) 
        |     +-[Interface] <Set>
        |                 +-[Interface-Reference]
        |                 |           +-[Access-Technology] <U-Key>
        |                 |           +-[Role] <U-Key>
        |                 |           +-[Interface-Id] <L-Key>
        |                 +-[Interface-Settings] <Set> (O)
    ]]></artwork>
            <postamble></postamble>
          </figure>
        </t>

    <t>Each DPN entry contains the following information:
    <list style="hanging">
    <t hangText="DPN-Id (Key):"> A unique ID of the virtual DPN</t>
    <t hangText="DPN-Id (Name):">the human-readable display string</t>
    <t hangText="DPN-Resource-Mapping-Reference (O):">A reference to the underlying implementation, e.g. physical node,
       virtual element, etc. that supports this DPN.  This value MUST be non-empty prior to Dynamic-Policies being installed upon the DPN.</t>
    <t hangText="Interface-Set:"> the set of interfaces (through which data packets are received and transmitted) of that Virtual DPN. The virtual DPN
       abstracts one or multiple physical DPNs each having one or more interfaces. The Interface-set sub-structure is a collection of all interface
       types available by this virtual DPN. The purpose of this information is not to describe each interface of each DPN, but rather, to indicate
       the entire set of interface types for the sake of the DPN selection process, when a DPN with specific interface capabilities is required.
       Each interface entry has a reference to a defined DPN-Type entry in the DPN-Type-Set sub-structure defined below and additional information
       that is specific to that interface:
       <list>
       <t>Interface-Reference - a 3-tuple key that uniquely references an entry in the DPN-Type-Set sub-structure: Access-Technology, Role and Interface-Id.</t>
       <t>Interface-Settings - An optional set of settings of this interface (that do not affect the DPN selection of active or enabled interfaces). 
       	Examples: MTU size, display name, etc.</t> 
       </list></t>
    </list></t>


    </section> <!-- End section DPN-->


    <section anchor="dpn-type" title="DPN-Type">

    <t>DPN-Type is the collection of all possible types of interfaces defined for DPNs in the network. The interfaces are grouped according
       to their access technology, e.g. 3GPP, WiMAX, 802.x and Role, e.g. LMA, MAG, PGW, AMF etc. Within a group, interfaces may have
       additional properties that are more specific, a list of features and optionally settings relevant to DPN selection. This information
       is used when searching for resources in a network to carry out required operations on data traffic.</t>
    
    <t><figure anchor="fig-dpn-type" title="DPN Type">
            <artwork align="center"><![CDATA[
      |
      +-[DPN-Type] <Set>
      |     +-[Access-Technology] <U-Key>,<Name> (O)
      |     +-[Role] <U-Key>, <Name> (O) 
      |     +-[Interface] <Set>
      |             +-[Interface-ID] <L-Key>, <Name> (O)
      |             +-[Interface-Protocol] <Set> 
      |             +-[Features] <Set> (O) 
      |             +-[Interface-Settings] <Set> (O)
      ]]></artwork>
            <postamble></postamble>
          </figure>
        </t>

    <t>Each DPN-Type entry contains the following information:
    <list style="hanging">
    <t hangText="Access-technology: ">the technology used in the access network that originated the signaling (WiMAX, 3GPP, 802.x etc.)</t>
    <t hangText="Role: ">the role (MAG, LMA, PGW, AMF etc.) of the device sharing the interfaces specified below.</t>
    <t hangText="Interface: ">A set of interfaces possible for the group above. Each interface carries the following information:
      <list>
      <t>Interface-Id: a key that is used together with the 2-tuple Access-Technology and Role, to create a 3-tuple key that is referred
         to be the interface definition of virtual DPNs</t>
      <t>Interface-Protocols: rotocols supported by this interface - PMIP, S5-GTP, S5-PMIP etc.</t>
      <t>Features: an optional set of supported features which further determine the suitability of the interface to the desired operation</t>
      <t>Interface-Settings: an optional set of settings that MUST be known when determining the suitability of an interface for the
         specific request. The difference between 'Features' and 'Settings' is that 'Features' are static while 'Settings' may be configured.
         Examples: SequenceNumber=ON/OFF</t>
      </list></t>
     </list></t>

     <t>The entries Access-Technology and Role represent a tuple key that uniquely identifies the set of interfaces that may be available
        for DPNs of the specific type.</t>

    </section> <!-- End section DPN Type-->


    <section anchor="dpn-group" title="DPN-Group">

    <t>A DPN-Group is a list of a group of DPNs serving some administrative purpose. Each group contains a list of DPNs
       (referenced by DPN-ID) and selected interfaces (referenced by the interface's 3-tuple key). The interfaces are listed
       rather than referred implicitly by each specific DPN to enable to define a subset of a DPN interfaces to be part of the group.</t>

    <t><figure anchor="fig-dpn-group" title="DPN Group">
            <artwork align="center"><![CDATA[
 |
 +-[DPN-Group] <Set>
 |           +-[DPN-Group-Id] <G-Key>, <Name> (O)
             +-[Referenced-Interface] <Set>
             |           +-[Interface-Id] <L-Key>
             |           +-[Role] <U-Key>
             |           +-[Access-Technology] <U-Key>
             |           +-[Supporting-DPN-Id] <Set>
             |           +-[DPN-Group-Peer-Reference] <Set> (O)
             +-[DPN-Peer-Group] <Set>                     
             |           +-[Remote-DPN-Group-ID] <L-key>
             |           +-[Interface-Settings] <Set> (O)
             +-[Domain-Id-Reference]
       ]]></artwork>
            <postamble></postamble>
          </figure>
        </t>

    <t>Each DPN-Group entry contains the following information:
    <list style="hanging">
    <t hangText="DPN-Group (Key):"> A unique ID of the DPN-Group</t>
    <t hangText="DPN-Group (Name):">the human-readable display string</t>
    <t hangText="Referenced-Interfaces:">A set of interfaces and the DPNs / associated DPN-Peer-Groups that support them.  Each
    entry contains
    <list style="hanging">
    <t hangText="Interface-Id: ">a key that is used together with the 2-tuple Access-Technology and Role, to create a 3-tuple key that is referred
         to be the interface definition of virtual DPNs</t>
    <t hangText="Role: ">the role (MAG, LMA, PGW, AMF etc.) of the device sharing the interfaces specified below.</t>
    <t hangText="Access-technology: ">the technology used in the access network that originated the signaling (WiMAX, 3GPP, 802.x etc.)</t>
    <t hangText="Role: ">the role (MAG, LMA, PGW, AMF etc.) of the device sharing the interfaces specified below.</t>
    <t hangText="Supporting-DPN-Id (Set): ">A set of DPN-Id-References that support the specific interface for this DPN-Group.</t>
    <t hangText="Interface-Settings: ">an optional set of settings that MUST be known when determining the suitability of an interface for the
         specific request.F</t>
    </list></t>
        <t hangText="DPN-Peer-Group:">A set of Remote (from the DPN-Group's point of view) DPN-Groups.  When communication occurs between the DPN-Group
        and DPN-Peer-Group the Interface-Settings MUST be used.  Each entry contains the following information:
    entry contains
    <list style="hanging">
    <t hangText="Remote-DPN-Group-Id: "> A unique ID of the DPN-Peer-Group</t>
    <t hangText="Interface-Settings: ">an optional set of settings that MUST be known when determining the suitability of an interface for the
         specific request.</t>
    </list></t>
    </list></t>

    </section> <!-- End section DPN Group-->
    </section>        <!-- end section Topology -->

    <section anchor="policy" title="Policy">

    <section anchor="policy-substructure" title="Policy Substructure">

    <t>The Policy substructure defines and identifies grouped Rules for enforcement on the data plane. Rules comprise
       traffic descriptors and actions on how to treat traffic in case the traffic descriptor matches a data packet.
       The Policy substructure is independent of a policy context, whether it's an administratively configurable
       policy which applies to all or a defined aggregate of data flows, or a mobility context-related policy, which is
       associated with a mobility session and may apply only to data traffic of an associated mobile node while being registered.</t>

    <t>In addition to the Policy substructure, the Core Structure per <xref target="corestructure"/> holds accordingly
       separate entries for the Configurable-Policy as well as for Mobility-Context, which do not only define their own policies
       by embedded rules, but comprise references to policy definitions in the Policy substructure, to which additional
       settings can be applies on a per-Configurable-Policy basis and on a per-Mobility-Context bases respectively.</t> 

    <t>Traffic descriptions and traffic treatment actions are defined separately in Descriptor-Definition and
       Action-Definition respectively. Binding between traffic descriptors and associated traffic treatment action is
       defined in a set of rule definition entries (Rule-Definition) which comprise references to entries in the set of
       traffic descriptors (Descriptor-Reference) and traffic treatment actions (Action-Reference). Accordingly, a single
       rule or a group of rules are bound to a policy in the set of policy definitions (Policy-Definition) by reference to
       entries in the set of rule definitions (Rule-ID).</t>

 <t><figure anchor="fig-policy-substructure" title="Policy Substructure">
            <artwork align="center"><![CDATA[
  |
  +-[Policy]
  |      +-[Policy-Definition] <Set>
  |      |             +-[Policy-Id] <G-Key> (M)
  |      |             +-[Rule-Reference] Set (M)
  |      |             +-[Precedence] <L-Key> (M)
  |      |             +-[Rule-Id-Reference] (M)
  |      +-[Rule-Definition] <Set>
  |      |             +-[Rule-Id] <L-Key> (M)
  |      |             +-[Descriptor-Match-Type] (M) 
  |      |             +-[Descriptor-Reference] <Set>
  |      |             |                +-[Descriptor-ID-Reference]
  |      |             |                +-[Direction] (O)
  |      |             +-[Action-Reference] <Set>
  |      |                              +-[Action-Id-Reference] 
  |      |                              +-[Action-Order]
  |      +-[Descriptor-Definition] <Set>
  |      |             +-[Descriptor -Id] <L-Key> (M)
  |      |             +-[Descriptor-Type]
  |      |             +-[Descriptor-Value]
  |      +-[Action-Definition] <Set>
  |                    +-[Action-Id] <L-Key> (M)
  |                    +-[Action-Type]
  |                    +-[Action-Value] 
  |
      ]]></artwork>
            <postamble></postamble>
          </figure>
        </t>

    <t>The Policy Substructure contains the following entries:
    <list style="hanging">
    <t hangText="Policy-Definition: ">A set of policy definitions which bind a single or multiple rules to a policy.
    <list>
    <t hangText="Policy-Id: ">Identifies a policy definition.</t>
    <t hangText="Rule-Reference: ">Assigns a set of rule definitions, which are bound to a policy definition, by reference
       to the associated Rule in the Rule-Definition Substructure.</t>
    <t hangText="Precedence: ">Defines the order with which the rules must be applied.</t>
    <t hangText="Rule-Id-Reference: ">Identifies a rule.</t>
    </list></t>
    <t hangText="Rule-Definition: ">A set of rule definitions which bind a single or multiple traffic descriptors
       (by reference to Descriptor-Definition) to a single or multiple traffic treatment actions (by reference to Action-Definition).
    <list>
    <t hangText="Rule-Id: ">Identifies a rule definition.</t>
    <t hangText="Descriptor-Match-Type: ">Conjuction of Descriptor-Values to apply as match to DPN traffic, which can be either
       OR or AND. The identified conjunction applies to all Descriptor-Definitions in the given Rule-Definition.</t>
    <t hangText="Descriptor-Reference: ">Assigns a set of descriptors to the rule by reference to the associated Descriptor-Definition.</t>
    <t hangText="Descriptor-Id-Reference: ">Identifies the referred Descriptor-Definition</t>
    <t hangText="Direction: ">Indicates if a rule applies to uplink traffic, to downlink traffic, or to both, uplink- and downlink traffic.
       Applying a rule to both, uplink- and downlink traffic, in case of symmetric rules, allows omitting a separate entry for each direction.
       When not present, the direction is implied by the Descriptor's values.</t>
    <t hangText="Action-Reference: ">Assigns a set of actions to the rule by reference to the associated Action-Definition.</t>
    <t hangText="Action-Id-Reference: ">Identifies the referred Action-Definition.</t>
    <t hangText="Action-Order: ">Defines the order how actions are executed in case the rule applies per match of the associated traffic descriptor.</t>
    </list></t>
    <t hangText="Descriptor-Definition: ">A set of descriptor definitions, each being identified by a key (Descriptor-ID)
    <list>
    <t hangText="Descriptor-Id: ">Identifies a descriptor definition.</t>
    <t hangText="Descriptor-Type: ">Identifies the type of descriptor, e.g. an IPv6 traffic selector per [RFC 6088], for unambiguous
2      interpretation of a Descriptor-Value.</t>
    <t hangText="Descriptor-Value: ">Defines all required attribute-value pairs per the traffic descriptor type identified in Descriptor-Type.</t>
    </list></t>
    <t hangText="Action-Definition: ">A set of action definitions.
    <list>
    <t hangText="Action-Id: ">Identifies an action definition.</t>
    <t hangText="Action-Type: ">Identifies the type of an action for unambiguous interpretation of an Action-Value entry.</t>
    <t hangText="Action-Value: ">Defines all required attribute-value pairs per the action type identified in Action-Type.</t>
    </list></t>
    </list></t>


    </section> <!-- End policy substructure -->


    <section anchor="config-policy" title="Configurable Policy">

    <t><figure anchor="fig-configurable-policy" title="Configurable Policy">
            <artwork align="center"><![CDATA[
      |
      +-[Configurable-Policy] <Set>
      |               +-[DPN-Id-Reference] <U-Key>
      |               +-[Installed-Policy] <List>                   
      |               |           +-[Installed-Policy-Id] <G-Key>
      |               |           +-[Policy-Id-Reference]
      |               |           +-[Policy-Settings] <Set> (O)
      |               +-[Settings] <Set> (O)
      |
     ]]></artwork>
            <postamble></postamble>
          </figure>
        </t>

    <t>The Configurable-Policy Substructure contains the following entries:
    <list style="hanging">
    <t hangText="DPN-Id-Reference: ">Refers to the DPN to which the policy applies.</t>
    <t hangText="Installed-Policy: ">A list of policies that apply to an identified DPN.
    <list>
    <t hangText="Installed-Policy-Id: ">Holds the identifier of the DPN at which the policy has been installed.</t>
    <t hangText="Policy-Id-Reference: ">Assigns a policy by reference to the associated Policy-Definition.</t>
    <t hangText="Policy-Settings: ">Settings that apply to the previously referenced policy to complement rules or
      make them concrete, e.g. in case the descriptor representing a packet match has not or unambiguously been defined
      in the poliicy sub-structure.</t>
    </list></t>
    <t hangText="Settings: ">Settings that apply to multiple policies at the identified DPN.</t>
    </list></t>

    </section>


    </section> <!-- end section Policy-->

    <section anchor="mobility" title="Mobility-Context">

   <t>The Mobility-Context Substructure holds entries associated with a mobile node's mobility sessions. At least one instance 
      is created at the mobile node's registration to serve as parent context. Additional instances holding child context with
      reference to parent context can be created. Child context holds, for example, descriptors of mobile node data traffic which needs
      to be treated different from traffic that matches descriptor of the parent context, e.g. in terms of QoS. Child context can
      inherit some attributes/values from parent context, such as traffic encapsulation and forwarding information, but can hold different
      or additional attributes/values that apply to traffic that matches the descriptor of the child context.</t>

    <t>Termination a parent context implies termination of all dependent child context, e.g. at deregistration of a mobile node.</t>

   <t><figure anchor="fig-mobility-context" title="Mobility Context">
            <artwork align="center"><![CDATA[
 |
 +-[Mobility-Context] <Set>
 |            +-[Mobility-Context-Id] <G-Key>
 |            +-[DPN-Group-Id-Reference] (O)
 |            +-[Parent-Mobility-Context-Id-Reference] (O)
 |            +-[DPN-References] <List>
 |            |          +-[DPN-Id-Reference] 
 |            |          +-[Direction] (O) 
 |            |          +-[DPN-Settings-Complementary]
 |            |          +-[Interface-Id-Reference] 
 |            |          +-[Embedded-Rule] <Set> (O)
 |            |          +-[Assigned-Policy-Reference] <Set> (O)
 |            +-[Requested-Policy-Reference] <Set> (O)
 |            +-[Context-Settings-Complementary] <Set> (O)
    ]]></artwork>
            <postamble></postamble>
          </figure>
        </t>

  <t>The Mobility-Context Substructure holds the following entries:
    <list style="hanging">
    <t hangText="Mobility-Context-Id: ">Identifies a Mobility-Context</t>
    <t hangText="DPN-Group-Id-Reference: ">Assigns a DPN-Group, which groups DPN that are used during the DPN selection procedure, by reference.</t>
    <t hangText="Parent-Mobility-Context-Id-Reference: ">Assigns a parent Mobility-Context to aquire settings as required.</t>
    <t hangText="DPN-References: ">Holds a list of DPNs with the associated concrete policies that apply to the DPN. An entry MUST have at least
    one value present in its Assigned-Policy-Refence or Embedded-Rule sets in order to be valid.
    <list>
    <t hangText="DPN-Id-Reference: ">Assigns a DPN, to which the policy applies, by reference.</t>
    <t hangText="Direction: ">Indicates if a rule applies to uplink or downlink traffic, or to both, uplink- and downlink traffic. Applying a
       rule to both, uplink- and downlink traffic, in case of symmetric rules, allows omitting a separate entry for each direction.
       When not present the value is assumed to apply to both directions.</t>
    <t hangText="DPN-Settings-Complementary: ">Complementary seeings that apply to the DPN for the given Mobility-Context.</t>
    <t hangText="Interface-Id-Reference: ">Assigns the selected interface of the DPN my reference.</t>
    <t hangText="Embedded-Rule: ">Rule that applies to the DPN for this Mobility-Context. This rule is embedded and not refereced in the
       Policy substructure.</t>
    <t hangText="Assigned-Policy-Reference: ">A set of references to the list of Requested-Policy-References per this Mobility-Context.</t>
    </list></t>
    <t hangText="Requested-Policy-Reference: ">Assigns a list of policies in Policy-Definitions that can apply to any DPN per this Mobility-Context.
      DPN-Reference entries can select from this list of policy references to apply to the associated DPN.</t>
    <t hangText="Context-Settings-Complementary: ">Complementary settings that apply to the referenced policies per this Mobility-Context.</t>
    </list></t>

    </section> <!-- End mobility context -->

    <section anchor="rule-template" title="Rule Template">

    <t>The Rules Template format is aligned with the Rule Substructure. It can represent an Embedded-Rule
       per the Mobility-Context Substructure.</t>

    <t><figure anchor="fig-rules-template" title="Rule Template">
            <artwork align="center"><![CDATA[
     |
     +-[Embedded-Rule] <List>
     |         +-[Rule-Id] (M)
     |         +-[Precedence] <L-Key>
     |         +-[Descriptor-Match-Type] (M)
     |         +-[Descriptor-Definition] <Set>
     |         |             +-[Descriptor-Id] <L-Key> (M)
     |         |             +-[Descriptor-Type]
     |         |             +-[Descriptor-Value]
     |         +-[Action-Definition] <Set>
     |                       +-[Action-Order] <L-Key> (M)
     |                       +-[Action-Id] (O)
     |                       +-[Action-Type]
     |                       +-[Action-Value]
    ]]></artwork>
            <postamble></postamble>
          </figure>
        </t>

<t>The Embedded-Rule template holds the following entries:
    <list style="hanging">
    <t hangText="Rule-Id: ">Identifies a rule definition. It is provided for convenience.</t>
    <t hangText="Precedence: ">Defines the order with which the rules must be applied and is used as the key.</t>
    <t hangText="Descriptor-Match-Type: ">Conjuction of Descriptor-Values to apply as match to DPN traffic,
                                          which can be either OR or AND. The identified conjunction applies
                                          to all Descriptor-Definitions in the given Rule-Definition</t>
    <t hangText="Descriptor-Definition: ">A set of descriptor definitions, each being identified by a key (Descriptor-ID)
    <list>
    <t hangText="Descriptor-Id: ">Identifies a Descriptor-Definition</t>
    <t hangText="Descriptor-Type: ">Identifies the type of descriptor, e.g. an IPv6 traffic selector per [RFC 6088], for
                                    unambiguous 2 interpretation of a Descriptor-Value</t>
    <t hangText="Descriptor-Value: ">Defines all required attribute-value pairs per the traffic descriptor type identified
                                     in Descriptor-Type.</t>
    </list></t>
    <t hangText="Action-Definition: ">A set of action definitions.
    <list>
    <t hangText="Action-Order: ">Defines the order how actions are executed in case the rule applies per match of the associated traffic descriptor.</t>
    <t hangText="Action-Id: ">Identifies an action definition.</t>
    <t hangText="Action-Type: ">Identifies the type of an action for unambiguous interpretation of an Action-Value entry.</t>
    <t hangText="Action-Value: ">Defines all required attribute-value pairs per the action type identified in Action-Type.</t>
    </list></t>
    </list></t>

    </section>  <!-- End embeddable-rule -->

   <section anchor="monitor_overview" title="Monitors">
        <t> Monitors provide a mechanism to produce reports when events
            occur. A Monitor will have a target that specifies what is to
            be watched. </t>
        <t> When a Monitor is specified, the configuration MUST be applicable
            to the attribute/entity monitored. For example, a Monitor using a
            Threshold configuration cannot be applied to a Context, because
            Contexts do not have thresholds. But  such a monitor could be
            applied to a numeric threshold property of a Context. </t>
        <t>
        <figure anchor="fig-monitor"
                  title="Monitor Substructure">
            <artwork align="center"><![CDATA[
       |
       +-[Monitor] <List>
       |         +-[Monitor-Id] <U-Key>
       |         +-[Target]
       |         +-[Binding-Information] (O)
       |         +-[Deterrable] (O)
       |         +-[Configuration]
              ]]></artwork>
            <postamble></postamble>
          </figure>
        </t>

        <t><list style="hanging">
        <t hangText="Monitor-Id:"> Name of the Monitor. The ID format MUST conform to <xref target="naming"></xref>.</t>
        <t hangText="Target:"> Description of what is to be monitored. This can be an Event, a Dynamic Policy, an installed DPN Policy,
              or values of a Dynamic-Policy attribute. When the type is an attribute of Mobility-Context, the target name
              is a concatenation of the Context-Id and the relative path (separated by '/') to the attribute(s) to be monitored. 
              Target must provide unambiguously identify the monitored attribute and the location (DPN).</t>
        <t hangText="Binding-Information:"> Complements (ambigous) Target information to define the Monitor in an unambigous way.</t>
        <t hangText="Deterrable: "> Indicates that a monitoring report can be delayed in a defined delay budget for possible bundling with other reports</t>
        <t hangText="Configuration:"> Determined by the Monitor subtype. The recipient of a notification as monitor report is specified
              in the Configuration. Four reporting types are defined:
              <list style="symbols">
                  <t>Periodic reporting specifies an interval by which a notification is sent.</t>
                  <t>Event reporting specifies a list of event types that, if they occur and are related to the monitored
                  attribute, will result in sending a notification.</t>
                  <t>Scheduled reporting specifies the time (in seconds since Jan 1, 1970) when a notification for the monitor should
                  be sent. Once this Monitor's notification is completed the Monitor is automatically de-registered.</t>
                  <t>Threshold reporting specifies one or both of a low and high threshold. When these values are crossed a
                  corresponding notification is sent.</t>
              </list>
            </t>
        </list></t>

    </section>        <!-- end section title="Monitors"  -->


    <section anchor="naming" title="Namespace and Format">
<t>The identifiers and names in FPC models which reside in the same
   namespace must be unique.  That uniqueness must be kept in agent or
   data-plane tenant namespace on an Agent.  The tenant namespace
   uniqueness MUST be applied to all elements of the tenant model, i.e.
   Topology, Policy and Mobility models.</t>
   
   <t> When a Policy needs to be applied to Contexts in all tenants on an
   Agent, the Agent SHOULD define that policy to be visible from all the
   tenants.  In this case, the Agent assigns an unique identifier in the
   agent namespace and effectively creates a U-Key although only a G-Key is required.</t>
   
   <t> The format of identifiers can utilize any format with agreement
   between data-plane agent and client operators.  The formats include
   but are not limited to Globally Unique IDentifiers (GUIDs),
   Universally Unique IDentifiers (UUIDs), Fully Qualified Domain Names
   (FQDNs), Fully Qualified Path Names (FQPNs) and Uniform Resource
   Identifiers (URIs).</t>

<t>The FPC model does not limit the types of format that dictate the
   choice of FPC protocol.  However the choice of identifiers which are
   used in Mobility model need to be considered to handle runtime
   parameters in real-time.</t>
   
    </section>        <!-- end section title="Namespace and Format"  -->

    <section anchor="attr_application" title="Attribute Application">



    </section>        <!-- end section title="Attribute Application"  -->

</section>        <!-- end section title="Information Model"  -->


<section anchor="protocol" title="Protocol">
<t>NOTE - The terms Context and Mobility-Context are used interchangeable 
throughout the rest of this document.</t>
  <section anchor="messageandsematics" title="Protocol Messages and Semantics">
    <t>Five message types are supported:</t>
<texttable anchor="messages" title="Client to Agent Messages">
    <ttcol align="left">Message</ttcol>
    <ttcol align="left">Type</ttcol>
    <ttcol align="left">Description</ttcol>

    <c>CONF</c>
    <c>HEADER OP_TYPE BODY</c>
    <c>Configure processes a single operation.</c>

    <c>CONF_BUNDLE</c>
    <c>HEADER OP_TYPE REF_SCOPE TRANS_STRATEGY 1*[OP_ID BODY]</c>
    <c> A Conf-bundle takes multiple operations that are to be executed as a
    group with partial failures allowed. They are executed according to the
    OP_ID value coupled with the BODY in ascending order. If a CONF_BUNDLE
    fails, any entities provisioned in the CURRENT operation are removed.
    However, any successful operations completed prior to
    the current operation are preserved in order to reduce system load.</c>

    <c> REG_MONITOR</c>
    <c> HEADER *[ MONITOR ]</c>
    <c> Register a monitor at an Agent. The message includes information about
    the attribute to monitor and the reporting method.  Note that a
    MONITOR_CONFIG is required for this operation.</c>

    <c> DEREG_MONITOR</c>
    <c> HEADER 1*[ MONITOR_ID ] [ SEND_DATA ]</c>
    <c> Deregister monitors from an Agent. Monitor IDs are provided. SEND_DATA is
    an optional boolen that indicates if a successful DEREG triggers a NOTIFY with
    final data.</c>

    <c> PROBE</c>
    <c> HEADER MONITOR_ID</c>
    <c> Probe the status of a registered monitor.</c>
    </texttable>
    <t> Each message contains a header with the Client Identifier, an execution
    delay timer and an operation identifier. The delay, in ms, is processed
    as the delay for operation execution from the time the operation is
    received by the Agent.</t>

    <t> The Client Identifier is used by the Agent to associate specific
    configuration characteristics, e.g. options used by the Client when
    communicating with the Agent, as well as the association of the Client
    and tenant in the information model.</t>

    <t> CONF_BUNDLE also has the Transaction Strategy (TRANS_STRATEGY)
    attribute.  This value specifies the behavior of the Agent when an
    operation fails while processing a CONF_BUNDLE message.  The value of
    'default' uses the default strategy defined for the message.  The value
    'all_or_nothing' will roll back all successfully executed operations
    within the bundle as well as the operation that failed.</t>

    <t> An FPC interface protocol used to support this
    specification may not need to support CONF_BUNDLE messages or specific
    TRANS_STRATEGY types beyond 'default' when the protocol provides
    similar semantics.  However, this MUST be clearly defined in the
    specification that defines the interface protocol.</t>

    <t> An Agent will respond with an ERROR, OK, or an OK WITH INDICATION that
    remaining data will be sent via a notify from the Agent to the Client
    <xref target="asyncnotification"/> for CONFIG and CONF_BUNDLE requests.
    When returning an 'ok' of any kind, optional data MAY be present.</t>
    <t>Two Agent notifications are supported:</t>
    <texttable anchor="notifications"
            title="Agent to Client Messages (notifications)">
      <ttcol align="left">Message</ttcol>
      <ttcol align="left">Type</ttcol>
      <ttcol align="left">Description</ttcol>

      <c>CONFIG_RESULT_NOTIFY</c>
      <c>See <xref target="ayncnotify_detail"/></c>
      <c>An asynchronous notification from Agent to Client based upon a
    previous CONFIG or CONF_BUNDLE request.</c>

      <c>NOTIFY</c>
      <c>See <xref target="notify_structs"/></c>
      <c>An asynchronous notification from Agent to Client based upon a
    registered MONITOR.</c>
    </texttable>
    
    <t>The HEADER is a part of all messages and is comprised of the following information:
    <list hangIndent="4" style="hanging">
    	<t hangText="CLT_ID:"> The Client Identifier </t>
    	<t hangText="DELAY (OPTIONAL):"> The time (in ms) to delay the execution of ther operaiton
    	 on the DPN once it is received by the Agent.</t>
    	<t hangText="OP_ID:"> Operation Identifier</t>
    </list>
    </t>
    

    <t>Results will be supplied per operation input. Each result contains the
      RESULT_STATUS and OP_ID that it corresponds to. RESULT_STATUS values are:
      <list>
      <t> OK - Success </t>
      <t> ERR - An Error has occurred </t>
      </list>
    </t>
    <t> If an error occurs, information MUST be returned in the response.  Error informaiton 
    is comprised of the following:
    <list>
    <t> ERROR_TYPE_ID (Unsigned 32, REQUIRED) - The identifier of a specific
        error type The values are TRANSPORT (0), RPC (1), PROTOCOL(2) or 
        APPLICATION (3).</t>
    <t> ERROR_TAG - (String, REQUIRED) - enumerated error tag.</t>
    <t> ERROR_APP_TAG - (String, OPTIONAL) - Application specific error tag.</t>
    <t> ERROR_MESSAGE - (String, OPTIONAL) - A message describing the error.</t>
    <t> ERROR_INFO - (Any Data, OPTIONAL) - Any data required for the response.</t>
    </list>
    </t>
    
  <section anchor="conf-processing" title="CONFIG and CONF_BUNDLE Messages">
    <t>CONFIG and CONF_BUNDLE include OP_TYPE as part of the header information:
    <list hangIndent="4" style="hanging">
      <t hangText="OP_TYPE:"> specifies the type of operation. Valid values
    are 'create' (0), 'update' (1), 'query' (2) or 'delete' (3).</t>
    </list></t>
    
    <t>The BODY is comprised of the following information:
    <list hangIndent="4" style="hanging">
      <t hangText="COMMAND_SET:"> Specifies the Command Set (see <xref target="commandsets"/>).</t>
	  <t hangText="REF_SCOPE:"> If supported, specifies the Reference Scope (see <xref target="refscope"/>)</t>
      <t hangText="BODY INTERNALS:"> A list of entities under Policy, e.g. Policy-Definitions,
      Action-Definitions, etc. as well as Installed Policies and Contexts
    when the OP_TYPE is 'create' or 'update'.  Otherwise it is a list of
    Targets for 'query' or 'deletion'.  See <xref target="op-body"/>
        for details.</t>
    </list>
    </t>
<t>CONF_BUNDLES includes an OP_ID with each body for tracking of the bundle's subtransactions.</t>
    <section anchor="agent-processing" title="Agent Operation Processing">
      <t>The Agent will process entities provided in an operation in the
    following order:
        <list style="numbers">
    <t>Action-Definitions</t>
    <t>Descriptor Defintions</t>
    <t>Rule Definitions</t>
    <t>Policy Definitions</t>
    <t>Installed Policies</t>
    <t>Mobility Contexts according to COMMAND_SET</t>
    </list></t>
    </section>
    <section anchor="commandsets" title="Command Bitsets">
    <t> The COMMAND_SET is a technology specific bitset that allows for a
    single entity to be sent in an operation with multiple requested
    sub-transactions to be completed. It can also provide clarity for a request.
    For example, a Mobility-Context could have
    the Home Network Prefix absent but it is unclear if the Client would
    like the address to be assigned by the Agent or if this is an error.
    Rather than creating a specific command for assigning the IP a bit
    position in a COMMAND_SET is reserved for Agent based IP assignment.</t>
    </section>
    <section anchor="refscope" title="Reference Scope">
    <t> The Reference Scope is an optional feature that provides the scope of
    references used in a configuration command, i.e. CONFIG or
    CONF_BUNDLE. These scopes are defined as
    <list style="symbols">
    <t> none - All entities have no references to other entities.</t>
        <t> op - All references are contained in the operation body, i.e. only
        intra-operation references exist.</t>
        <t> bundle - All references exist in bundle
        (inter-operation/intra-bundle). NOTE - If this value is present in
        a CONFIG message it is equivalent to 'op'.</t>
        <t> storage - One or more references exist outside of the operation
        and bundle. A lookup to cache / storage is required.</t>
        <t> unknown - the location of the references are unknown. This is
        treated as a 'storage' type.</t>
    </list></t>
    <t> An agent that only accepts 'op' or 'bundle' reference scope messages
    is referred to as 'stateless' as it has no direct memory of references
    outside messages themselves. This permits low memory footprint Agents.
    Even when an Agent supports all message types an 'op' or 'bundle'
    scoped message can be processed quickly by the Agent as it does not
    require storage access. </t>
    </section>
    <section anchor="response" title="Operation Response">
      <section anchor="immediateresp" title="Immediate Response">
    <t>For CONF and CONF_BUNDLE the Response MAY include the the following:
      <list>
      <t> NOTIFY_FOLLOWS - A boolean indicator that the Operation has been accepted by the Agent
      but further processing is required. A CONFIG_RESULT_NOTIFY will be
      sent once the processing has succeeded or failed.</t>
      <t>ENTITIES - Optionally, entities created or partially fulfilled as part of 
      the operation as specified in <xref target="op_respbody"/> For Clients that need 
      attributes back quickly for call processing, the AGENT MUST respond back with an
      OK_NOTIFY_FOLLOWS and minimally the attributes assigned by the Agent
      in the response.  These situations MUST be determined through the use
      of Command Sets (see <xref target="commandsets"/>).</t>
      </list>
    </t>
    </section>

    <section anchor="asyncnotification" title="Asynchronous Notification">
    <t> A CONFIG_RESULT_NOTIFY occurs after the Agent has completed processing
    related to a CONFIG or CONF_BUNDLE request. It is an asynchronous
    communication from the Agent to the Client.</t>

    <t> The values of the CONFIG_RESULT_NOTIFY are detailed in
    <xref target="ayncnotify_detail"/>.</t>
    </section>
  </section>
</section>

<section anchor="monitor_descr" title="Monitors">
  <t>An Agent may reject a registration if it or the DPN has insufficient
      resources.</t>
  <t> An Agent or DPN may temporarily suspend monitoring if insufficient
      resources exist.  In such a case the Agent MUST notify the
      Client.</t>

	<t>When a monitor has a reporting configuration of SCHEDULED it
      is automatically de-registered after the last NOTIFY occurs. </t>
      
  <t> If a SCHEDULED or PERIODIC configuration is
      provided during registration with the time related value (time
      or period respectively) of 0 a NOTIFY is sent and
      the monitor is immediately de-registered. This method should, when a
      MONITOR has not been installed, result in an immediate NOTIFY sufficient
      for the Client's needs and lets the Agent realize the Client has
      no further need for the monitor to be registered. </t>

  <t> PROBE messages are also used by a Client to retrieve information about a
      previously installed monitor. The PROBE message SHOULD identify
      one or more monitors by means of including the associated
      monitor identifier. An Agent receiving a PROBE message
      sends the requested information in a single or multiple NOTIFY
      messages.</t>
      
<t>If the Monitor configuration associated with a NOTIFY is deterrable then 
the NOTIFY MAY be bundled with other messages back to the Agent even if this results
in a delay of the NOTIFY.</t>
  <section anchor="asyncmonitornotification" title="Asynchronous Notification">
    <t> A NOTIFY can be sent as part of de-registraiton, a trigger based upon a
    Monitor Configuration or a PROBE.   A NOTIFY is comprised of unique
    Notification Identifier from the Agent, the Monitor ID the notification
    applies to, the Trigger for the notification, a timestamp of when the
    notification's associated event occurs and data that is specific to
    the monitored value's type.</t>
  </section>
  </section>
</section>

<section anchor="protoperation" title="Protocol Operation">
  <section anchor="simple" title="Simple RPC Operation">
  <t> An FPC Client and Agent MUST identify themselves using the CLI_ID and
      AGT_ID respectively to ensure that for all transactions a recipient of
      an FPC message can unambiguously identify the sender of the FPC message.
<!--  All messages between an Agent and a Client must identify the Client and
      Agent using the CLI_ID and AGT_ID respectively.-->
      A Client MAY direct the Agent to enforce a rule in a particular DPN by
      including a DPN_ID value in a Context. Otherwise the Agent selects a
      suitable DPN to enforce a Context and notifies the Client about the
      selected DPN using the DPN_ID.</t>

  <t> All messages sent from a Client to an Agent MUST be acknowledged by the
      Agent. The response must include all entities as well as status
      information, which indicates the result of processing the message, using
      the RESPONSE_BODY property. In case the processing of the message results
      in a failure, the Agent sets the ERROR_TYPE and ERROR_TAG
      accordingly and MAY clear the entity, e.g. Context or Installed-Policy, which caused the failure,
      in the response.</t>

  <t> If based upon Agent configuration or the processing of the request
      possibly taking a significant amount of time the Agent MAY respond with
      a NOTIFY_FOLLOWS indicaiton with an optional RESPONSE_BODY containing the
      partially completed entities. When a NOTIFY_FOLLOWS indication is indicated, the
      Agent will, upon completion or failure of the operation, respond with
      an asynchronous CONFIG_RESULT_NOTIFY to the Client.</t>

  <t> A Client MAY add a property to a Context without providing all required
      details of the attribute's value. In such case the Agent SHOULD determine
      the missing details and provide the completed property description back
      to the Client. If the processing will take too long or based upon Agent
      configuration, the Agent MAY respond with an OK that indicates a NOTIFY_FOLLOWS and also
      includes a 
      RESPONSE_BODY containing the partially completed entities.</t>

  <t> In case the Agent cannot determine the missing value of an attribute's
      value per the Client's request, it leaves the attribute's value cleared
      in the RESPONSE_BODY and sets the RESULT to Error, ERROR_TYPE and
      ERROR_TAG. As example, the Control-Plane needs to setup a tunnel
      configuration in the Data-Plane but has to rely on the Agent to determine
      the tunnel endpoint which is associated with the DPN that supports the
      Context. The Client adds the tunnel property attribute to the FPC message
      and clears the value of the attribute (e.g. IP address of the local
      tunnel endpoint). The Agent determines the tunnel endpoint and includes
      the completed tunnel property in its response to the Client.</t>

  <t> <xref target="fig_msc_example"></xref> illustrates an exemplary session
      life-cycle based on Proxy Mobile IPv6 registration via MAG Control-Plane
      function 1 (MAG-C1) and handover to MAG Control-Plane function 2 (MAG-C2).
      Edge DPN1 represents the Proxy CoA after attachment, whereas Edge DPN2
      serves as Proxy CoA after handover. As exemplary architecture, the FPC
      Agent and the network control function are assumed to be co-located with
      the Anchor-DPN, e.g. a Router.  </t>
  <t>
  <figure anchor="fig_msc_example"
          title="Exemplary Message Sequence (focus on FPC reference point)">
        <artwork align="center"><![CDATA[
                                              +-------Router--------+
                        +-----------+         |+-------+ +---------+|
+------+ +------+     +-----+ FPC   |          | FPC   | |  Anchor |
|MAG-C1| |MAG-C2|     |LMA-C| Client|          | Agent | |   DPN   |
+------+ +------+     +-----+-------+          +-------+ +---------+
[MN attach]  |            |                          |           |
   |-------------PBU----->|                          |           |
   |         |            |---(1)--CONFIG(CREATE)--->|           |
   |         |            |   [ MOBILTY_CONTEXT_ID,  |--tun1 up->|
   |         |            | DPNREFLIST:[[DPN1, BOTH  |           |
   |         |            |  DPN_SETTINGS_COMPL:[    |           |
   |         |            |   DOWNLINK(QOS/TUN),     |           |
   |         |            |   UPLINK(QOS/TUN)] ]]    |--tc qos-->|
   |         |            |   CTXT_SETTINGS_COMPL:[  |           |
   |         |            |     IP_PREFIX(HNP) ] ]   |           |
   |         |            |<---(2)- OK --------------|-route add>|
   |         |            |                          |           |
   |<------------PBA------|                          |           |
   |         |            |                          |           |
   | +----+  |            |                          |           |
   | |Edge|  |            |                          |           |
   | |DPN1|  |            |                          |           |
   | +----+  |            |                          |           |
   |   |                                                         |
   |   |-=======================================================-|
   |                      |                          |           |
   |   [MN handover]      |                          |           |
   |         |---PBU ---->|                          |           |
   |         |            |--(3)- CONFIG(MODIFY)---->|           |
   |         |<--PBA------|    [ MOBILTY_CONTEXT_ID  |-tun1 mod->|
   |         |            | DPNREFLIST:[[DPN1, BOTH  |           |
   |         |            |    DPN_SETTINGS_COMPL:[  |           |
   |         |            |   DOWNLINK(TUN),         |           |
   |         |  +----+    |   UPLINK(TUN)] ]] ]      |           |
   |         |  |Edge|    |<---(4)- OK --------------|           |
   |         |  |DPN2|    |                          |           |
   |         |  +----+    |                          |           |
   |         |    |       |                          |           |
   |         |    |-============================================-|
   |         |            |                          |           |

      ]]></artwork>
        <postamble></postamble>
      </figure>
  </t>

  <t> After reception of the Proxy Binding Update (PBU) at the LMA
      Control-Plane function (LMA-C), the LMA-C selects a suitable DPN, which
      serves as Data-Plane anchor to the mobile node's (MN) traffic. The
      LMA-C adds a new logical Context to the DPN to treat the MN's
      traffic (1) and includes a Context Identifier (CONTEXT_ID) to the
      CONFIG command. The LMA-C identifies the selected Anchor DPN by
      including the associated DPN identifier and the Direction the entry applies to, BOTH.</t>

  <t> The LMA-C adds properties during the creation of the new Context. One
      property is added to the DPN Settings Complimentary, to specify the forwarding tunnel type and endpoints
      (Anchor DPN, Edge DPN1) in each direction (as required). Another
      property is added to specify the QoS differentiation, which the MN's
      traffic should experience. At reception of the Context, the FPC Agent
      utilizes local configuration commands to create the tunnel (tun1) as
      well as the traffic control (tc) to enable QoS differentiation. After
      configuration has been completed, the Agent applies a new route to
      forward all traffic destined to the MN's HNP specified as a property
      in the Context's Complementary Settings and applied the configured tunnel interface (tun1).</t>

  <t> During handover, the LMA-C receives an updating PBU from the handover
      target MAG-C2. The PBU refers to a new Data-Plane node (Edge DPN2) to
      represent the new tunnel endpoints in the downlink and uplink, as
      required.  The LMA-C sends a CONFIG message (3) to the Agent to
      modify the existing tunnel property of the existing Context and to update
      the tunnel endpoint from Edge DPN1 to Edge DPN2. Upon reception of the
      CONFIG message, the Agent applies updated tunnel property to the local
      configuration and responds to the Client (4).</t>

  <t>
    <figure anchor="fig_msc_delete_example"
            title="Exemplary Message Sequence (focus on FPC reference point)">
        <artwork align="center"><![CDATA[
                                              +-------Router--------+
                        +-----------+         |+-------+ +---------+|
+------+ +------+     +-----+ FPC   |          | FPC   | |  Anchor |
|MAG-C1| |MAG-C2|     |LMA-C| Client|          | Agent | |   DPN   |
+------+ +------+     +-----+-------+          +-------+ +---------+
[MN attach]  |            |                          |           |
   |-------------PBU----->|                          |           |
   |         |            |---(1)--CONFIG(MODIFY)--->|           |
   |<------------PBA------|   [ CONTEXT_ID,          |--tun1   ->|
   |         |            | DPNREFLIST:[[DPN1, BOTH |           |
   |         |            |    DPN_SETTINGS_COMPL:[  |           |
   |         |            |   DOWNLINK(TUN delete),  |    down   |
   |         |            | UPLINK(TUN delete)] ]] ] |           |
   |         |            |                          |           |
   |         |            |<-(2)- OK ----------------|           |
   |         |            |                          |           |
   |         |  [ MinDelayBeforeBCEDelete expires ]  |           |
   |         |            |                          |           |
   |         |            |---(3)--CONFIG(DELETE)--->|-- tun1 -->|
   |         |            |                          |  delete   |
   |         |            |<-(4)- OK ----------------|           |
   |         |            |                          |-- route ->|
   |         |            |                          |   remove  |
   |         |            |                          |           |
      ]]></artwork>
        <postamble></postamble>
      </figure>
  </t>

  <t> When a teardown of the session occurs, MAG-C1 will send a PBU with a
      lifetime value of zero.  The LMA-C sends a CONFIG message (1) to the
      Agent to modify the existing tunnel property of the existing Context to
      delete the tunnel information.) Upon reception of the CONFIG message,
      the Agent removes the tunnel configuration and responds to the Client (2).
      Per <xref target="RFC5213"/>, the PBA is sent back immediately after the
      PBA is received.</t>

  <t> If no valid PBA is received after the expiration of the
      MinDelayBeforeBCEDelete timer (see <xref target="RFC5213"/>),
      the LMA-C will send a CONFIG (3) message with a deletion request for
      the Context.  Upon reception of the message, the Agent deletes the tunnel
      and route on the DPN and responds to the Client (4).</t>

  <t> When a multi-DPN Agent is used the DPN list permits several DPNs to be
      provisioned in a single message for the single Conext.</t>
  <t>
    <figure anchor="fig_multidpn_example"
            title="Exemplary Message Sequence for Multi-DPN Agent">
        <artwork align="center"><![CDATA[

                        +-----------+           +-------+ +---------+
+------+ +------+     +-----+ FPC   |           | FPC   | |  Anchor |
|MAG-C1| |MAG-C2|     |LMA-C| Client|           | Agent | |   DPN1  |
+------+ +------+     +-----+-------+           +-------+ +---------+
[MN attach]  |            |                          |           |
   |-------------PBU----->|                          |           |
   |         |            |---(1)--CONFIG(CREATE)--->|           |
   |         |            |   [ MOBILTY_CONTEXT_ID,  |--tun1 up->|
   |         |            | DPNREFLIST:[[DPN1, BOTH  |           |
   |         |            |    DPN_SETTINGS_COMPL:[  |           |
   |         |            |   DOWNLINK(QOS/TUN),     |           |
   |         |            |   UPLINK(QOS/TUN) ] ],   |--tc qos-->|
   |         |            |    [DPN2, BOTH           |           |
   |         |            |    DPN_SETTINGS_COMPL:[  |           |
   |         |            |   DOWNLINK(QOS/TUN),     |           |
   |         |            |   UPLINK(QOS/TUN) ] ] ], |           |
   |         |            |   CTXT_SETTINGS_COMPL [  |           |
   |         |            |     IP_PREFIX(HNP) ] ]   |           |
   |         |            |<-(2)- OK_NOTIFY_FOLLOWS -|-route add>|
   |         |            |                          |           |
   |<------------PBA------|                          |           |
   |         |            |                          |           |
   | +----+               |                          |           |
   | |Edge|               |                          |           |
   | |DPN2|               |                          |           |
   | +----+               |                          |           |
   |   |<---------------------- tun1 up -------------|           |
   |   |<---------------------- tc qos --------------|           |
   |   |<---------------------- route add -----------|           |
   |   |                  |                          |           |
   |   |                  |<(3) CONFIG_RESULT_NOTIFY |           |
   |   |                  |   [ Response Data ]      |           |
   |   |                  |                          |           |
      ]]></artwork>
        <postamble></postamble>
      </figure>
  </t>
  <t> <xref target="fig_multidpn_example"/> shows how the first 2 messages in
      <xref target="fig_msc_example"/> are supported when a multi-DPN Agent
      communicates with both Anchor DPN1 and Edge DPN2.  In such a case, the
      FPC Client sends the downlink and uplink for both DPNs in the DPN Reference 
      List of the same Context. Message 1 shows the DPN Reference List with all entries.
      Each entry identifies the DPN and direction (one of 'uplink', 'downlink'
      or 'both').</t>

  <t> The Agent responds with an OK and NOTIFY_FOLLOWS indication while it simultaneoulsy
      provisions both DPNs. Upon successful completion, the Agent responds to
      the Client with a CONFIG_RESULT_NOTIFY indicating the operation status.
  </t>
  </section>

  <section anchor="policy_ex" title="Policy And Mobility on the Agent">

  <t> A Client may build Policy and Topology using any mechanism on the Agent.
      Such entities are not always required to be constructed in realtime and,
      therefore, there are no specific messages defined for them in this
      specification.</t>

  <t> The Client may add, modify or delete many Installed Policies and Contexts in a single
      FPC message. This includes linking Contexts to Actions and Descriptors,
      i.e. a Rule.  As example, a Rule which performs re-writing of an arriving
      packet's destination IP address from IP_A to IP_B matching an associated
      Descriptor, can be enforced in the Data-Plane via an Agent to implicitly
      consider matching arriving packet's source IP address against IP_B and
      re- write the source IP address to IP_A.
  </t>

  <t> <xref target="fig_port"/> illustrates the generic policy configuration
      model as used between a FPC Client and a FPC Agent.
  </t>

  <t>
     <figure anchor="fig_port" title="Structure of Policies and Vports">
        <artwork align="center"><![CDATA[

  Descriptor_1 -+          +- Action_1
                |          |
  Descriptor_2 -+--<Rule>--+- Action_2
                  +------+
                  /Order#/-------------+
                  +------+             |
                                       |
  Descriptor_3 -+          +- Action_3 +-<Policy>
                |          |           |  ^
  Descriptor_4 -+--<Rule>--+- Action_4 |  |
                  +------+             |  |
                  /Order#/-------------+  |
                  +------+                |
                                         <Intsalled-Policy>

  +-------------------+     +---------------------+
  | Bind 1..M traffic |     |  Bind 1..N traffic  |
  |  Descriptors to   | --> |  treatment actions  |
  |  to a Policy and  |     |   to a Policy and   |
  |  Installed-Policy |     |  Installed-Policy |
  +-------------------+     +---------------------+

 |                                                 |
 +-------------- Data-Plane Rule ------------------+
        ]]></artwork>
        <postamble></postamble>
      </figure>
  </t>

  <t>
   As depicted in <xref target="fig_port"/>, the Installed-Policy represents the anchor
   of Rules through the Policy / Rule hierarchy.  A Client and Agent use the identifier of the
   associated Policy to directly access the Rule and perform modifications of
   traffic Descriptors or Action references.  A Client and Agent use the
   identifiers to access the Descriptors or Actions to perform modifications.
   From the viewpoint of packet processing, arriving packets are matched
   against traffic Descriptors and processed according to the treatment
   Actions specified in the list of properties associated with the Installed-Policy.
  </t>
  <t>
   A Client complements a rule's Descriptors with a Rule's Order (priority)
   value to allow unambiguous traffic matching on the Data-Plane.
  </t>
  <t><xref target="fig_context"/> illustrates the generic context configuration
   model as used between a FPC Client and a FPC Agent.
  </t>

  <t>
      <figure anchor="fig_context" title="Structure of Contexts">
        <artwork align="center"><![CDATA[

  TrafficSelector_1
           |
  profile-parameters
           |
  mobility-profile-- dl ------+
                     ^        |
                     |      qos-profile
                <ContextID1>       |
                     ^        per-mn-agg-max-dl_2
                     |
                <ContextID2>

  +-------------------+     +---------------------+
  | Bind 1..M traffic |     |  Bind 1..N traffic  |
  |    selectors to   | --> |  treatment / qos    |
  |     a Context     |     |  actions to a       |
  |                   |     |       Context       |
  +-------------------+     +---------------------+

 |                                                 |
 +-------------- Data-Plane Rule ------------------+
        ]]></artwork>
        <postamble></postamble>
      </figure>
  </t>
  <t> As depicted in <xref target="fig_context"/>, the Context represents a
      mobility session hierarchy.  A Client and Agent directly assigns values
      such as downlink traffic descriptors, QoS information, etc.  A Client and
      Agent use the context identifiers to access the descriptors, qos
      information, etc. to perform modifications.  From the viewpoint of packet
      processing, arriving packets are matched against traffic Descriptors and
      processed according to the qos or other mobility profile related Actions
      specified in the Context's properties. If present, the final action is
      to use a Context's tunnel information to encapsulate and forward the
      packet.  </t>

  <t> A second Context also references context1 in the figure.  Based upon the
      technology a property in a parent context (parent mobility-context-id reference) MAY be inherited by its
      descendants.  This permits concise over the wire representation.  When a
      Client deletes a parent Context all children are also deleted.</t>
  </section>

  <section anchor="optimization"
           title="Optimization for Current and Subsequent Messages">
  <section anchor="bundelexample" title="Configuration Bundles">
    <t> Bundles provide transaction boundaries around work in a single
    message.  Operations in a bundle MUST be successfully executed in the
    order specified.  This allows references created in one operation to be
        used in a subsequent operation in the bundle. </t>
    <t> The example bundle shows in Operation 1 (OP 1) the creation of a
    Context 1 which is then referenced in Operation 2 (OP 2) by CONTEXT_ID
    2.  If OP 1 fails then OP 2 will not be executed.  The advantage of the
        CONF_BUNDLE is preservation of dependency orders in a single
    message as opposed to sending multiple CONFIG messages and awaiting
    results from the Agent.</t>
    <t> When a CONF_BUNDLE fails, any entities provisioned in the
    CURRENT operation are removed, however, any successful operations
    completed prior to the current operation are preserved in order to
    reduce system load.</t>
    <t>
      <figure anchor="fig_bundle_example"
              title="Exemplary Bundle Message (focus on FPC reference point)">
        <artwork align="center"><![CDATA[
                        +-------Router--------+
+-----------+           |+-------+ +---------+|
|   FPC     |            | FPC   | |  Anchor |
|  Client   |            | Agent | |   DPN   |
+-----------+            +-------+ +---------+
     |                          |           |
     |--CONF_BUNDLE(CREATE)---->|           |
     | [ OP 1,                  |           |
     |   [ MOBILTY_CONTEXT_ID 1,  |--tun1 up->|
     | DPNREFLIST:[[DPN1, BOTH  |           |
     |  DPN_SETTINGS_COMPL:[    |           |
     |   DOWNLINK(QOS/TUN),     |           |
     |   UPLINK(QOS/TUN)] ]]    |--tc qos-->|
     |   CTXT_SETTINGS_COMPL:[  |           |
     |     IP_PREFIX(HNP) ] ] ],|           |
     | [ OP 2,                  |           |
     |   [ MOBILTY_CONTEXT_ID,  |--tun1 up->|
     | DPNREFLIST:[[DPN1, BOTH  |           |
     |  DPN_SETTINGS_COMPL:[    |           |
     |   DOWNLINK(QOS/TUN),     |           |
     |   UPLINK(QOS/TUN)] ]]    |--tc qos-->|
     | PARENT_CONTEXT_ID_REF=1  |           |
     |  ] ]                     |           |
     |                          |           |
      ]]></artwork>
        <postamble></postamble>
      </figure>
    </t>
    </section>
    <section anchor="commandsetexample" title="Command Bitsets (Optional)">
    <t> Command Sets permit the ability to provide a single, unified data
    structure, e.g. Mobility-Context, and specify which activities are expected to
    be performed on the DPN.  This has some advantages
        <list style="symbols">
        <t> Rather than sending N messages with a single operation performed
        on the DPN a single message can be used with a Command Set that
        specifies the N DPN operations to be executed.</t>
        <t> Errors become more obvious.  For example, if the HNP is NOT
        provided but the Client did not specify that the HNP should be
        assigned by the Agent this error is easily detected.  Without the
        Command Set the default behavior of the Agent would be to assign
        the HNP and then respond back to the Client where the error would
        be detected and subsequent messaging would be required to remedy
        the error. Such situations can increase the time to error detection
        and overall system load without the Command Set present.</t>
        <t> Unambiguous provisioning specification.  The Agent is exactly in
        sync with the expectations of the Client as opposed to guessing
        what DPN work could be done based upon data present at the Agent.
        This greatly increases the speed by which the Agent can complete
        work.</t>
        <t> Permits different technologies with different instructions to be
        supported in FPC.</t>
        </list>
        </t>
    <t> As Command Bitsets are technology specific, e.g. PMIP or 3GPP Mobility,
    the type of work varies on the DPN and the amount of data present in a
    Context or Port will vary.  Using the technology specific instructions
    allows the Client to serve multiple technologies and MAY result in a
    more stateless Client as the instructions are transferred the Agent
    which will match the desired, technology specific instructions with
    the capabilities and over the wire protocol of the DPN more
    efficiently.</t>
    </section>

    <section anchor="referenceexample" title="Reference Scope(Optional)">
    <t> Although entities MAY refer to any other entity of an appropriate
    type, e.g. Contexts can refer to Policies or other Contexts, the Reference
    Scope gives the Agent an idea of where those references reside.  They
    may be in the same operation, an operation in the same CONF_BUNDLE
    message or in storage.  There may also be no references.  This permits
    the Agent to understand when it can stop searching for reference it
    cannot find.  For example, if a CONF_BUNDLE message uses a
    Reference Scope of type 'op' then it merely needs to keep an operation
    level cache and consume no memory or resources searching across the many
        operations in the CONF_BUNDLE message or the data store.</t>
    <t> Agents can also be stateless by only supporting the 'none', 'op' and
    'bundle' reference scopes.   This does not imply they lack storage but
    merely the search space they use when looking up references for an
    entity. The figure below shows the caching hierarchy provided by the
    Reference Scope</t>
    <t> Caches are temporarily created at each level and as the scope includes
    more caches the amount of entities that are searched increases.
    <xref target="fig_cache_example"/> shows an example containment hierarchy
      provided for all caches.</t>
    <t>
        <figure anchor="fig_cache_example"
              title="Exemplary Hierarchical Cache">
        <artwork align="center"><![CDATA[
                       +---------------+
                       | Global Cache  |
                       |  (storage)    |
                       +------+--------+
                              |
                              +----------------------+
                              |                      |
                       +------+--------+      +------+--------+
                       | Bundle Cache  |      | Bundle Cache  |
                       |   (bundle)    | .... |   (bundle)    |
                       +------+--------+      +------+--------+
                              |
         +--------------------+--------------------+
         |                    |                    |
+--------+---------+ +--------+---------+ +--------+---------+
| Operation Cache  | | Operation Cache  | | Operation Cache  |
|       (op)       | |       (op)       | |       (op)       |
+------------------+ +------------------+ +------------------+

                          (no cache)
      ]]></artwork>
        <postamble></postamble>
      </figure>
    </t>
    </section>

      <section anchor="registry" title="Basename Registry Feature (Optional)">
      <t> The Optional BaseName Registry support feature is provided to permit
      Clients and tenants with common scopes, referred to in this
      specification as BaseNames, to track the state of provisioned policy
      information on an Agent. The registry records the BaseName and
      Checkpoint set by a Client. If a new Client attaches to the Agent
      it can query the Registry to determine the amount of work that must
      be executed to configure the Agent to a BaseName / checkpoint
      revision. A State value is also provided in the registry to help
      Clients coordinate work on common BaseNames.</t>
      </section>
    </section>
  </section>
</section>

<section anchor="proto_message_detail" title="Protocol Message Details">
<section anchor="datastructure" title="Data Structures And Type Assignment">
<t>This section provides a type mapping for FPC structures.  When being mapped to a specific
information such as YANG the data type MAY change.</t>
<section anchor="policystructs" title="Policy Structures">
  <texttable anchor="policy-structs" title="Action Fields">
    <ttcol align="left">Structure</ttcol>
    <ttcol align="left">Field</ttcol>
    <ttcol align="left">Type</ttcol>
    <!-- Actions -->
      <c>ACTION</c>
      <c>ACTION_ID </c>
      <c>FPC-Identity (<xref target="naming"/>)</c>

      <c>ACTION</c>
      <c>ACTION_TYPE</c>
      <c>[32, unsigned integer]</c>

      <c>ACTION</c>
      <c>ACTION_VALUE</c>
      <c>Type specific</c>

      <c>DESCRIPTOR</c>
      <c>DESCRIPTOR_ID </c>
      <c>FPC-Identity (<xref target="naming"/>)</c>

      <c>DESCRIPTOR</c>
      <c>DESCRIPTOR_TYPE</c>
      <c>[32, unsigned integer]</c>

      <c>DESCRIPTOR</c>
      <c>DESCRIPTOR_VALUE</c>
      <c>Type specific</c>

    <!-- Policies -->
      <c>POLICY</c>
      <c>POLICY_ID</c>
      <c>FPC-Identity (<xref target="naming"/>)</c>

      <c>POLICY</c>
      <c>RULES</c>
      <c>*[ PRECEDENCE RULE_ID ] PRECENDENCE is [32, unsigned integer].  For Rule see <xref target="rule_field"/></c>
  </texttable>
	
  <t> Policies contain a list of Rules by their order value. Each Rule contains
      Descriptors with optional directionality and Actions with order values
      that specifies action execution ordering if the Rule has multiple
      actions.</t>

  <t> Rules consist of the following fields.</t>
  <texttable anchor="rule_field" title="Rule Fields">
    <ttcol align="left">Field</ttcol>
    <ttcol align="left">Type</ttcol>
    <ttcol align="left">Sub-Fields</ttcol>
      <c>RULE_ID</c>
      <c>FPC-Identity (<xref target="naming"/>)</c>
      <c></c>
      
      <c>MATCH_TYPE</c>
      <c>ENUMERATION [2, unsigned bits]  
     ('AND' or 'OR')</c>
      <c></c>

      <c>RULE_DESCRIPTORS</c>
      <c>*[ DESCRIPTOR_ID DIRECTION ]</c>
      <c>DIRECTION [2, unsigned bits] is an ENUMERATION
     (uplink, downlink or both).</c>
      <c>RULE_ACTIONS</c>
      <c>*[ ACTION_ID ACTION_ORDER ]</c>
      <c>ACTION-ORDER [8, unsigned integer] specifies action execution order.</c>
  </texttable>
</section>

<section anchor="mobilitystructs" title="Mobility Structures">
  <texttable anchor="port_field" title="Installed-Policy Fields">
    <ttcol align="left">Field</ttcol>
    <ttcol align="left">Type</ttcol>
      <c>DPN_ID</c>
      <c>FPC-Identity (<xref target="naming"/>)</c>
    
    
      <c>1*[ INSTALLED_POLICY_ID POLICY_ID_REFERENCE POLICY_SETTINGS ] DPN_POLICY_SETTINGS</c>
      <c></c>
    
      <c>INSTALLED_POLICY_ID</c>
      <c>FPC-Identity (<xref target="naming"/>)</c>
      
      <c>POLICY_ID_REFERENCE</c>
      <c>POLICY_ID</c>
      
      <c>POLICY_SETTINGS</c>
      <c>A collection of policy specific setings (properties)</c>
      
      <c>DPN_POLICY_SETTINGS</c>
      <c>A collection of setings (properties) that affect multiple installed policies.</c>
  </texttable>
  <texttable anchor="context_fields" title="Mobility Context Fields" >
    <ttcol align="left">Field</ttcol>
    <ttcol align="left">Type</ttcol>
      <c>MOBILITY_CONTEXT_ID</c>
      <c>FPC-Identity (<xref target="naming"/>)</c>

      <c>DPN_GROUP_ID_REFERENCE</c>
      <c>FPC-Identity (<xref target="naming"/>)</c>

      <c>PARENT_MOBILITY_CONTEXT_ID_REFERNCE</c>
      <c>FPC-Identity (<xref target="naming"/>)</c>

      <c>DPNS [NOTE 2]</c>
      <c>*[  DPN_REFERENCE ]</c>

      <c>REQUEST_POLICY_REFERENCES</c>
      <c>* [ POLICY_ID ]</c>

      <c>CONTEXT_SETTINGS_COMPLEMENTARY</c>
      <c> A Collection of Settings (properties).</c>
  </texttable>

  <texttable anchor="dpn_ref_fields" title="DPN_REFERENCE Fields" >
    <ttcol align="left">Field</ttcol>
    <ttcol align="left">Type</ttcol>
      <c>DPN_ID</c>
      <c>FPC-Identity (<xref target="naming"/>)</c>

      <c>DIRECTION</c>
      <c>See <xref target="rule_field"/></c>

      <c>INTERFACE_ID_REF</c>
      <c>FPC-Identity (<xref target="naming"/>)</c>
      
      <c>EMBEDDED_RULES</c>
      <c>*[ EMBEDDED_RULE ]</c>

      <c>DPN_SETTINGS_COMPLEMENTARY</c>
      <c> A Collection of Settings (properties).</c>
      
      <c>ASSIGNED_POLICY_REFERENCES</c>
      <c>* [ POLICY_ID ]</c>
  </texttable>
  <texttable anchor="embedded_rule_fields" title="EMBEDDED_RULE Fields" >
    <ttcol align="left">Field</ttcol>
    <ttcol align="left">Type</ttcol>
      <c>RULE_ID</c>
      <c>FPC-Identity (<xref target="naming"/>)</c>

      <c>MATCH_TYPE</c>
      <c>See <xref target="rule_field"/></c>

      <c>PRECEDENCE</c>
      <c>See <xref target="policy-structs"/></c>
      
      <c>ACTION_DEFINITION_SET</c>
      <c>*[ ACTION_ORDER ACTION_ID ACTION_TYPE ACTION_VALUE ]</c>

      <c>DESCRIPTOR_DEFINITION_SET</c>
      <c> *[ DESCRIPTOR_ID DESCRIPTOR_TYPE DESCRIPTOR_VALUE ]</c>
  </texttable>

  <section anchor="mess_notifications" title="Monitors">
  <texttable anchor="monitor_structs" title="Monitor Structures and Attributes">
      <ttcol align="left">Field</ttcol>
      <ttcol align="left">Type</ttcol>
      <ttcol align="left">Description</ttcol>

      <c>MONITOR</c>
      <c>MONITOR_ID DETERRABLE TARGET BINDING_INFORMATION [REPORT_CONFIG]</c>
      <c></c>
      
      <c>DETERRABLE</c>
      <c>boolean</c>
      <c>Deterrability indicator.</c>
      
      <c>BINDING_INFORMATION</c>
      <c>String</c>
      <c></c>

      <c>MONITOR_ID</c>
      <c>FPC-Identity. See <xref target="naming"/></c>
      <c></c>

      <c>EVENT_TYPE_ID</c>
      <c>[8, Event Type ID]</c>
      <c>Event Type (unsigned integer).</c>

      <c>TARGET</c>
      <c>OCTET STRING (See <xref target="monitor_overview"/>)</c>
      <c></c>

      <c>REPORT_CONFIG</c>
      <c>[8, REPORT-TYPE] [TYPE_SPECIFIC_INFO]</c>
      <c></c>

      <c>PERIODIC_CONFIG</c>
      <c>[32, period]</c>
      <c>report interval (ms).</c>

      <c>THRESHOLD_CONFIG</c>
      <c>[32, low] [32, hi]</c>
      <c>thresholds (at least one value must be present)</c>

      <c>SCHEDULED_CONFIG</c>
      <c>[32, time]</c>
      <c></c>

      <c>EVENTS_CONFIG</c>
      <c>*[EVENT_TYPE_ID]</c>
      <c></c>
    </texttable>
    <t>TRIGGERS include but are not limited to the following values:
      <list style="symbols">
        <t>Events specified in the Event List of an EVENTS CONFIG</t>
        <t>LOW_THRESHOLD_CROSSED</t>
        <t>HIGH_THRESHOLD_CROSSED</t>
        <t>PERIODIC_REPORT</t>
        <t>SCHEDULED_REPORT</t>
        <t>PROBED</t>
        <t>DEREG_FINAL_VALUE</t>
      </list>
    </t>
  </section>
 </section>

 <section anchor="mess_attributes" title="Message Attributes">
  <section anchor="op-header" title="Header">
    <t>Each operation contains a header with the following fields:</t>
    <texttable anchor="op-header-tables" title="Message Header Fields">
    <ttcol align="left">Field</ttcol>
    <ttcol align="left">Type</ttcol>
    <ttcol align="left">Messages</ttcol>

    <c>CLIENT_ID</c>
    <c>FPC-Identity (<xref target="naming"/>)</c>
    <c>All</c>

    <c>DELAY</c>
    <c>[32, unsigned integer]</c>
    <c>All</c>

    <c>OP_ID</c>
    <c>[64, unsigned integer]</c>
    <c>All</c>
    
    <c>OP_REF_SCOPE</c>
    <c>[4, ENUMERATION]</c>
    <c>Values are none(0), op(1), bundle(2), storage(3) or unknown(4)</c>

    </texttable>
  </section>

  <section anchor="op-body"
       title="CONFIG and CONF_BUNDLE Attributes and Notifications">
    <texttable anchor="op_input" title="CONFIG and CONF_BUNDLE OP_BODY Fields">
      <ttcol align="left">Field</ttcol>
      <ttcol align="left">Type</ttcol>
      <ttcol align="left">Operation Types Create(C), Update(U),
              Query(Q) and Delete(D)</ttcol>

    <c>OP_TYPE</c>
    <c>[8, op type]</c>
    <c>CONFIG and CONF_BUNDLE</c>
    
      <c>COMMAND_SET</c>
      <c>FPC Command Bitset. See <xref target="commandsets"/>.</c>
      <c>C,U</c>

      <c>INSTALLED_POLICIES</c>
      <c>*[ INSTALLED_POLICY ]</c>
      <c>C,U</c>

      <c>MOBILITY-CONTEXTS</c>
      <c>*[ MOBILITY-CONTEXT [ COMMAND_SET [NOTE 1] ] ]</c>
      <c>C,U</c>

      <c>TARGETS</c>
      <c>FPC-Identity (<xref target="naming"/>) *[DPN_ID]</c>
      <c>Q,D</c>

      <c>POLICIES</c>
      <c>*[ POLICY ]</c>
      <c>C,U</c>
      
      <c>RULES</c>
      <c>*[ RULE ]</c>
      <c>C,U</c>

      <c>DESCRIPTORS</c>
      <c>*[ DESCRIPTOR ]</c>
      <c>C,U</c>

      <c>ACTIONS</c>
      <c>*[ ACTION ]</c>
      <c>C,U </c>
    </texttable>

    <texttable anchor="op_respbody"
           title="Immediate Response RESPONSE_BODY Fields">
      <ttcol align="left">Field</ttcol>
      <ttcol align="left">Type</ttcol>
      <ttcol align="left">Operation Types Create(C), Update(U),
              Query(Q) and Delete(D)</ttcol>

    <c>OP_ID</c>
    <c>[64, unsigned integer]</c>
    <c>All</c>
    
        <c>STATUS</c>
    <c>[1, Enumerated]</c>
    <c>OK(0) or Error(1)</c>
    
        <c>NOTIFY_FOLLOWS</c>
    <c>boolean</c>
    <c></c>

      <c>POLICIES</c>
      <c>*[ POLICY ]</c>
      <c>C,U</c>
      
      <c>RULES</c>
      <c>*[ RULE ]</c>
      <c>C,U</c>

      <c>DESCRIPTORS</c>
      <c>*[ DESCRIPTOR ]</c>
      <c>C,U</c>

      <c>ACTIONS</c>
      <c>*[ ACTION ]</c>
      <c>C,U </c>

      <c>INSTALLED_POLICIES</c>
      <c>*[ INSTALLED_POLICY ]</c>
      <c>C,U [NOTE 1]</c>

      <c>CONTEXTS</c>
      <c>*[ CONTEXT [ COMMAND_SET [NOTE 1] ] ]</c>
      <c>C,U [NOTE 1]</c>

      <c>TARGETS</c>
      <c>*[ FPC-Identity (<xref target="naming"/>) ]</c>
      <c>Q,D [NOTE 1]</c>

      <c>ERROR_TYPE_ID</c>
      <c>[32, unsigned integer]</c>
      <c>All [NOTE 2]</c>

      <c>ERROR_TAG</c>
      <c>[1024, octet string]</c>
      <c>All [NOTE 2, 3]</c>
    </texttable>
    <t>Notes:
      <list>
        <t> NOTE 1 - Present in OK and OK with NOTIFY_FOLLOWS for both CONFIG and
        CONF_BUNDLE. MAY also be present in an CONF_BUNDLE Error response
        (ERR) if one of the operations completed successfully.</t>
        <t> NOTE 2 - Present only for Error (ERR) responses.</t>
        <t> NOTE 3 - Other Error Info (Strings) MAY also be present.</t>
        </list>
    </t>

    <texttable anchor="ayncnotify_detail"
           title="CONFIG_RESULT_NOTIFY Asynchronous Notification Fields">
      <ttcol align="left">Field</ttcol>
      <ttcol align="left">Type</ttcol>
      <ttcol align="left">Description</ttcol>
      <c>AGENT_ID </c>
      <c>FPC-Identity (<xref target="naming"/>)</c>
      <c></c>

    <c>OP_ID</c>
    <c>[64, unsigned integer]</c>
    <c>All</c>
    
        <c>STATUS</c>
    <c>[1, Enumerated]</c>
    <c>OK(0) or Error(1)</c>

      <c>NOTIFICATION_ID </c>
      <c>[32, unsigned integer]</c>
      <c>A Notification Identifier used to determine notification order.</c>

      <c>TIMESTAMP</c>
      <c>[32, unsigned integer]</c>
      <c>The time that the notification occurred.</c>

      <c>DATA</c>
      <c>*[ [OP_ID (if CONF_BUNDLE) ] RESPONSE_BODY (<xref target="op_respbody"/>) ]</c>
      <c></c>
    </texttable>
  </section>

  <section anchor="mon_notifications" title="Monitors">
    <texttable anchor="notify_structs" title="Monitor Notifications">
      <ttcol align="left">Field</ttcol>
      <ttcol align="left">Type</ttcol>
      <ttcol align="left">Description</ttcol>

      <c>NOTIFICATION_ID</c>
      <c>[32, unsiged integer]</c>
      <c></c>

      <c>TIMESTAMP</c>
      <c>[32, unsigned integer]</c>
      <c></c>
      
      <c>CAUSE</c>
      <c>[32, unsigned integer]</c>
      <c></c>

      <c>NOTIFY</c>
      <c>MONITOR [NOTIFICATION_DATA]</c>
      <c>NOTIFICATION_DATA is the value of the monitored target if this is not ean error.</c>
    </texttable>
    </section>
  </section>
</section>
  
</section>

<section anchor="derived_attrs" title="Derived and Subtyped Attributes">
  <t>This section notes settings and derived attributes.</t>
  <texttable anchor="context_link_fields"
         title="Context Downlink/Uplink Field Definitions in Settings">
    <ttcol align="left">Field</ttcol>
    <ttcol align="left">Type</ttcol>
    <ttcol align="left">Detail</ttcol>
      <c>TUN_LOCAL_ADDRESS</c>
      <c>IP Address</c>
      <c>[NOTE 1]</c>

      <c>TUN_REMOTE_ADDRESS</c>
      <c>IP Address</c>
      <c>[NOTE 1]</c>

      <c>TUN_MTU</c>
      <c>[32, unsigned integer]</c>
      <c></c>

      <c>TUN_PAYLOAD_TYPE</c>
      <c>[2, bits]</c>
      <c>Enumeration: payload_ipv4(0), payload_ipv6(1) or payload_dual(2).</c>

      <c>TUN_TYPE</c>
      <c>[8, unsigned integer]</c>
      <c>Enumeration:  IP-in-IP(0), UDP(1), GRE(2) and GTP(3).</c>

      <c>TUN_IF</c>
      <c>[16, unsigned integer]</c>
      <c>Input interface index.</c>

      <c>MOBILITY_SPECIFIC_TUN_PARAMS</c>
      <c>[ IETF_PMIP_MOB_PROFILE |
           3GPP_MOB_PROFILE ]</c>
      <c>[NOTE 1]</c>

      <c>NEXTHOP</c>
      <c>[ IP Address | MAC Address | SPI | MPLS Label | SID | Interface Index ]
     (See <xref target="nexthop_subtypes"/>).</c>
      <c>[NOTE 1]</c>

      <c>QOS_PROFILE_PARAMS</c>
      <c>[ 3GPP_QOS | PMIP_QOS ]</c>
      <c>[NOTE 1]</c>

      <c>DPN_SPECIFIC_PARAMS</c>
      <c>[ TUN_IF or Varies]</c>
      <c>Specifies optional node specific parameters in need such as if-index,
     tunnel-if-number that must be unique in the DPN.</c>
      <postamble>
        NOTE 1 - These parameters are extensible.  The Types may be extended
    for Field value by future specifications or in the case of Vendor
    Specific Attributes by enterprises.
      </postamble>
  </texttable>
  <texttable anchor="descriptor_subtypes"
         title="Descriptor Subtypes" align="left">
    <ttcol align="left">Field</ttcol>
    <ttcol align="left">Type Value</ttcol>
    <ttcol align="left">Type</ttcol>
    <ttcol align="left">Description</ttcol>

    <c>TO_PREFIX</c>
    <c>0</c>
    <c>[IP Address] [ Prefix Len ]</c>
    <c>Aggregated or per-host destination IP address/prefix descriptor.</c>

    <c>FROM_PREFIX</c>
    <c>1</c>
    <c>[IP Address] [ Prefix Len ]</c>
    <c>Aggregated or per-host source IP address/prefix descriptor.</c>

    <c>TRAFFIC_SELECTOR</c>
    <c>2</c>
    <c>Format per specification <xref target="RFC6088"/>.</c>
    <c>Traffic Selector.</c>
  </texttable>

  <texttable anchor="action_subtypes" title="Action Subtypes" align="left">
    <ttcol align="left">Field</ttcol>
    <ttcol align="left">Type Value</ttcol>
    <ttcol align="left">Type</ttcol>
    <ttcol align="left">Description</ttcol>

    <c>DROP</c>
    <c>0</c>
    <c>Empty</c>
    <c>Drop the associated packets.</c>

    <c>REWRITE</c>
    <c>1</c>
    <c>[in_src_ip] [out_src_ip]
       [in_dst_ip] [out_dst_ip]
       [in_src_port] [out_src_port]
       [in_dst_port] [out_dst_port]</c>
    <c>Rewrite IP Address (NAT) or IP Address / Port (NAPT).</c>

    <c>COPY_FORWARD</c>
    <c>2</c>
    <c>FPC-Identity. See <xref target="naming"/>.</c>
    <c>Copy all packets and forward them to the provided identity.  The
       value of the identity MUST be a port or context.</c>
  </texttable>

  <texttable anchor="nexthop_subtypes" title="Next Hop Subtypes" align="left">
    <ttcol align="left">Field</ttcol>
    <ttcol align="left">Type Value</ttcol>
    <ttcol align="left">Type</ttcol>
    <ttcol align="left">Description</ttcol>

    <c>IP_ADDR</c>
    <c>0</c>
    <c>IP Address</c>
    <c>An IP Address.</c>

    <c>MAC_ADDR</c>
    <c>1</c>
    <c>MAC Address</c>
    <c>A MAC Address.</c>

    <c>SERVICE_PATH_ID</c>
    <c>2</c>
    <c>[24, unsigned integer]</c>
    <c>Service Path Identifier (SPI)</c>

    <c>MPLS_LABEL</c>
    <c>3</c>
    <c>[20, unsigned integer]</c>
    <c>MPLS Label</c>

    <c>NSH</c>
    <c>4</c>
    <c>[SERVICE_PATH_ID] [8, unsigned integer]</c>
    <c>Included NSH which is a SPI and Service Index (8 bits).</c>

    <c>INTERFACE_INDEX</c>
    <c>5</c>
    <c>[16, unsigned integer]</c>
    <c>Interface Index (an unsigned integer).</c>

    <c>SEGMENT_ID</c>
    <c>6</c>
    <c>[128, unsigned integer]</c>
    <c>Segement Identifier.</c>
    
    <c>MPLS_LABEL_STACK</c>
    <c>7</c>
    <c>1*[MPLS_LABEL]</c>
    <c>MPLS Label</c>
    
    <c>SRV6_STACK</c>
    <c>8</c>
    <c>1*[IPv6 ADDR or PREFIX]</c>
    <c>SRv6 Stack</c>
  </texttable>

  <texttable anchor="qos_subtypes" title="QoS Subtypes" align="left">
    <ttcol align="left">Field</ttcol>
    <ttcol align="left">Type Value</ttcol>
    <ttcol align="left">Type</ttcol>
    <ttcol align="left">Description</ttcol>

    <c>QOS</c>
    <c>0</c>
    <c>[qos index type] [index] [DSCP]</c>
    <c>Refers to a single index and DSCP to write to the packet.</c>

    <c>GBR</c>
    <c>1</c>
    <c>[32, unsigned integer]</c>
    <c>Guaranteed bit rate.</c>

    <c>MBR</c>
    <c>2</c>
    <c>[32, unsigned integer]</c>
    <c>Maximum bit rate.</c>

    <c>PMIP_QOS</c>
    <c>3</c>
    <c>Varies by Type</c>
    <c>A non-traffic selector PMIP QoS Attribute
    per <xref target="RFC7222"/></c>
  </texttable>

  <texttable anchor="tunnel_subtypes" title="Tunnel Subtypes" align="left">
    <ttcol align="left">Field</ttcol>
    <ttcol align="left">Type Value</ttcol>
    <ttcol align="left">Type</ttcol>
    <ttcol align="left">Description</ttcol>

    <c>IPIP_TUN</c>
    <c>0</c>
    <c></c>
    <c>IP in IP Configuration</c>

    <c>UDP_TUN</c>
    <c>1</c>
    <c>[src_port] [dst_port]</c>
    <c>UDP Tunnel - source and/or destination port</c>

    <c>GRE_TUN</c>
    <c>2</c>
    <c>[32, GRE Key]</c>
    <c>GRE Tunnel.</c>
  </texttable>

  <t>The following COMMAND_SET values are supported for IETF_PMIP.
    <list style="symbols">
      <t>assign-ip - Assign the IP Address for the mobile session.</t>
      <t>assign-dpn - Assign the Dataplane Node.</t>
      <t>session - Assign values for the Session Level.</t>
      <t>uplink - Command applies to uplink.</t>
      <t>downlink - Command applies to downlink.</t>
    </list>
  </t>

 <section anchor="thregpp" title="3GPP Specific Extenstions">
  <t> 3GPP support is optional and detailed in this section. The following
      acronyms are used:
   <list hangIndent="4" style="hanging">
    <t hangText="APN-AMBR:">Access Point Name Aggregate Maximum Bit Rate</t>
    <t hangText="ARP:">Allocation of Retention Priority </t>
    <t hangText="EBI:">EPS Bearer Identity </t>
    <t hangText="GBR:">Guaranteed Bit Rate</t>
    <t hangText="GTP:">GPRS (General Packet Radio Service)
            Tunneling Protocol</t>
    <t hangText="IMSI:">International Mobile Subscriber Identity</t>
    <t hangText="MBR:">Maximum Bit Rate</t>
    <t hangText="QCI:">QoS Class Identifier</t>
    <t hangText="TEID:">Tunnel Endpoint Identifier.</t>
    <t hangText="TFT:">Traffic Flow Template (TFT)</t>
    <t hangText="UE-AMBR:">User Equipment Aggregate Maximum Bit Rate </t>
   </list></t>
   <t>NOTE: GTP Sequence Number (SEQ_NUMBER) is used
        in failover and handover.</t>
  <texttable anchor="threegpp_attributes"
         title="3GPP Attributes and Structures">
    <ttcol align="left">Field</ttcol>
    <ttcol align="left">Type Value</ttcol>
    <ttcol align="left">Namespace / Entity Extended</ttcol>
    <ttcol align="left">Type</ttcol>

    <c>GTPV1</c>
    <c>3</c>
    <c>Tunnel Subtypes namespace.</c>
    <c>LOCAL_TEID REMOTE_TEID SEQ_NUMBER</c>

    <c>GTPV2</c>
    <c>4</c>
    <c>Tunnel Subtypes namespace.</c>
    <c>LOCAL_TEID REMOTE_TEID SEQ_NUMBER</c>

    <c>LOCAL_TEID</c>
    <c>N/A</c>
    <c>N/A</c>
    <c>[32, unisgned integer]</c>

    <c>REMOTE_TEID</c>
    <c>N/A</c>
    <c>N/A</c>
    <c>[32, unisgned integer]</c>

    <c>SEQ_NUMBER</c>
    <c>N/A</c>
    <c>N/A</c>
    <c>[32, unisgned integer]</c>

    <c>TFT</c>
    <c>3</c>
    <c>Descriptors Subtypes namespace.</c>
    <c>Format per TS 24.008 Section 10.5.6.12.</c>

    <c>IMSI</c>
    <c>N/A</c>
    <c>Context (new attribute)</c>
    <c>[64, unsigned integer]</c>

    <c>EBI</c>
    <c>N/A</c>
    <c>Context (new attribute)</c>
    <c>[4, unsigned integer]</c>

    <c>3GPP_QOS</c>
    <c>4</c>
    <c>QoS Subtypes namespace.</c>
    <c>[8, qci] [32, gbr] [32, mbr] [32, apn_ambr] [32, ue_ambr] ARP</c>

    <c>ARP</c>
    <c>N/A</c>
    <c>N/A</c>
    <c>See Allocation-Retention-Priority from <xref target="RFC7222"/></c>
  </texttable>

  <t>The following COMMAND_SET values are supported for 3GPP.
    <list style="symbols">
      <t> assign-ip - Assign the IP Address for the mobile session.</t>
      <t> assign-dpn - Assign the Dataplane Node.</t>
      <t> assign-fteid-ip - Assign the Fully Qualified TEID (F-TEID)
      LOCAL IP address.</t>
      <t> assign-fteid-teid - Assign the Fully Qualified TEID (F-TEID)
      LOCAL TEID.</t>
      <t> session - Assign values for the Session Level.  When this involves
      'assign-fteid-ip' and 'assign-fteid-teid' this implies the values are
      part of the default bearer.</t>
      <t> uplink - Command applies to uplink.</t>
      <t> downlink - Command applies to downlink.</t>
    </list>
  </t>
 </section>
</section>
<section title="Implementation Status">
  <t> Three FPC Agent implementations have been made to date.  The first was
      based upon Version 03 of the draft and followed Model 1.  The second
      follows Version 04 of the document. Both implementations were
      OpenDaylight plug-ins developed in Java by Sprint.   Version 03 was
      known as fpcagent and version 04's implementation is simply referred to
      as 'fpc'.  A third has been devloped on an ONOS Controller for use in MCORD
      projects.</t>
  <t> fpcagent's intent was to provide a proof of concept for FPC Version 03
      Model 1 in January 2016 and research various errors, corrections and
      optimizations that the Agent could make when supporting multiple DPNs.</t>
  <t> As the code developed to support OpenFlow and a proprietary DPN from a
      3rd party, several of the advantages of a multi-DPN Agent became obvious
      including the use of machine learning to reduce the number of Flows and
      Policy entities placed on the DPN.  This work has driven new efforts in
      the DIME WG, namely Diameter Policy Groups
      <xref target="I-D.bertz-dime-policygroups"/>.</t>
  <t> A throughput performance of tens per second using various NetConf based
      solutions in OpenDaylight made fpcagent undesirable for call processing.
      The RPC implementation improved throughput by an order of magnitude but
      was not useful based upon FPC's Version 03 design using two information
      models.  During this time the features of version 04 and its converged
      model became attractive and the fpcagent project was closed in August
      2016. fpcagent will no longer be developed and will remain a proprietary
      implementation.</t>
  <t> The learnings of fpcagent has influenced the second project, fpc. Fpc is
      also an OpenDaylight project but is an open source release
      as the Opendaylight FpcAgent plugin
      (https://wiki.opendaylight.org/view/Project_Proposals:FpcAgent).
      This project is scoped to be a fully compliant FPC Agent that supports
      multiple DPNs including those that communicate via OpenFlow. The following
      features present in this draft and others developed by the FPC development
      team have already lead to an order of magnitude improvement.
      <list hangIndent="4" style="hanging">
      <t> Migration of non-realtime provisioning of entities such as topology
      and policy allowed the implementation to focus only on the rpc.</t>
      <t> Using only 5 messages and 2 notifications has also reduced
      implementation time.</t>
      <t> Command Sets, an optional feature in this specification, have
      eliminated 80% of the time spent determining what needs to be done
      with a Context during a Create or Update operation.</t>
      <t> Op Reference is an optional feature modeled after video delivery.
      It has reduced unnecessary cache lookups.  It also has the additional
      benefit of allowing an Agent to become cacheless and effectively act
          as a FPC protocol adapter remotely with multi-DPN support or
      colocated on the DPN in a single-DPN support model.</t>
      <t> Multi-tenant support allows for Cache searches to be partitioned for
      clustering and performance improvements. This has not been
      capitalized upon by the current implementation but is part of the
      development roadmap.</t>
      <t> Use of Contexts to pre-provision policy has also eliminated any
      processing of Ports for DPNs which permitted the code for CONFIGURE
      and CONF_BUNDLE to be implemented as a simple nested FOR loops
      (see below).</t>
      </list>
  </t>

  <t> Initial v04 performance results without code optimizations or tuning allow
      2-5K FPC Contexts processed per second on a 2013 Mac laptop.  This
      results in 2x the number of transactions on the southbound interface to
      a proprietary DPN API on the same machine.</t>
    <t> Current v04 performance results without code optimizations or tuning allow
      1-2K FPC Contexts processed per second on a 2013 Mac laptop.  This
      results in 2x the number of transactions on the southbound interface to
      a proprietary DPN API on the same machine.</t>
  <t> fpc currently supports the following:
      <list hangIndent="24" style="hanging">
      <t> 1 proprietary DPN API</t>
      <t> Policy and Topology as defined in this specification using
      OpenDaylight North Bound Interfaces such as NetConf and RestConf</t>
      <t> CONFIG and CONF_BUNDLE (all operations)</t>
      <t> DPN assignment, Tunnel allocations and IPv4 address assignment
      by the Agent or Client.</t>
      <t> Immediate Response is always an OK_NOTIFY_FOLLOWS.</t>
      </list> </t>

  <t>
        <figure anchor="pseudo_code"
              title="fpc pseudo code">
        <artwork align="center"><![CDATA[
assignment system (receives rpc call):
  perform basic operation integrity check
  if CONFIG then
    goto assignments
    if assignments was ok then
      send request to activation system
      respond back to client with assignment data
    else
      send back error
    end if
  else if CONF_BUNDLE then
    for each operation in bundles
    goto assignments
    if assignments was ok then
      hold onto data
    else
      return error with the assignments that occurred in
        prior operations (best effort)
    end if
    end for
    send bundles to activation systems
  end if

assignments:
  assign DPN, IPv4 Address and/or tunnel info as required
  if an error occurs undo all assignments in this operation
  return result

activation system:
  build cache according to op-ref and operation type
  for each operation
    for each Context
      for each DPN / direction in Context
        perform actions on DPN according to Command Set
      end for
    end for
  end for
  commit changes to in memory cache
  log transaction for tracking and notification
                                (CONFIG_RESULT_NOTIFY)
      ]]></artwork>
    </figure>
  </t>

  <t> For further information please contact Lyle Bertz who is also a
      co-author of this document.</t>

  <t> NOTE: Tenant support requires binding a Client ID to a Tenant ID
      (it is a one to many relation) but that is outside of the scope of this
      specification.  Otherwise, the specification is complete in terms
      of providing sufficient information to implement an Agent.</t>
</section>


<section title="Security Considerations">

  <t> Detailed protocol implementations for DMM Forwarding Policy Configuration
      must ensure integrity of the information exchanged between an FPC Client
      and an FPC Agent. Required Security Associations may be derived from
      co-located functions, which utilize the FPC Client and FPC Agent
      respectively.</t>

  <t> The YANG modules defined in this memo is designed to be accessed
      via the NETCONF <xref target="RFC6241"/> or RESTCONF <xref target="RFC8040"/> protocol.  The lowest NETCONF
      layer is the secure transport layer and the mandatory-to-implement
      secure transport is SSH <xref target="RFC6242"/>.</t>

  <t> The information model defined in the memo is designed to be access by
      protocols specified in extensions to this document or, if using the YANG
      modules, as described above.</t>

  <t> There are a number of data nodes defined which are
      writable/creatable/deletable.  These data nodes may be considered
      sensitive or vulnerable in some network environments.  Write operations
      (e.g., a NETCONF edit-config) to these data nodes without proper
      protection can have a negative effect on network operations.  These
      are the subtrees and data nodes and their sensitivity/vulnerability:
      <list>
      <t> Nodes under the Policy tree provide generic policy enforcement and
      traffic classification.  They can be used to block or permit traffic.
      If this portion of the model was to be compromised it may be used to
      block, identify or permit traffic that was not intended by the Tenant
      or FPC CLient.</t>
      <t> Nodes under the Topology tree provide defintion of the Tenant's
      forwarding topology.  Any compromise of this information will provide
      topology information that could be used for subsequent attack
      vectors.  Removal of topology can limit services.</t>
      <t> Nodes under the Mobility Tree are runtime only and manipulated by
      remote procedure calls.  The unwanted deletion or removal of such
      information would deny users service or provide services to
      unauthorized parties.</t>
      </list> </t>

  <t> Some of the readable data nodes defined may be considered sensitive or
      vulnerable in some network environments.  It is thus important to control
      read access (e.g., via get, get-config, or notification) to these data
      nodes.  These are the subtrees and data nodes and their
      sensitivity/vulnerability:
      <list>
      <t> IP address assignments in the Context along with their associated
          tunnel configurations/identifiers (from the FPC base module)</t>
      <t> Internaional Mobile Subscriber Identity (IMSI) and bearer identifiers
          in the Context when using the optional 3GPP module</t>
      </list></t>

  <t> Some of the RPC operations defined may be considered sensitive or
      vulnerable in some network environments.  It is thus important to
      control access to these operations.  These are the operations and their
      sensitivity/vulnerability:
      <list>
      <t> CONFIG and CONF_BUNDLE send Context information which can include
          information of a sensitive or vulnerable nature in some network
      environments as described above.</t>
      <t> Monitor related RPC operations do not specicially provide sensitive
      or vulnerable informaiton but care must be taken by users to avoid
      identifier values that expose sensitive or vulnerable information.</t>
      <t> Notications MUST be treated with same level of protection and
      scrutiny as the operations they correspond to.  For example, a
      CONFIG_RESULT_NOTIFY notification provides the same information that
      is sent as part of the input and output of the CONFIG and CONF_BUNDLE
      RPC operations.</t>
      </list> </t>

  <t> General usage of FPC MUST consider the following:
      <list>
      <t> FPC Naming <xref target="naming"/> permits arbirtrary string values
      but a users MUST avoid placing sensitive or vulnerable information
      in those values.</t>
      <t> Policies that are very narrow and permit the identification of
      specific traffic, e.g. that of a single user, SHOULD be avoided.</t>
      </list></t>
</section>

<section anchor="IANA" title="IANA Considerations">
  <t>This document registers six URIs in the "IETF XML Registry"
   <xref target="RFC3688"/>.  Following the format in RFC 3688, the following
   registrations have been made.</t>

  <t><figure><artwork>
   URI: urn:ietf:params:xml:ns:yang:ietf-dmm-fpc
   Registrant Contact: The DMM WG of the IETF.
   XML: N/A, the requested URI is an XML namespace.</artwork></figure></t>

  <t><figure><artwork>
   URI: urn:ietf:params:xml:ns:yang:ietf-dmm-pmip-qos
   Registrant Contact: The DMM WG of the IETF.
   XML: N/A, the requested URI is an XML namespace.</artwork></figure></t>

  <t><figure><artwork>
   URI: urn:ietf:params:xml:ns:yang:ietf-dmm-traffic-selector-types
   Registrant Contact: The DMM WG of the IETF.
   XML: N/A, the requested URI is an XML namespace.</artwork></figure></t>

  <t><figure><artwork>
   URI: urn:ietf:params:xml:ns:yang:ietf-dmm-fpc-settingsext
   Registrant Contact: The DMM WG of the IETF.
   XML: N/A, the requested URI is an XML namespace.</artwork></figure></t>

  <t>This document registers the following YANG modules in the "YANG
    Module Names" registry [RFC6020].</t>

  <t><figure><artwork>
  name:         ietf-dmm-fpc
  namespace:    urn:ietf:params:xml:ns:yang:ietf-dmm-fpc
  prefix:       fpc
  reference:    TBD1
  </artwork></figure></t>
  <t><figure><artwork>
  name:         ietf-dmm-pmip-qos
  namespace:    urn:ietf:params:xml:ns:yang:ietf-dmm-pmip-qos
  prefix:       qos-pmip
  reference:    TBD2
  </artwork></figure></t>
  <t><figure><artwork>
  name:         ietf-dmm-traffic-selector-types
  namespace:    urn:ietf:params:xml:ns:yang:
    ietf-dmm-traffic-selector-types
  prefix:       traffic-selectors
  reference:    TBD3
  </artwork></figure></t>
  <t><figure><artwork>
  name:         ietf-dmm-fpc-settingsext
  namespace:    urn:ietf:params:xml:ns:yang:ietf-dmm-fpc-settingsext
  prefix:       fpcbase
  reference:    TBD4
  </artwork></figure></t>
</section>

<section title="Work Team Participants">

  <t> Participants in the FPSM work team discussion include Satoru Matsushima,
      Danny Moses, Sri Gundavelli, Marco Liebsch, Pierrick Seite, Alper Yegin,
      Carlos Bernardos, Charles Perkins and Fred Templin.</t>

</section>


</middle>

  <back>
    <references title="Normative References">
    &rfc2119;
    &RFC7333;
    &RFC6088;
    &RFC6089;
    &RFC6991;
    &I-D.ietf-sfc-nsh;
    &I-D.ietf-6man-segment-routing-header;
    &I-D.ietf-spring-segment-routing-mpls;

    </references>

    <references title="Informative References">
    &I-D.ietf-dmm-deployment-models;
    &I-D.ietf-netconf-restconf;
    &I-D.bertz-dime-policygroups;
    &RFC5213;
    &RFC7222;
    &RFC6241;
    &RFC6242;
    &RFC3688;
    &RFC8040;

</references>

<!--

<reference anchor="3GPP-PCRFFR" target="http://www.3gpp.org">
        <front>
            <title>3GPP TS 29.816  3GPP TS 29.272 Study on PRCF Failure and Restoration</title>
            <author initials="" surname="" fullname="">
                <organization />
            </author>
        </front>
    </reference>

<reference anchor="3GPP-DIAM" target="http://www.3gpp.org">
        <front>
            <title>3GPP TS 29.272  Mobility Management Entity (MME) and Serving
          GPRS Support Node (SGSN) related interfaces based on Diameter protocol </title>
            <author initials="" surname="" fullname="">
                <organization />
            </author>
        </front>
    </reference>


    </references>
-->

<section anchor="yangmodel" title="YANG Data Model for the FPC protocol">


<t>These modules define YANG definitions. 

When mapping from the FPC model was performed U-Key values, ACTION_TYPES and DESCRIPTOR_TYPES as 
well as many enumerations were mapped to identity types.  

ACTION_TYPES and DESCRIPTOR_TYPES are also optional as the type can be inferred from the value.

Four modules are defined:</t>

<t><list style="symbols">
<t>ietf-dmm-fpc (fpc) - Defines the base model and messages for FPC that are meant to be static in FPC.</t>
<t>ietf-dmm-fpc-settingsext An FPC module that defines the information model elements that 
are likely to be extended in FPC.</t>

<t>ietf-pmip-qos (pmip-qos) - Defines proxy mobile IPv6 QoS parameters per RFC 7222</t>
<t>ietf-trafficselectors-types (traffic-selectors) - Defines Traffic Selectors per RFC 6088</t>

</list></t>

<!-- template for YANG model, start -->
  <section anchor="ietf-dmm-fpcagent" title="FPC YANG Model">
    <t>This module defines the information model and protocol elements specified in this document.</t>
    <t>This module references <xref target="RFC6991"/>, <xref target="RFC8040"/> and the fpc-settingsext module
      defined in this document.</t>
        <figure>
          <artwork><![CDATA[
<CODE BEGINS> file "ietf-dmm-fpc@2017-09-27.yang"
module ietf-dmm-fpc {
  yang-version 1.1;
    namespace "urn:ietf:params:xml:ns:yang:ietf-dmm-fpc";
    prefix fpc;

    import ietf-inet-types { prefix inet; 
        revision-date 2013-07-15; }
    import ietf-restconf { prefix restconf; 
        revision-date 2017-01-26; }
    import ietf-dmm-fpc-settingsext { prefix fpcbase; 
    revision-date 2017-09-27;
  }

    organization "IETF Distributed Mobility Management (DMM)
      Working Group";

    contact
       "WG Web:   <http://tools.ietf.org/wg/netmod/>
        WG List:  <mailto:netmod@ietf.org>

        WG Chair: Dapeng Liu
                  <mailto:maxpassion@gmail.com>

        WG Chair: Jouni Korhonen
                  <mailto:jouni.nospam@gmail.com>

        Editor:   Satoru Matsushima
                  <mailto:satoru.matsushima@g.softbank.co.jp>

        Editor:   Lyle Bertz
                  <mailto:lylebe551144@gmail.com>";

    description
    "This module contains YANG definition for
     Forwarding Policy Configuration Protocol (FPCP).

     Copyright (c) 2016 IETF Trust and the persons identified as the
     document authors. All rights reserved.

     This document is subject to BCP 78 and the IETF Trust's Legal
     Provisions Relating to IETF Documents
     (http://trustee.ietf.org/license-info) in effect on the date of
     publication of this document. Please review these documents
     carefully, as they describe your rights and restrictions with
     respect to this document. Code Components extracted from this
     document must include Simplified BSD License text as described
     in Section 4.e of the Trust Legal Provisions and are provided
     without warranty as described in the Simplified BSD License.";

    revision 2017-09-27 {
    description "Version 10 updates.";
    reference "draft-ietf-dmm-fpc-cpdp-10";
  }
revision 2017-07-22 {
    description "Version 08 updates.";
    reference "draft-ietf-dmm-fpc-cpdp-08";
}
revision 2017-03-08 {
    description "Version 06 updates.";
    reference "draft-ietf-dmm-fpc-cpdp-06";
}
revision 2016-08-03 {
    description "Initial Revision.";
    reference "draft-ietf-dmm-fpc-cpdp-05";
}
    feature fpc-basename-registry {
      description "Ability to track Base Names already provisioned
        on the Agent";
    }
    feature fpc-bundles {
      description "Ability for Client to send multiple bundles of
        actions to an Agent";
    }
    feature fpc-auto-binding {
      description "Allows a FPC Agent to advertise Topology Objects
        that could be DPNs";
    }
    feature operation-ref-scope {
      description "Provides the scope of refeneces in an operation.
        Used to optmize the Agent processing.";
    }
    
  //General Structures
    typedef fpc-identity {
        type union {
            type uint32;
            type string;
            type instance-identifier;
        }
        description "FPC Identity";
    }
    grouping target-value {
      leaf target {
          type fpc-identity;
      mandatory true;
      description "Target Identity";
      }
      description "FPC Target Value";
    }
  // Topology 
  typedef fpc-interface-id {
        type fpc:fpc-identity;
        description "DPN interface Identifier";
  }
    identity interface-protocols {
        description "Protocol supported by the interface";
    }
    identity features {
        description "Protocol features";
    }
  // Settings
  grouping settings {
    container settings-set {
      uses fpcbase:fpc-settings;
      description "Settings";
    }
    description "Settings container";
  }
  //Topology - Groupings
  grouping interface-settings {
    container interface-settings-set {
      description "Interface settings";
    }
    description "Generic interface settings container";
  }
  grouping access-technology-key {
    leaf access-technology {
      type identityref {
        base "fpcbase:access-technology";
      }
      mandatory true;
      description "Access Technology";
    }
    description "Access Technology key";
  }
  grouping role-key {
    leaf role {
      type identityref {
        base "fpcbase:role";
      }
      mandatory true;
      description "Access Technology Role";
    }
    description "Access Technology Role key";
  }
  grouping interface-id-key {
    leaf interface-id {
      type fpc:fpc-interface-id;
      mandatory true;
      description "interface identifier";
    }
    description "Interface Identifier key";
  }
  grouping dpn-identifier-key {
    leaf dpn-id {
      type fpc:fpc-identity;
      mandatory true;
      description "DPN Identifier Type";
    }
    description "DPN Identifier key";
  }
  grouping dpn-interface-reference {
    uses fpc:access-technology-key;
    uses fpc:role-key;
    uses fpc:interface-id-key;
    description "A reference to a DPN interface";
  }
  // Topology Grouping
  grouping fpc-topology {
    list dpn-set {
      key dpn-id;
      uses fpc:dpn-identifier-key;
      leaf dpn-name {
        type string;
        description "DPN name";
      }
      leaf dpn-resource-mapping-reference {
        type string;
        description "Reference to underlying DPN resource(s)";
      }
      list interface-set {
        key "access-technology role interface-id";
        uses fpc:dpn-interface-reference;
        uses fpc:interface-settings;
        description "DPN interfaces";
      }
      description "Set of DPNs";
    }
    list dpn-type-set {
      key "access-technology role";  
      uses fpc:access-technology-key;
      leaf access-technology-name {
        type string;
        description "Access Technology Name";
      }
      uses fpc:role-key;
      leaf role-name {
        type string;
        description "Access Technology Role Name";
      }
      list interface-set {
        key interface-id;
        uses fpc:interface-id-key;
        leaf interface-name {
          type string;
          description "DPN-Type Interface Name";
        }
        leaf-list interface-protocol-set {
          type identityref {
            base "interface-protocols";
          }
          description "Supported protocols";
        }
        leaf-list feature-set {
          type identityref {
            base "interface-protocols";
          }
          description "Supported features";
        }
        uses fpc:interface-settings;
        description "A DPN interface types";
      }
      description "Set of DPN types";
    }
    list dpn-group-set {
      key "dpn-group-id";
      leaf dpn-group-id {
        type fpc:fpc-identity;
        mandatory true;
        description "DPN Group Identifier";
      }
      list referenced-dpns-set {
        key "access-technology role interface-id";
        uses fpc:dpn-interface-reference;
        leaf-list supporting-dpn-id-set {
          type fpc:fpc-identity;
          description "DPNs that suppport this group";
        }
        leaf-list dpn-group-peer-id-set {
          type fpc:fpc-identity;
          description "DPN Peer Groups reference";
        }
        description "A list of DPNs supporting a group 
          by DPN Type";
      }
      list dpn-group-peer-set {
        key remote-dpn-group-id;
        leaf remote-dpn-group-id {
          type fpc:fpc-identity;
          mandatory true;
          description "Remote DPN Group identifier";
        }
        uses fpc:interface-settings;
        description "Locally applied settings used for 
          the referenced DPN-Group (peer group).";
      }
      leaf domain-id {
        type fpc:fpc-identity;
        description "Domain Identiifer";
      }
      description "List of DPN groups";
    }
    list domain-set {
      key domain-id;
      leaf domain-id {
        type fpc:fpc-identity;
        mandatory true;
        description "Domain Identifier";
      }
      leaf domain-name {
        type string;
        description "Domain displayname";
      }
      leaf domain-reference {
        type string;
        description "Reference to domain resources";
      }
      description "List of Domains";
    }
    description "FPC Topology grouping";
  }
  // Policy Structures
    // Descriptor Structure
    identity fpc-descriptor-type {
        description "A traffic descriptor";
    }
    grouping descriptor-definition {
        leaf descriptor-id {
            type fpc:fpc-identity;
            mandatory true;
            description "Descriptor Id";
        }
        leaf descriptor-type {
            type identityref {
              base "fpc-descriptor-type";
            }
            description "Descriptor Type Value";
        }
    uses fpcbase:fpc-descriptor-value;
        description "FPC Descriptor Definition";
    }
    // Action Structure
    identity fpc-action-type {
        description "Action Type";
    }
    grouping action-definition {
        leaf action-id {
            type fpc:fpc-identity;
            description "Action Identifier";
        }
        leaf action-type {
            type identityref {
              base "fpc-action-type";
            }
            description "Action Type";
        }
        uses fpcbase:fpc-action-value;
        description "FPC Action Definition";
    }
    // Rule Structure
    typedef fpc-direction-type {
       type enumeration {
         enum uplink {
           description "uplink";
         }
         enum downlink {
           description "Downlink";
         }
         enum both {
           description "Both";
        }
       }
       description "FPC Direction";
    }
    grouping fpc-rule-id {
    leaf rule-id {
      type fpc:fpc-identity;
      mandatory true;
      description "Rule Identifier";
    }
    description "FPC Rule-Id key";
    }
    grouping match-type {
        leaf descriptor-match-type {
          type enumeration {
            enum or { 
              value 0;
              description "OR logic";
            }
            enum and {
              value 1;
              description "AND logic";
            }
          }
          mandatory true;
          description "Type of Match (OR or AND) applied to the 
            descriptor-reference-set.";
      }
        description "Map Type Grouping";
    }
    grouping fpc-action-order {
        leaf action-order {
            type uint32;
            mandatory true;
            description "Action Execution Order";
        }
        description "Action Order Leaf";
    }
    grouping rule-definition {
        uses fpc:fpc-rule-id;
    uses fpc:match-type;
        list descriptor-reference-set {
          key "descriptor-id-reference";
          leaf descriptor-id-reference {
              type fpc:fpc-identity;
              mandatory true;
              description "Descriptor Id Reference";
          }
          leaf direction {
              type fpc:fpc-direction-type;
              description "Direction";
          }
          description "A set of Descriptor references";
        }
        list action-reference-set {
          key "action-order";
      uses fpc:fpc-action-order;
          leaf action-id-reference {
      type fpc:fpc-identity;
      mandatory true;
      description "Action Identifier Reference";
          }
          description "A set of Action references";
        }
        description
          "Rule.Definition";
    }
    // Policy Structures
    grouping fpc-precedence {
    leaf precedence {
      type uint32;
      mandatory true;
      description "Rule Precedence";
    }
    description "FPC Rule Precedence";
    }
    grouping policy {
        leaf policy-id {
            type fpc:fpc-identity;
            description "Policy Identifier";
        }
        list rule-set {
            key "precedence";
            unique "rule-id-reference";
            uses fpc:fpc-precedence;
            leaf rule-id-reference {
                type fpc:fpc-identity;
                mandatory true;
                description "Rule Identifier";
            }
            description "Rule Entry";
        }
        description "FPC Policy";
    }
    // FPC Policy
  grouping fpc-policy {
    list action-definition-set {
      key action-id;
      uses fpc:action-definition;
      description "List of Actions";
    }
    list descriptor-definition-set {
      key descriptor-id;
      uses fpc:descriptor-definition;
      description "List of Descriptors";
    }
    list rule-definition-set {
      key rule-id;
      uses fpc:rule-definition;
      description "List of Rules";
    }
    list policy-definition-set {
      key policy-id;
      uses fpc:policy;
      description "List of Policies";
    }
    description "FPC Policy Structures";
  }
    // Mobility Structures
  grouping configurable-policy-set {
    list installed-policy-list {
      key dpn-id-reference;
      leaf dpn-id-reference {
        type fpc:fpc-identity;
        description "Installed Policy identifier";
      }
      list installed-policy-set {
        key installed-policy-id;
        leaf installed-policy-id {
          type fpc:fpc-identity;
          description "Installed Policy Identifier";
        }
        leaf policy-id-reference {
          type fpc:fpc-identity;
          description "Installed Policy Identifier";
        }
        container policy-settings {
          uses fpcbase:fpc-settings;
          description "Policy Settings";
        }
        description "Policy installed upon a DPN";
      }
      description "Configurable Policy";
      uses fpc:settings;
    }
    description "List of installed DPN policies and settings";
  }
    // Dynamic Policy
    grouping mobility-context {
    leaf mobility-context-id {
      type fpc:fpc-identity;
      mandatory true;
      description "Mobility Context Identifier";
    }
    leaf dpn-group-id-reference {
      type fpc:fpc-identity;
      description "Group ID used when DPN selecitons were 
        made";
    }
    leaf parent-mobility-context-id-reference {
      type fpc:fpc-identity;
      description "Parent Mobility Context";
    }
    list dpn-reference-list {
      key "dpn-id-reference direction";
      leaf dpn-id-reference {
        type fpc:fpc-identity;
        mandatory true;
        description "DPN Id reference";
      }
      leaf direction {
        type fpc:fpc-direction-type;
        mandatory true;
        description "Direction of DPN assignment";
      }
      container dpn-settings-complementary {
        uses fpcbase:fpc-settings;
        description "Complentary Settings";
      }
      leaf interface-id-reference {
        type fpc:fpc-interface-id;
        mandatory true;
        description "referenced interface";
      }
      list embedded-rule-set {
        key "precedence";
        unique "rule-id";
        uses fpc:fpc-rule-id;
        uses fpc:match-type;
        uses fpc:fpc-precedence;
        list action-definition-set {
          key "action-order";
          uses fpc:fpc-action-order;
          uses fpc:action-definition;
          description "List of Actions";
        }
        list descriptor-definition-set {
          key descriptor-id;
          uses fpc:descriptor-definition;
          description "List of Descriptors";
        }
        description "List of FPC Embedded Rule Definitions";
      }
      leaf-list assigned-policy-reference-set {
        type fpc:fpc-identity;
        description "List of Policies request to be enforced for 
          this Mobility Context";
      }
      description "DPN List";
    }
    
    leaf-list requested-policy-reference-set {
      type fpc:fpc-identity;
      description "List of Policies request to be enforced for 
        this Mobility Context";
    }
    container context-settings-complementary {
      uses fpcbase:fpc-settings;
      description "Context Settings";
    }
    description "Mobility Context";
    }
    // Events, Probes & Notifications
  identity event-type {
    description "Base Event Type";
  }
  typedef event-type-id {
    type uint32;
    description "Event ID Type";
  }
  grouping monitor-id {
    leaf monitor-id {
      type fpc:fpc-identity;
      mandatory true;
      description "Monitor Identifier";
    }
    description "Monitor Id";
  }
    grouping monitor-config {
        uses fpc:monitor-id;
    leaf deterrable {
      type boolean;
      description "Indicates reports related to this
        config can be delayed.";
    }
    container binding-information {
      description "Placeholder for information helpful
        to binding the monitor ot the correct target";
    }
    uses fpc:target-value;
    choice configuration {
      mandatory true;
      case periodic-config {
        leaf period {
          type uint32;
          description "Period";
        }
        description "Periodic Config Case";
      }
      case threshold-config {
        leaf lo-thresh {
          type uint32;
          description "lo threshold";
        }
        leaf hi-thresh {
          type uint32;
          description "hi threshold";
        }
        description "Threshold Config Case";
      }
      case scheduled-config {
        leaf report-time {
          type uint32;
          description "Reporting Time";
        }
        description "Scheduled Config Case";
      }
      case events-config-ident {
        leaf-list event-identities {
          type identityref {
            base "fpc:event-type";
          }
          description "Event Identities";
        }
        description "Events Config Identities Case";
      }
      case events-config {
        leaf-list event-ids {
          type uint32;
            description "Event IDs";
        }
        description "Events Config Case";
      }
      description "Event Config Value";
    }
    description "Monitor Configuration";
  }
    grouping report {
      uses fpc:monitor-config;
      choice report-value {
        leaf trigger {
          type fpc:event-type-id;
          description "Trigger Identifier";
        }
        case simple-empty {
          leaf nothing {
            type empty;
            description "Empty Value";
          }
          description "Empty Case";
        }
        case simple-val32 {
          leaf val32 {
            type uint32;
            description "Unsigned 32 bit value";
          }
          description "Simple Value Case";
        }
        case list-simple-val32 {
            leaf-list  val32-list {
              type uint32;
              description "Unsigned 32 bit value";
            }
            description "Simple Value Case";
          }
        description "Report Value";
      }
      description "Monitor Report";
    }
    typedef agent-identifier {
        type fpc:fpc-identity;
        description "Agent Identifier";
    }
    typedef client-identifier {
        type fpc:fpc-identity;
        description "Client Identifier";
    }
    grouping basename-info {
          leaf basename {
            type fpc:fpc-identity;
            description "Rules Basename";
          }
          leaf base-state {
            type string;
            description "Current State";
          }
          leaf base-checkpoint {
            type string;
            description "Checkpoint";
          }
          description "Basename Information";
    }
    // Top Level Structures
  container tenants {
    list tenant {
      key "tenant-id";
      leaf tenant-id {
          type fpc:fpc-identity;
          description "Tenant ID";
      }
          container mobility {
           container topology {
              uses fpc:fpc-topology;
             uses fpc:basename-info {
               if-feature fpc:fpc-basename-registry;
             }
              description "Topology";
            }
           container policy {
             uses fpc:fpc-policy;
             uses fpc:basename-info {
               if-feature fpc:fpc-basename-registry;
             }
             description "Policy";
           }
            uses fpc:configurable-policy-set;
            list mobility-context-set {
                key "mobility-context-id";
                config false;
                uses fpc:mobility-context;
                description "Mobility Context Set";
            }
            list monitor-set {
              key monitor-id;
              uses fpc:monitor-config;
              description "Monitor Configurations";
            }
            description "Mobility Elements";
          }
      description "Tenant";
    }
    description "Tenant List";
  }
    // RPC
    // RPC Specific Structures
    typedef op-identifier {
        type uint64;
        description "Operation Identifier";
    }
    typedef ref-scope {
      type enumeration {
        enum none {
          value 0;
          description "no references";
        }
        enum op {
          value 1;
          description "All references are intra-operation";
        }
        enum bundle {
          value 2;
          description "All references in exist in bundle";
        }
        enum storage {
          value 3;
          description "One or more references exist in storage.";
        }
        enum unknown {
          value 4;
          description "The location of the references are unknown.";
        }
      }
      description "Search scope for references in the operation.";
    }
    grouping context-operation {
      uses fpc:mobility-context;
      uses fpcbase:instructions;
      description "Context Operation";
    }
    grouping payload {
        uses fpc:configurable-policy-set;
    list mobility-context-set {
        key "mobility-context-id";
        uses fpc:mobility-context;
        description "Mobility Context Set";
    }
    uses fpc:fpc-policy;
    description "Payload";
  }
    grouping op-header {
    leaf client-id {
      type fpc:client-identifier;
      mandatory true;
      description "Client ID";
    }
    leaf delay {
      type uint32;
      description "Operation Delay (ms)";
    }
    leaf op-id {
      type op-identifier;
      mandatory true;
      description "Operation Identifier";
    }
    description "Common Operation header";
    }
  grouping fpc-op-type {
    leaf op-type {
      type enumeration {
        enum create {
          value 0;
          description "create";
        }
        enum update {
          value 1;
          description "update";
        }
        enum query {
          value 2;
          description "query";
        }
        enum delete {
          value 3;
          description "delete";
        }
      }
      mandatory true;
      description "Type";
    }
    description "FPC Operation Type";
  }
  grouping fpc-op-ref-scope {
    leaf op-ref-scope {
      if-feature operation-ref-scope;
      type fpc:ref-scope;
      description "Reference Scope";
    }
    description "FPC OP-REF Scope";
  }
  grouping op-input {
    uses fpc:fpc-op-ref-scope;
    uses fpcbase:instructions;
    choice op_body {
      case create_or_update {
        uses fpc:payload;
        description "Create/Update input";
      }
      case delete_or_query {
        uses fpc:target-value;
        description "Delete/Query input";
      }
      description "Opeartion Input value";
    }
    description "Operation Input";
  }
  typedef result-status {
    type enumeration {
      enum ok {
        value 0;
        description "OK";
      }
      enum err {
        value 1;
        description "Error";
      }
    }
    description "Result Status";
  }
  grouping status-value {
    leaf op-id {
      type op-identifier;
      mandatory true;
      description "Operation Identifier";
    }
    leaf status {
      type result-status;
      mandatory true;
      description "Status";
    }    
    description "Status value for all messages";
  }
  grouping result {
    uses fpc:status-value;
    uses fpc:result-body;
    description "General Result grouping";
  }
  grouping result-body {
    leaf notify-follows {
      type boolean;
      description "Indicates that a notification will 
        follow regarding this result";
    }
    choice result-type {
      case err {
        uses restconf:errors;
        description "Error Information";
      }
      case create-or-update-success {
        uses fpc:payload;
        description "Create/Update Success";
      }
      case delete_or_query-success {
        uses fpc:target-value;
        description "Delete/Query Success";
      }
      case empty-case {
        description "Empty Case";
      }
      description "Result Value";
    }
    description "Common Result member body";
  }
  // Common RPCs
  rpc configure {
    description "CONF message";
    input {
      uses fpc:op-header;
      uses fpc:fpc-op-type;
      uses fpc:op-input;
    }
    output {
      uses fpc:result;
    }
  }
  rpc configure-bundles {
    if-feature fpc:fpc-bundles;
    description "CONF_BUNDLES message";
    input {
      uses fpc:op-header;
      uses fpc:fpc-op-type;
      uses fpc:fpc-op-ref-scope;
      list bundles {
        key op-id;
        leaf op-id {
          type op-identifier;
          mandatory true;
          description "Operation Identifier";
        }
        uses fpc:op-input;
        description "List of operations";
      }
    }
    output {
      uses fpc:status-value;
      list bundles {
        key op-id;
        uses fpc:result;
        description "Operation Identifier";
      }
    }
  }
  rpc reg_monitor {
    description "Used to register monitoring of parameters/events";
    input {
      uses fpc:op-header;
      uses fpc:monitor-config;
    }
    output {
      uses fpc:status-value;
      uses restconf:errors;
    }
  }
  rpc dereg_monitor {
    description "Used to de-register monitoring of
      parameters/events";
    input {
      uses fpc:op-header;
      leaf-list monitor-set {
        type fpc:fpc-identity;
        min-elements 1;
        description "Monitor Identifier";
      }
      leaf send_data {
        type boolean;
        description "Indicates if NOTIFY with final data 
          is desired upon deregistration";
      }
    }
    output {
      uses fpc:status-value;
      uses restconf:errors;
    }
  }
  rpc probe {
    description "Probe the status of a registered monitor";
    input {
      uses fpc:op-header;
      uses fpc:monitor-id;
    }
    output {
      uses fpc:status-value;
      uses restconf:errors;
    }
  }
  // Notification Messages & Structures
  grouping notification-header {
    leaf notification-id {
      type uint32;
      description "Notification Identifier";
    }
    leaf timestamp {
      type uint32;
      description "timestamp";
    }
    description "Notification Header";
  }
  notification config-result-notification {
    uses fpc:notification-header;
    uses fpc:status-value;
    choice value {
      case config-result {
        uses result-body;
        description "CONF Result";
      }
      case config-bundle-result {
        list bundles {
          key op-id;
          uses fpc:result;
          description "Operation Identifier";
        }
        description "CONF_BUNDLES Result";
      }
      description "Config Result value";
    }
    description "CONF/CONF_BUNDLES Async Result";
  }
  identity notification-cause {
    description "Notification Cause";
  }
  identity dpn-availabilty-change {
    base "notification-cause";
    description "DPN Candidate/Exisitng DPN Availablity Change";
  }
  identity monitoring-suspension {
    base "notification-cause";
    description "Indicates monitoring suspension";
  }
  identity monitoring-resumption {
    base "notification-cause";
    description "Indicates that monitoring has resumed";
  }
  identity monitor-notification {
    base "notification-cause";
    description "Indicates 1+ monitor reports";
  }
  notification notify {
    uses fpc:notification-header;
    leaf cause {
      type identityref {
        base "notification-cause";
      }
      description "Notification Cause";
    }
    choice value {
      case dpn-candidate-available {
        if-feature fpc:fpc-auto-binding;
        leaf node-id {
          type inet:uri;
          description "Topology URI";
        }
        list supported-interface-list {
          key "access-technology role";
          uses fpc:access-technology-key;
          uses fpc:role-key;
          description "Support Intefaces";
        }
        description "DPN Candidate Information";
      }
      case dpn-unavailable {
        leaf dpn-id {
          type fpc:fpc-identity;
          description "DPN Identifier";
        }
        description "DPN Unavailable";
      }
      case monitor-notification {
        list reports {
          uses fpc:report;
          description "Reports";
        }
        description "Monitor Notification";
      }
      description "Notify Value";
    }
    description "Notify Message";
  }
}
<CODE ENDS>]]></artwork>
        </figure>
  </section>

  <section anchor="yangmodels" title="YANG Models">
  <section anchor="description" title="FPC YANG Settings and Extensions Model">
    <t>This module defines the base data elements in FPC that are likely to be extended.</t>
    <t>This module references <xref target="RFC6991"/>, ietf-trafficselector-types and ietf-pmip-qos modules.</t>
        <figure>
          <artwork><![CDATA[
<CODE BEGINS> file "ietf-dmm-fpc-settingsext@2017-09-27.yang"
module ietf-dmm-fpc-settingsext {
  yang-version 1.1;
  namespace "urn:ietf:params:xml:ns:yang:ietf-dmm-fpc-settingsext";
  prefix fpcbase;
  
    import ietf-inet-types { prefix inet; 
        revision-date 2013-07-15; }
    import ietf-trafficselector-types { prefix traffic-selectors; 
        revision-date 2017-10-29; }
    import ietf-yang-types { prefix ytypes;
        revision-date 2013-07-15; }
    import ietf-pmip-qos { prefix pmipqos;
        revision-date 2016-02-10; }

    organization "IETF Distributed Mobility Management (DMM)
      Working Group";

    contact
       "WG Web:   <http://tools.ietf.org/wg/netmod/>
        WG List:  <mailto:netmod@ietf.org>

        WG Chair: Dapeng Liu
                  <mailto:maxpassion@gmail.com>

        WG Chair: Jouni Korhonen
                  <mailto:jouni.nospam@gmail.com>

        Editor:   Satoru Matsushima
                  <mailto:satoru.matsushima@g.softbank.co.jp>

        Editor:   Lyle Bertz
                  <mailto:lylebe551144@gmail.com>";

    description
    "This module contains YANG definition for
     Forwarding Policy Configuration Protocol(FPCP).

      It contains Settings defintions as well as Descriptor and 
      Action extensions.
      
     Copyright (c) 2016 IETF Trust and the persons identified as the
     document authors. All rights reserved.

     This document is subject to BCP 78 and the IETF Trust's Legal
     Provisions Relating to IETF Documents
     (http://trustee.ietf.org/license-info) in effect on the date of
     publication of this document. Please review these documents
     carefully, as they describe your rights and restrictions with
     respect to this document. Code Components extracted from this
     document must include Simplified BSD License text as described
     in Section 4.e of the Trust Legal Provisions and are provided
     without warranty as described in the Simplified BSD License.";
    
    revision 2017-09-27 {
    description "Version 10 updates.";
    reference "draft-ietf-dmm-fpc-cpdp-10";
}
revision 2017-07-22 {
    description "Version 08 updates.";
    reference "draft-ietf-dmm-fpc-cpdp-08";
}
revision 2017-03-08 {
    description "Version 06 updates.";
    reference "draft-ietf-dmm-fpc-cpdp-06";
}
revision 2016-08-03 {
    description "Initial Revision.";
    reference "draft-ietf-dmm-fpc-cpdp-05";
}

    // Next Hop Structures - SETTING
    typedef fpc-service-path-id {
        type uint32 {
            range "0..33554431";
        }
        description "SERVICE_PATH_ID";
    }
    typedef fpc-mpls-label {
        type uint32 {
          range "0..1048575";
        }
        description "MPLS label";
    }
    identity fpc-nexthop-type {
        description "NAT Service";
    }
    
    grouping fpc-nexthop {
        leaf nexthop-type {
            type identityref {
              base "fpcbase:fpc-nexthop-type";
            }
            mandatory true;
            description "Nexthop Type";
        }
        choice nexthop-value {
              mandatory true;
            case ip-nexthop {
                leaf ip {
                  type inet:ip-address;
                  description "IP Value";
                }
                description "IP Case";
            }
            case macaddress-nexthop {
                leaf macaddress {
                  type ytypes:mac-address;
                  description "MAC Address Value";
                }
            }
            case servicepath-nexthop {
                leaf servicepath {
                    type fpcbase:fpc-service-path-id;
                    description "Service Path Value";
                }
                description "Service Path Case";
            }
            case mplslabel-nexthop {
                leaf lsp {
                    type fpcbase:fpc-mpls-label;
                    description "MPLS Value";
                }
                description "Service Path Case";
            }
            case if-nexthop {
                leaf if-index {
                    type uint16;
                    description "If (interface) Value";
                }
                description "Service Path Case";
            }
            description "Value";
        }
        description "Nexthop Value";
    }

    // Address Translation - ACTION
    grouping simple-nat {
      leaf outbound-nat-address {
        type inet:ip-address;
        description "Outbound NAT Address";
      }
      description "Simple NAT value";
    }
    grouping simple-napt {
      leaf source-port {
        type inet:port-number;
        description "Source Port";
      }
      leaf outbound-napt-address {
        type inet:ip-address;
        description "Outbound NAPT Address";
      }
      leaf destination-port {
        type inet:port-number;
        description "Destination Port";
      }
      description "Simple NAPT Configuration";
    }

    // COPY FORWARD - ACTION
    grouping copy-forward {
      container destination {
        choice value {
          case nexthop-case {
      container nexthop {
              uses fpcbase:fpc-nexthop;
              description "Next Hop";
          }
            description "Port Forward Case";
          }
          description "Copy Forward Value";
        }
        description "destination";
      }
      description "Copy Then Forward to Port/Context Action";
    }

    //////////////////////////////
    // PMIP Integration         //
      identity pmip-tunnel-type {
          description "PMIP Tunnel Type";
      }
      identity grev1 {
          base "pmip-tunnel-type";
          description "GRE v1";
      }
      identity grev2 {
          base "pmip-tunnel-type";
          description "GRE v2";
      }
      identity ipinip {
          base "pmip-tunnel-type";
          description "IP in IP";
      }
      grouping pmip-tunnel-info {
          leaf pmip-tunnel-type {
              type identityref {
                  base "pmip-tunnel-type";
              }
              description "PMIP Mobility";
          }
          choice pmip-tunnel-value {
              case gre {
                  leaf gre-key {
                      type uint32;
                      description "GRE_KEY";
                  }
                  description "GRE Value";
              }
              description "PMIP Mobility value";
          }
          uses traffic-selectors:traffic-selector;
          description "PMIP Tunnel Information";
      }
      typedef pmip-commandset {
            type bits {
                bit assign-ip {
                  position 0;
                  description "Assign IP";
                }
                bit assign-dpn {
                  position 1;
                  description "Assign DPN";
                }
                bit session {
                  position 2;
                  description "Session Level";
                }
                bit uplink {
                  position 3;
                  description "Uplink";
                }
                bit downlink {
                  position 4;
                  description "Downlink";
                }
            }
            description "PMIP Instructions";
        }
    ///////////////////////////////
    // 3GPP Integration         //
  //    Tunnel Types
      identity threeGPP-tunnel-type {
          description "3GPP Base Tunnel Type";
      }
      identity gtpv1 {
          base "fpcbase:threeGPP-tunnel-type";
          description "GTP version 1 Tunnel";
      }
      identity gtpv2 {
          base "fpcbase:threeGPP-tunnel-type";
          description "GTP version 2 Tunnel";
      }
      // QoS Profile
      typedef fpc-qos-class-identifier {
          type uint8 {
              range "1..9";
          }
          description "QoS Class Identifier (QCI)";
      }
      grouping threeGPP-QoS {
          description "3GPP QoS Attributes";
          leaf qci {
              type fpc-qos-class-identifier;
              description "QCI";
          }
          leaf gbr {
              type uint32;
              description "Guaranteed Bit Rate";
          }
          leaf mbr {
              type uint32;
              description "Maximum Bit Rate";
          }
          leaf apn-ambr {
              type uint32;
              description "Access Point Name Aggregate Max Bit Rate";
          }
          leaf ue-ambr {
              type uint32;
              description "User Equipment Aggregate Max Bit Rate";
          }
          container arp {
              uses pmipqos:Allocation-Retention-Priority-Value;
              description "Allocation Retention Priority";
          }
      }
      typedef ebi-type {
        type uint8 {
          range "0..15";
        }
        description "EUTRAN Bearere Identifier (EBI) Type";
      }

     // From 3GPP TS 24.008 version 13.5.0 Release 13
     typedef component-type-enum {
          type enumeration {
              enum ipv4RemoteAddress {
                value 16;
                description "IPv4 Remote Address";
              }
              enum ipv4LocalAddress  {
                value 17;
                description "IPv4 Local Address";
              }
              enum ipv6RemoteAddress {
                value 32;
                description "IPv6 Remote Address";
              }
              enum ipv6RemoteAddressPrefix {
                value 33;
                description "IPv6 Remote Address Prefix";
              }
              enum ipv6LocalAddressPrefix {
                value 35;
                description "IPv6 Local Address Prefix";
              }
              enum protocolNextHeader {
                value 48;
                description "Protocol (IPv4) or NextHeader (IPv6)
                  value";
              }
              enum localPort {
                value 64;
                description "Local Port";
              }
              enum localPortRange {
                value 65;
                description "Local Port Range";
              }
              enum reomotePort {
                value 80;
                description "Remote Port";
              }
              enum remotePortRange {
                value 81;
                description "Remote Port Range";
              }
              enum secParamIndex {
                value 96;
                description "Security Parameter Index (SPI)";
              }
              enum tosTraffClass {
                value 112;
                description "TOS Traffic Class";
              }
              enum flowLabel {
                value 128;
                description "Flow Label";
              }
          }
          description "TFT Component Type";
      }
      typedef packet-filter-direction {
          type enumeration {
            enum preRel7Tft {
              value 0;
              description "Pre-Release 7 TFT";
            }
            enum uplink {
              value 1;
              description "uplink";
            }
            enum downlink {
              value 2;
              description "downlink";
            }
            enum bidirectional {
              value 3;
              description "bi-direcitonal";
            }
          }
          description "Packet Filter Direction";
      }
      typedef component-type-id {
          type uint8 {
            range "16 | 17 | 32 | 33 | 35 | 48 | 64 | 65 |"
            + " 80 | 81 | 96 | 112 | 128";
          }
          description "Specifies the Component Type";
      }
      grouping packet-filter {
        leaf direction {
            type fpcbase:packet-filter-direction;
            description "Filter Direction";
        }
        leaf identifier {
            type uint8 {
              range "1..15";
            }
            description "Filter Identifier";
        }
        leaf evaluation-precedence {
            type uint8;
            description "Evaluation Precedence";
        }
        list contents {
          key component-type-identifier;
          description "Filter Contents";
          leaf component-type-identifier {
              type fpcbase:component-type-id;
              description "Component Type";
          }
          choice value {
            case ipv4-local {
              leaf ipv4-local {
                type inet:ipv4-address;
                description "IPv4 Local Address";
              }
            }
            case ipv6-prefix-local {
              leaf ipv6-prefix-local {
                type inet:ipv6-prefix;
                description "IPv6 Local Prefix";
              }
            }
            case ipv4-ipv6-remote {
              leaf ipv4-ipv6-remote {
                type inet:ip-address;
                description "Ipv4 Ipv6 remote address";
              }
            }
            case ipv6-prefix-remote {
              leaf ipv6-prefix-remote {
                type inet:ipv6-prefix;
                description "IPv6 Remote Prefix";
              }
            }
            case next-header {
              leaf next-header {
                type uint8;
                description "Next Header";
              }
            }
            case local-port {
              leaf local-port {
                type inet:port-number;
                description "Local Port";
              }
            }
            case local-port-range {
              leaf local-port-lo {
                type inet:port-number;
                description "Local Port Min Value";
              }
              leaf local-port-hi {
                type inet:port-number;
                description "Local Port Max Value";
              }
            }
            case remote-port {
              leaf remote-port {
                type inet:port-number;
                description "Remote Port";
              }
            }
            case remote-port-range {
              leaf remote-port-lo {
                type inet:port-number;
                description "Remote Por Min Value";
              }
              leaf remote-port-hi {
                type inet:port-number;
                description "Remote Port Max Value";
              }
            }
            case ipsec-index {
              leaf ipsec-index {
                type traffic-selectors:ipsec-spi;
                description "IPSec Index";
              }
            }
            case traffic-class {
              leaf traffic-class {
                type inet:dscp;
                description "Traffic Class";
              }
            }
            case traffic-class-range {
                leaf traffic-class-lo {
                  type inet:dscp;
                  description "Traffic Class Min Value";
                }
                leaf traffic-class-hi {
                  type inet:dscp;
                  description "Traffic Class Max Value";
                }
            }
            case flow-label-type {
              leaf-list flow-label {
                type inet:ipv6-flow-label;
                description "Flow Label";
              }
            }
            description "Component Value";
          }
        }
        description "Packet Filter";
      }
      grouping tft {
        list packet-filters {
            key identifier;
            uses fpcbase:packet-filter;
            description "List of Packet Filters";
        }
        description "Packet Filter List";
      }
      typedef imsi-type {
          type uint64;
          description
              "International Mobile Subscriber Identity (IMSI)
                Value Type";
      }
      typedef threegpp-instr {
        type bits {
          bit assign-ip {
            position 0;
            description "Assign IP Address/Prefix";
          }
          bit assign-fteid-ip {
            position 1;
            description "Assign FTEID-IP";
          }
          bit assign-fteid-teid {
            position 2;
            description "Assign FTEID-TEID";
          }
          bit session {
            position 3;
            description "Commands apply to the Session Level";
          }
          bit uplink {
            position 4;
            description "Commands apply to the Uplink";
          }
          bit downlink {
            position 5;
            description "Commands apply to the Downlink";
          }
          bit assign-dpn {
            position 6;
            description "Assign DPN";
          }
        }
        description "Instruction Set for 3GPP R11";
      }
      
      grouping threegpp-tunnel-info {
          leaf tunnel-type {
              type identityref  {
                base "fpcbase:threeGPP-tunnel-type";
              }
              description "3GPP Tunnel Subtype";
          }
          leaf tunnel-identifier {
              type uint32;
              description "Tunnel Endpoint IDentifier (TEID)";
          }
          choice tft-or-ref {
            case defined-tft {
              uses fpcbase:tft;
            }
            description "TFT Value";
          }
          description "3GPP TFT and Tunnel Information";
        }
      
      grouping threegpp-properties {
          leaf imsi {
            type fpcbase:imsi-type;
            description "IMSI";
          }
          leaf ebi {
            type fpcbase:ebi-type;
            description "EUTRAN Bearere Identifier (EBI)";
          }
          leaf lbi {
            type fpcbase:ebi-type;
            description "Linked Bearer Identifier (LBI)";
          }
          description "3GPP Mobility Session Properties";
        }
    //////////////////////////////
    // ACTION VALUE AUGMENTS
    grouping fpc-action-value {
        choice action-value {
            mandatory true;
            case drop {
              leaf drop {
                type empty;
                description "Drop Traffic";
              }
            }
            case simple-nat {
                uses fpcbase:simple-nat;
                description "Simple NAT value";
            }
            case simple-napt {
                uses fpcbase:simple-napt;
                description "Simple NAPT Value";
            }
            case copy-forward {
                uses fpcbase:copy-forward;
                description "Copy Forward Value";
            }
            case pmip-selector {
                uses traffic-selectors:traffic-selector;
                description "PMIP Selector";
            }
            description "Action Value";
        }
        description "FPC Action Value";
    }

    //////////////////////////////
    // DESCRIPTOR DEFINITIONS
  grouping fpc-descriptor-value {
    choice descriptor-value {
      mandatory true;
      case all-traffic {
        leaf all-traffic {
          type empty;
          description "admit any";
        }
      }
      case no-traffic {
        leaf no-traffic {
          type empty;
          description "deny any";
        }
      }
      case prefix-descriptor {
        leaf destination-ip {
          type inet:ip-prefix;
          description "Rule of destination IP";
        }
        leaf source-ip {
          type inet:ip-prefix;
          description "Rule of source IP";
        }
        description "Traffic descriptor based upon source/
          destination as IP prefixes";
      }
      case pmip-selector {
        uses traffic-selectors:traffic-selector;
        description "PMIP Selector";
      }
      case threegpp-tft {
          uses fpcbase:tft;
          description "3GPP TFT";
      }
      description "Descriptor Value";
    }
    description "FPC Descriptor Values";
  }
    
    //SETTINGS DEFINITIONS
    grouping fpc-settings {
        leaf-list delegated-ip-prefixes {
            type inet:ip-prefix;
            description "Delegated Prefix(es)";
        }
        leaf tunnel-local-address {
            type inet:ip-address;
            description "local tunnel address";
        }
        leaf tunnel-remote-address {
            type inet:ip-address;
            description "remote tunnel address";
        }
        leaf mtu-size {
            type uint32;
            description "MTU size";
        }
        container mobility-tunnel-parameters {
            choice profile-parameters {
                case nothing {
                  leaf none {
                    type empty;
                    description "Empty Value";
                  }
                  description "No Parameters Case";
                }
        case pmip {
          uses pmip-tunnel-info;
        }
        case threegpp {
          uses threegpp-tunnel-info;
          uses threegpp-properties;
        }
                description "Mobility Profile Parameters";
            }
            description
            "Profile specific tunnel parameters";
        }
        container nexthop {
            uses fpcbase:fpc-nexthop;
            description "Next Hop";
        }
        container qos-profile-parameters {
            choice value {
                description "QoS Value";
            }
            description "QoS Parameters";
        }
        description "A collection of settings";
    }
    identity access-technology {
    description "The technology used in the access network";
  }
    identity role {
    description "The access-technology function of the DPN";
}
  identity ietf-pmip-access-type {
    base "fpcbase:access-technology";
    description "PMIP Access";
  }
  identity threeGPP-access-type {
    base "fpcbase:access-technology";
    description "3GPP Access Type";
  }
   // Instructions
  grouping instructions {
    container instructions {
      choice instr-type {
        case threegpp-instr {
          leaf instr-3gpp-mob {
            type fpcbase:threegpp-instr;
            description "3GPP GTP Mobility Instructions";
          }
        }
        case pmip-instr {
          leaf instr-pmip {
            type pmip-commandset;
            description "PMIP Instructions";
          }
        }
        description "Instruction Value Choice";
      }
      description "Instructions";
    }
    description "Instructions Value";
  }
}
<CODE ENDS>]]></artwork>
        </figure>
</section>

  <section anchor="ietf-pmip-qos" title="PMIP QoS Model">
    <t>This module defines the base protocol elements specified in this document.</t>
    <t>This module references <xref target="RFC6991"/>.</t>
        <figure>
          <artwork><![CDATA[
<CODE BEGINS> file "ietf-pmip-qos@2017-10-29.yang"
module ietf-pmip-qos {
    yang-version 1.1;

    namespace
      "urn:ietf:params:xml:ns:yang:ietf-pmip-qos";

    prefix "qos-pmip";

    import ietf-inet-types {
      prefix inet;
      revision-date 2013-07-15;
    }
    import ietf-trafficselector-types { prefix traffic-selectors; }

    organization "IETF Distributed Mobility Management (DMM)
      Working Group";

    contact
       "WG Web:   <http://tools.ietf.org/wg/netmod/>
        WG List:  <mailto:netmod@ietf.org>

        WG Chair: Dapeng Liu
                  <mailto:maxpassion@gmail.com>

        WG Chair: Jouni Korhonen
                  <mailto:jouni.nospam@gmail.com>

        Editor:   Satoru Matsushima
                  <mailto:satoru.matsushima@g.softbank.co.jp>

        Editor:   Lyle Bertz
                  <mailto:lylebe551144@gmail.com>";

    description
      "This module contains a collection of YANG definitions for
     quality of service paramaters used in Proxy Mobile IPv6.

     Copyright (c) 2016 IETF Trust and the persons identified as the
     document authors. All rights reserved.

     This document is subject to BCP 78 and the IETF Trust's Legal
     Provisions Relating to IETF Documents
     (http://trustee.ietf.org/license-info) in effect on the date of
     publication of this document. Please review these documents
     carefully, as they describe your rights and restrictions with
     respect to this document. Code Components extracted from this
     document must include Simplified BSD License text as described
     in Section 4.e of the Trust Legal Provisions and are provided
     without warranty as described in the Simplified BSD License.";

  revision 2017-10-29 {
     description "Base Version";
      reference
        "RFC 6088: Traffic Selectors for Flow Bindings";
   }

    // Type Definitions

    // QoS Option Field Type Definitions
  typedef sr-id {
    type uint8;
      description
       "An 8-bit unsigned integer used for identifying the QoS 
        Service Request.";
    }

    typedef traffic-class {
      type inet:dscp;
      description
        "Traffic Class consists of a 6-bit DSCP field followed by a
         2-bit reserved field.";
     reference
         "RFC 3289: Management Information Base for the 
             Differentiated Services Architecture
          RFC 2474: Definition of the Differentiated Services Field
                    (DS Field) in the IPv4 and IPv6 Headers
          RFC 2780: IANA Allocation Guidelines For Values In
                    the Internet Protocol and Related Headers";
    }

    typedef operational-code {
      type enumeration {
        enum RESPONSE {
          value 0;
          description "Response to a QoS request";
        }
        enum ALLOCATE {
          value 1;
          description "Request to allocate QoS resources";
        }
        enum DE-ALLOCATE {
          value 2;
          description "Request to de-Allocate QoS resources";
        }
        enum MODIFY {
          value 3;
          description "Request to modify QoS parameters for a
              previously negotiated QoS Service Request";
        }
        enum QUERY {
          value 4;
          description "Query to list the previously negotiated QoS
              Service Requests that are still active";
        }
        enum NEGOTIATE {
          value 5;
          description "Response to a QoS Service Request with a
            counter QoS proposal";
        }
      }
      description
       "The type of QoS request. Reserved values:   (6) to (255)
                Currently not used.  Receiver MUST ignore the option
                received with any value in this range.";
    }

    // QoS Attribute Types

    //The enumeration value for mapping - don't confuse with the
    //  identities
    typedef qos-attrubite-type-enum {
      type enumeration {
        enum Reserved {
          value 0;
          description "This value is reserved and cannot be used";
        }
        enum Per-MN-Agg-Max-DL-Bit-Rate {
          value 1;
          description "Per-Mobile-Node Aggregate Maximum Downlink
              Bit Rate.";
        }
        enum Per-MN-Agg-Max-UL-Bit-Rate {
          value 2;
          description "Per-Mobile-Node Aggregate Maximum Uplink Bit
            Rate.";
        }
        enum Per-Session-Agg-Max-DL-Bit-Rate {
          value 3;
          description "Per-Mobility-Session Aggregate Maximum
            Downlink Bit Rate.";
        }
        enum Per-Session-Agg-Max-UL-Bit-Rate {
          value 4;
          description "Per-Mobility-Session Aggregate Maximum
             Uplink Bit Rate.";
        }
        enum Allocation-Retention-Priority {
          value 5;
          description "Allocation and Retention Priority.";
        }
        enum Aggregate-Max-DL-Bit-Rate {
          value 6;
          description "Aggregate Maximum Downlink Bit Rate.";
        }
        enum Aggregate-Max-UL-Bit-Rate {
          value 7;
          description "Aggregate Maximum Uplink Bit Rate.";
        }
        enum Guaranteed-DL-Bit-Rate {
          value 8;
          description "Guaranteed Downlink Bit Rate.";
        }
        enum Guaranteed-UL-Bit-Rate {
          value 9;
          description "Guaranteed Uplink Bit Rate.";
        }
        enum QoS-Traffic-Selector {
          value 10;
          description "QoS Traffic Selector.";
        }
        enum QoS-Vendor-Specific-Attribute {
          value 11;
          description "QoS Vendor-Specific Attribute.";
        }
      }
     description
    "The type of the QoS attribute.  This specification reserves 
       the following reserved values.
         (12) to (254) -  Reserved
            These values are reserved for future allocation.

         (255)  Reserved
            This value is reserved and cannot be used.";
    }

    // Attribute Type as Identities
    // Added for convenience of inclusion and extension in
    //    other YANG modules.
    identity qos-attribute-type {
      description
        "Base type for Quality of Service Attributes";
    }

    identity Per-MN-Agg-Max-DL-Bit-Rate-type {
      base qos-attribute-type;
      description
        "Per-Mobile-Node Aggregate Maximum Downlink Bit Rate.";
    }

   identity Per-MN-Agg-Max-UL-Bit-Rate-type {
      base qos-attribute-type;
      description
        "Per-Mobile-Node Aggregate Maximum Uplink Bit Rate";
   }

   identity Per-Session-Agg-Max-DL-Bit-Rate-type {
      base qos-attribute-type;
      description
       "Per-Mobility-Session Aggregate Maximum Downlink Bit Rate.";
  }

   identity Per-Session-Agg-Max-UL-Bit-Rate-type {
      base qos-attribute-type;
      description
       "Per-Mobility-Session Aggregate Maximum Uplink Bit Rate.";
   }

   identity Allocation-Retention-Priority-type {
      base qos-attribute-type;
      description
        "Allocation and Retention Priority.";
   }

   identity Aggregate-Max-DL-Bit-Rate-type {
      base qos-attribute-type;
      description "Aggregate Maximum Downlink Bit Rate.";
   }

  identity Aggregate-Max-UL-Bit-Rate-type {
      base qos-attribute-type;
      description "Aggregate Maximum Uplink Bit Rate.";
  }

  identity Guaranteed-DL-Bit-Rate-type {
      base qos-attribute-type;
      description "Guaranteed Downlink Bit Rate.";
  }

  identity Guaranteed-UL-Bit-Rate-type {
      base qos-attribute-type;
      description "Guaranteed Uplink Bit Rate.";
  }

  identity QoS-Traffic-Selector-type {
      base qos-attribute-type;
      description "QoS Traffic Selector.";
  }

  identity QoS-Vendor-Specific-Attribute-type {
      base qos-attribute-type;
      description "QoS Vendor-Specific Attribute.";
  }

  //value definitions
  typedef Per-MN-Agg-Max-DL-Bit-Rate-Value {
      type uint32;
      description
          "The aggregate maximum downlink bit rate that is
          requested/allocated for all the mobile node's IP flows.
          The measurement units are bits per second.";
  }

   typedef Per-MN-Agg-Max-UL-Bit-Rate-Value {
      type uint32;
      description
        "The aggregate maximum uplink bit rate that is
            requested/allocated for the mobile node's IP flows. The
            measurement units are bits per second.";
   }

   // Generic Structure for the uplink and downlink
   grouping Per-Session-Agg-Max-Bit-Rate-Value {
     leaf max-rate {
       type uint32;
       mandatory true;
       description
       "The aggregate maximum bit rate that is requested/allocated 
     for all the IP flows associated with that mobility session.  
     The measurement units are bits per second.";
     }
     leaf service-flag {
      type boolean;
      mandatory true;
      description
       "This flag is used for extending the scope of the
        target flows for Per-Session-Agg-Max-UL/DL-Bit-Rate
        from(UL)/to(DL) the mobile node's other mobility sessions
        sharing the same Service Identifier.";
      reference
        "RFC 5149 - Service Selection mobility option";
     }
     leaf exclude-flag {
       type boolean;
       mandatory true;
       description
        "This flag is used to request that the uplink/downlink
       flows for which the network is providing
            Guaranteed-Bit-Rate service be excluded from the
            target IP flows for which
            Per-Session-Agg-Max-UL/DL-Bit-Rate is measured.";
     }
    description "Per-Session-Agg-Max-Bit-Rate Value";
   }

   grouping Allocation-Retention-Priority-Value {
     leaf prioirty-level {
       type uint8 {
         range "0..15";
       }
       mandatory true;
       description
        "This is a 4-bit unsigned integer value.  It is used to 
        decide whether a mobility session establishment or 
        modification request can be accepted; this is typically used
        for admission control of Guaranteed Bit Rate traffic in 
        case of resource limitations.";
     }
     leaf premption-capability {
       type enumeration {
        enum enabled {
          value 0;
          description "enabled";
        }
        enum disabled {
          value 1;
          description "disabled";
        }
        enum reserved1 {
          value 2;
          description "reserved1";
        }
        enum reserved2 {
          value 3;
          description "reserved2";
        }
       }
       mandatory true;
       description
       "This is a 2-bit unsigned integer value.  It defines whether a
        service data flow can get resources that were already
        assigned to another service data flow with a lower priority
        level.";
     }
     leaf premption-vulnerability {
       type enumeration {
        enum enabled {
          value 0;
          description "enabled";
        }
        enum disabled {
          value 1;
          description "disabled";
        }
        enum reserved1 {
          value 2;
          description "reserved1";
        }
        enum reserved2 {
          value 3;
          description "reserved2";
        }
       }
       mandatory true;
       description
       "This is a 2-bit unsigned integer value.  It defines whether a
         service data flow can lose the resources assigned to it in
         order to admit a service data flow with a higher priority
         level.";
     }
    description "Allocation-Retention-Priority Value";
   }

   typedef Aggregate-Max-DL-Bit-Rate-Value {
      type uint32;
      description
        "The aggregate maximum downlink bit rate that is
         requested/allocated for downlink IP flows.  The measurement
         units are bits per second.";
   }

    typedef Aggregate-Max-UL-Bit-Rate-Value {
      type uint32;
      description
        "The aggregate maximum downlink bit rate that is
         requested/allocated for downlink IP flows.  The measurement
         units are bits per second.";
    }

    typedef Guaranteed-DL-Bit-Rate-Value {
      type uint32;
      description
      "The guaranteed bandwidth in bits per second for downlink
        IP flows.  The measurement units are bits per second.";
    }

    typedef Guaranteed-UL-Bit-Rate-Value {
      type uint32;
      description
        "The guaranteed bandwidth in bits per second for uplink 
         IP flows.  The measurement units are bits per second.";
    }

    grouping QoS-Vendor-Specific-Attribute-Value-Base {
      leaf vendorid {
        type uint32;
        mandatory true;
        description
         "The Vendor ID is the SMI (Structure of Management
          Information) Network Management Private Enterprise Code of
          the IANA-maintained 'Private Enterprise Numbers'
          registry.";
        reference
          "'PRIVATE ENTERPRISE NUMBERS', SMI Network Management
            Private Enterprise Codes, April 2014,
             <http://www.iana.org/assignments/enterprise-numbers>";
      }
      leaf subtype {
        type uint8;
        mandatory true;
        description
          "An 8-bit field indicating the type of vendor-specific
           information carried in the option.  The namespace for this
           sub-type is managed by the vendor identified by the
           Vendor ID field.";
      }
      description
        "QoS Vendor-Specific Attribute.";
    }

    //NOTE - We do NOT add the Status Codes or other changes in
    // PMIP in this module

    //Primary Structures (groupings)
    grouping qosattribute {
        leaf attributetype {
            type identityref {
                base qos-attribute-type;
            }
            mandatory true;
            description "the attribute type";
        }

        //All of the sub-types by constraint
        choice attribute-choice {
            case per-mn-agg-max-dl-case {
                when "./attributetype = "
                   + "'Per-MN-Agg-Max-DL-Bit-Rate-type'";
                leaf per-mn-agg-max-dl {
                    type qos-pmip:Per-MN-Agg-Max-DL-Bit-Rate-Value;
                    description "Per-MN-Agg-Max-DL-Bit-Rate Value";
                }
                description "Per-MN-Agg-Max-DL-Bit-Rate Case";
            }
            case per-mn-agg-max-ul-case {
                when "./attributetype = "
                  + "'Per-MN-Agg-Max-UL-Bit-Rate-type'";
                leaf per-mn-agg-max-ul {
                    type qos-pmip:Per-MN-Agg-Max-UL-Bit-Rate-Value;
                    description "Per-MN-Agg-Max-UL-Bit-Rate Value";
                }
                description "Per-MN-Agg-Max-UL-Bit-Rate Case";
            }
            case per-session-agg-max-dl-case {
                when "./attributetype = "
                + "'Per-Session-Agg-Max-DL-Bit-Rate-type'";
                container per-session-agg-max-dl {
                    uses qos-pmip:Per-Session-Agg-Max-Bit-Rate-Value;
                    description "Per-Session-Agg-Max-Bit-Rate Value";
                }
                description "Per-Session-Agg-Max-Bit-Rate Case";
            }
            case per-session-agg-max-ul-case {
                when "./attributetype = "
                + "'Per-Session-Agg-Max-UL-Bit-Rate-type'";
                container per-session-agg-max-ul {
                    uses qos-pmip:Per-Session-Agg-Max-Bit-Rate-Value;
                    description "Per-Session-Agg-Max-Bit-Rate Value";
                }
                description "Per-Session-Agg-Max-Bit-Rate Case";
            }
            case allocation-retention-priority-case {
                when "./attributetype = "
                   + "'Allocation-Retention-Priority-type'";
                uses qos-pmip:Allocation-Retention-Priority-Value;
                description "Allocation-Retention-Priority Case";
            }
            case agg-max-dl-case {
                when "./attributetype = "
                  + "'Aggregate-Max-DL-Bit-Rate-type'";
                leaf agg-max-dl {
                    type qos-pmip:Aggregate-Max-DL-Bit-Rate-Value;
                    description "Aggregate-Max-DL-Bit-Rate Value";
                }
                description "Aggregate-Max-DL-Bit-Rate Case";
            }
            case agg-max-ul-case {
                when "./attributetype = "
                  + "'Aggregate-Max-UL-Bit-Rate-type'";
                leaf agg-max-ul {
                    type qos-pmip:Aggregate-Max-UL-Bit-Rate-Value;
                    description "Aggregate-Max-UL-Bit-Rate Value";
                }
                description "Aggregate-Max-UL-Bit-Rate Case";
            }
            case gbr-dl-case {
                when "./attributetype = 
                   'Guaranteed-DL-Bit-Rate-type'";
                leaf gbr-dl {
                    type qos-pmip:Guaranteed-DL-Bit-Rate-Value;
                    description "Guaranteed-DL-Bit-Rate Value";
                }
                description "Guaranteed-DL-Bit-Rate Case";
            }
            case gbr-ul-case {
                when "./attributetype = 
                 'Guaranteed-UL-Bit-Rate-type'";
                leaf gbr-ul {
                    type qos-pmip:Guaranteed-UL-Bit-Rate-Value;
                    description "Guaranteed-UL-Bit-Rate Value";
                }
                description "Guaranteed-UL-Bit-Rate Case";
            }
            case traffic-selector-case {
                when "./attributetype = 'QoS-Traffic-Selector-type'";
                container traffic-selector {
                    uses traffic-selectors:traffic-selector;
                    description "traffic selector";
                }
                description "traffic selector Case";
            }
            description "Attribute Value";
        }
        description "PMIP QoS Attribute";
    }

    grouping qosoption {
        leaf srid {
            type sr-id;
            mandatory true;
            description "Service Request Identifier";
        }
        leaf trafficclass {
            type traffic-class;
            mandatory true;
            description "Traffic Class";
        }
        leaf operationcode {
            type operational-code;
            mandatory true;
            description "Operation Code";
        }
        list attributes {
            unique "attributetype";
            uses qosattribute;
            min-elements 1;
            description "Attributes";
        }
        description "PMIP QoS Option";
    }
}
<CODE ENDS>]]></artwork>
        </figure>
  </section>
  <section anchor="ietf-trafficselectors-types" title="Traffic Selectors YANG Model">
<t>This module defines traffic selector types commonly used in Proxy Mobile IP (PMIP).</t>
    <t>This module references <xref target="RFC6991"/>.</t>
    <figure>
         <artwork><![CDATA[
<CODE BEGINS> file "ietf-trafficselector-types@2017-10-29.yang"
module ietf-trafficselector-types {
 yang-version 1.1;

 namespace
 "urn:ietf:params:xml:ns:yang:ietf-trafficselector-types";

 prefix "traffic-selectors";

 import ietf-inet-types {
   prefix inet;
   revision-date 2013-07-15;
 }

 organization "IETF Distributed Mobility Management (DMM)
 Working Group";

 contact
 "WG Web: <http://tools.ietf.org/wg/netmod/>
 WG List: <mailto:netmod@ietf.org>

 WG Chair: Dapeng Liu
 <mailto:maxpassion@gmail.com>

 WG Chair: Jouni Korhonen
 <mailto:jouni.nospam@gmail.com>

 Editor: Satoru Matsushima
 <mailto:satoru.matsushima@g.softbank.co.jp>

 Editor: Lyle Bertz
 <mailto:lylebe551144@gmail.com>";

 description
 "This module contains a collection of YANG definitions for
 traffic selectors for flow bindings.

 Copyright (c) 2016 IETF Trust and the persons identified as the
 document authors. All rights reserved.

 This document is subject to BCP 78 and the IETF Trust's Legal
 Provisions Relating to IETF Documents
 (http://trustee.ietf.org/license-info) in effect on the date of
 publication of this document. Please review these documents
 carefully, as they describe your rights and restrictions with
 respect to this document. Code Components extracted from this
 document must include Simplified BSD License text as described
 in Section 4.e of the Trust Legal Provisions and are provided
 without warranty as described in the Simplified BSD License.";


  revision 2017-10-29 {
     description "Base Version";
      reference
        "RFC 6088: Traffic Selectors for Flow Bindings";
   }

 // Identities
   identity traffic-selector-format {
     description
     "The base type for Traffic-Selector Formats";
   }

   identity ipv4-binary-selector-format {
     base traffic-selector-format;
     description
       "IPv4 Binary Traffic Selector Format";
   }

   identity ipv6-binary-selector-format {
     base traffic-selector-format;
     description
       "IPv6 Binary Traffic Selector Format";
   }

   // Type definitions and groupings
   typedef ipsec-spi {
     type uint32;
     description
      "The first 32-bit IPsec Security Parameter Index (SPI)
      value on data. This field is defined in [RFC4303].";
       reference
       "RFC 4303: IP Encapsulating Security
       Payload (ESP)";
   }

   grouping traffic-selector-base {
     description "A grouping of the commen leaves between the
       v4 and v6 Traffic Selectors";
     container ipsec-spi-range {
       presence "Enables setting ipsec spi range";
       description
       "Inclusive range representing IPSec Security Parameter
       Indices to be used. When only start-spi is present, it
       represents a single spi.";
   leaf start-spi {
       type ipsec-spi;
       mandatory true;
       description
         "The first 32-bit IPsec SPI value on data.";
       }
   leaf end-spi {
         type ipsec-spi;
         must ". >= ../start-spi" {
           error-message
             "The end-spi must be greater than or equal
              to start-spi";
       }
      description
        "If more than one contiguous SPI value needs to be matched,
        then this field indicates the end value of a range.";
       }
    }
    container source-port-range {
      presence "Enables setting source port range";
      description
       "Inclusive range representing source ports to be used.
        When only start-port is present, it represents a single
     port. These value(s) are from the range of port numbers 
        defined by IANA (http://www.iana.org).";
      leaf start-port {
         type inet:port-number;
         mandatory true;
         description
         "The first 16-bit source port number to be matched";
      }
      leaf end-port {
         type inet:port-number;
         must ". >= ../start-port" {
         error-message
          "The end-port must be greater than or equal to start-port";
        }
        description
         "The last 16-bit source port number to be matched";
       }
    }
    container destination-port-range {
      presence "Enables setting destination port range";
      description
       "Inclusive range representing destination ports to be used.
       When only start-port is present, it represents a single
       port.";
        leaf start-port {
          type inet:port-number;
          mandatory true;
          description
          "The first 16-bit destination port number to be matched";
       }
       leaf end-port {
         type inet:port-number;
         must ". >= ../start-port" {
         error-message
           "The end-port must be greater than or equal to
          start-port";
        }
        description
     "The last 16-bit destination port number to be matched";
     }
   }
 }

 grouping ipv4-binary-traffic-selector {
   container source-address-range-v4 {
      presence "Enables setting source IPv4 address range";
      description
       "Inclusive range representing IPv4 addresses to be used. When
       only start-address is present, it represents a single
       address.";
      leaf start-address {
        type inet:ipv4-address;
        mandatory true;
       description
        "The first source address to be matched";
      }
      leaf end-address {
        type inet:ipv4-address;
        description
         "The last source address to be matched";
       }
   }
   container destination-address-range-v4 {
      presence "Enables setting destination IPv4 address range";
      description
        "Inclusive range representing IPv4 addresses to be used.
        When only start-address is present, it represents a
        single address.";
      leaf start-address {
        type inet:ipv4-address;
        mandatory true;
        description
         "The first destination address to be matched";
      }
      leaf end-address {
        type inet:ipv4-address;
        description
         "The last destination address to be matched";
      }
   }
   container ds-range {
      presence "Enables setting dscp range";
      description
       "Inclusive range representing DiffServ Codepoints to be used.
       When only start-ds is present, it represents a single
       Codepoint.";
      leaf start-ds {
        type inet:dscp;
        mandatory true;
        description
         "The first differential service value to be matched";
    }
    leaf end-ds {
      type inet:dscp;
      must ". >= ../start-ds" {
        error-message
          "The end-ds must be greater than or equal to start-ds";
      }
      description
        "The last differential service value to be matched";
   }
  }
  container protocol-range {
    presence "Enables setting protocol range";
    description
      "Inclusive range representing IP protocol(s) to be used. When
       only start-protocol is present, it represents a single
       protocol.";
    leaf start-protocol {
      type uint8;
      mandatory true;
      description
        "The first 8-bit protocol value to be matched.";
     }
     leaf end-protocol {
       type uint8;
       must ". >= ../start-protocol" {
         error-message
           "The end-protocol must be greater than or equal to
          start-protocol";
       }
     description
       "The last 8-bit protocol value to be matched.";
     }
   }
   description "ipv4 binary traffic selector";
 }
  grouping ipv6-binary-traffic-selector {
   container source-address-range-v6 {
     presence "Enables setting source IPv6 address range";
      description
       "Inclusive range representing IPv6 addresses to be used.
       When only start-address is present, it represents a
       single address.";
      leaf start-address {
        type inet:ipv6-address;
        mandatory true;
        description
        "The first source address, from the
        range of 128-bit IPv6 addresses to be matched";
      }
      leaf end-address {
        type inet:ipv6-address;
        description
            "The last source address, from the
            range of 128-bit IPv6 addresses to be matched";
      }
   }
   container destination-address-range-v6 {
     presence "Enables setting destination IPv6 address range";
     description
       "Inclusive range representing IPv6 addresses to be used.
        When only start-address is present, it represents a
        single address.";
     leaf start-address {
       type inet:ipv6-address;
       mandatory true;
       description
           "The first destination address, from the
           range of 128-bit IPv6 addresses to be matched";
     }
     leaf end-address {
       type inet:ipv6-address;
       description
           "The last destination address, from the
           range of 128-bit IPv6 addresses to be matched";
    }
  }
  container flow-label-range {
    presence "Enables setting Flow Label range";
    description
      "Inclusive range representing IPv4 addresses to be used. When
       only start-flow-label is present, it represents a single
       flow label.";
    leaf start-flow-label {
      type inet:ipv6-flow-label;
      description
        "The first flow label value to be matched";
    }
    leaf end-flow-label {
      type inet:ipv6-flow-label;
      must ". >= ../start-flow-label" {
        error-message
          "The end-flow-lable must be greater than or equal to
           start-flow-label";
      }
      description
         "The first flow label value to be matched";
    }
   }
  container traffic-class-range {
    presence "Enables setting the traffic class range";
    description
     "Inclusive range representing IPv4 addresses to be used. When
      only start-traffic-class is present, it represents a single
      traffic class.";
    leaf start-traffic-class {
      type inet:dscp;
      description
       "The first traffic class value to be matched";
      reference
       "RFC 3260: New Terminology and Clarifications for Diffserv
        RFC 3168: The Addition of Explicit Congestion Notification
        (ECN) to IP";
    }
    leaf end-traffic-class {
      type inet:dscp;
      must ". >= ../start-traffic-class" {
        error-message
          "The end-traffic-class must be greater than or equal to
           start-traffic-class";
      }
      description
        "The last traffic class value to be matched";
    }
  }
  container next-header-range {
    presence "Enables setting Next Header range";
    description
     "Inclusive range representing Next Headers to be used. When
      only start-next-header is present, it represents a
      single Next Header.";
    leaf start-next-header {
      type uint8;
      description
       "The first 8-bit next header value to be matched.";
    }
    leaf end-next-header {
      type uint8;
      must ". >= ../start-next-header" {
        error-message
          "The end-next-header must be greater than or equal to
          start-next-header";
      }
      description
        "The last 8-bit next header value to be matched.";
    }
  }
  description "ipv6 binary traffic selector";
}
  grouping traffic-selector {
    leaf ts-format {
       type identityref {
         base traffic-selector-format;
       }
       description "Traffic Selector Format";
     }
    uses traffic-selector-base;
    uses ipv4-binary-traffic-selector;
    uses ipv6-binary-traffic-selector;
    description
     "The traffic selector includes the parameters used to match
       packets for a specific flow binding.";
    reference
     "RFC 6089: Flow Bindings in Mobile IPv6 and Network
       Mobility (NEMO) Basic Support";
  }

  grouping ts-list {
    list selectors {
      key index;
      leaf index {
        type uint64;
        description "index";
      }
      uses traffic-selector;
      description "traffic selectors";
    }
    description "traffic selector list";
  }
}

<CODE ENDS>]]></artwork>
        </figure>
  </section>
<!-- template for YANG model, end -->
  </section>
  <section anchor="ietf-dmm-fpc-tree" title="FPC YANG Data Model Structure">
    <t>This section only shows the structure for FPC YANG model. NOTE, it does NOT show the settings, Action values or Descriptor Value.</t>
<t>
 <figure anchor="fig-ietf-dmm-fpc-tree"
              title="YANG FPC Agent Tree">
<artwork align="center"><![CDATA[

module: ietf-dmm-fpc
+--rw mobility
   +--rw topology
   |  +--rw dpn-set* [dpn-id]
   |  |  +--rw dpn-id                            fpc:fpc-identity
   |  |  +--rw dpn-name?                         string
   |  |  +--rw dpn-resource-mapping-reference?   string
   |  |  +--rw interface-set* [access-technology role interface-id]
   |  |     +--rw access-technology         identityref
   |  |     +--rw role                      identityref
   |  |     +--rw interface-id              fpc:fpc-interface-id
   |  |     +--rw interface-settings-set
   |  +--rw dpn-type-set* [access-technology role]
   |  |  +--rw access-technology         identityref
   |  |  +--rw access-technology-name?   string
   |  |  +--rw role                      identityref
   |  |  +--rw role-name?                string
   |  |  +--rw interface-set* [interface-id]
   |  |     +--rw interface-id              fpc:fpc-interface-id
   |  |     +--rw interface-name?           string
   |  |     +--rw interface-protocol-set*   identityref
   |  |     +--rw feature-set*              identityref
   |  |     +--rw interface-settings-set
   |  +--rw dpn-group-set* [dpn-group-id]
   |  |  +--rw dpn-group-id           fpc:fpc-identity
   |  |  +--rw referenced-dpns-set* 
                       [access-technology role interface-id]
   |  |  |  +--rw access-technology        identityref
   |  |  |  +--rw role                     identityref
   |  |  |  +--rw interface-id             fpc:fpc-interface-id
   |  |  |  +--rw supporting-dpn-id-set*   fpc:fpc-identity
   |  |  |  +--rw dpn-group-peer-id-set*   fpc:fpc-identity
   |  |  +--rw dpn-group-peer-set* [remote-dpn-group-id]
   |  |  |  +--rw remote-dpn-group-id       fpc:fpc-identity
   |  |  |  +--rw interface-settings-set
   |  |  +--rw domain-id?             fpc:fpc-identity
   |  +--rw domain-set* [domain-id]
   |  |  +--rw domain-id           fpc:fpc-identity
   |  |  +--rw domain-name?        string
   |  |  +--rw domain-reference?   string
   |  +--rw basename?          fpc:fpc-identity
   |  +--rw base-state?        string
   |  +--rw base-checkpoint?   string
   +--rw policy
   |  +--rw action-definition-set* [action-id]
   |  |  +--rw action-id      fpc:fpc-identity
   |  |  +--rw action-type?   identityref
   |  |  +--rw (action-value)?
   |  +--rw descriptor-definition-set* [descriptor-id]
   |  |  +--rw descriptor-id      fpc:fpc-identity
   |  |  +--rw descriptor-type?   identityref
   |  |  +--rw (descriptor-value)?
   |  +--rw rule-definition-set* [rule-id]
   |  |  +--rw rule-id                     fpc:fpc-identity
   |  |  +--rw descriptor-match-type       enumeration
   |  |  +--rw descriptor-reference-set* [descriptor-id-reference]
   |  |  |  +--rw descriptor-id-reference    fpc:fpc-identity
   |  |  |  +--rw direction?                 fpc:fpc-direction-type
   |  |  +--rw action-reference-set* [action-order]
   |  |     +--rw action-order           uint32
   |  |     +--rw action-id-reference    fpc:fpc-identity
   |  +--rw policy-definition-set* [policy-id]
   |  |  +--rw policy-id    fpc:fpc-identity
   |  |  +--rw rule-set* [precedence]
   |  |     +--rw precedence           uint32
   |  |     +--rw rule-id-reference    fpc:fpc-identity
   |  +--rw basename?                    fpc:fpc-identity
   |  +--rw base-state?                  string
   |  +--rw base-checkpoint?             string
   +--rw installed-policy-list* [dpn-id-reference]
   |  +--rw dpn-id-reference        fpc:fpc-identity
   |  +--rw installed-policy-set* [installed-policy-id]
   |  |  +--rw installed-policy-id    fpc:fpc-identity
   |  |  +--rw policy-id-reference?   fpc:fpc-identity
   |  |  +--rw policy-settings
   |  +--rw settings-set
   +--ro mobility-context-set* [mobility-context-id]
   |  +--ro mobility-context-id                     fpc:fpc-identity
   |  +--ro dpn-group-id-reference?                 fpc:fpc-identity
   |  +--ro parent-mobility-context-id-reference?   fpc:fpc-identity
   |  +--ro dpn-reference-list* [dpn-id-reference direction]
   |  |  +--ro dpn-id-reference                 fpc:fpc-identity
   |  |  +--ro direction                        
                                  fpc:fpc-direction-type
   |  |  +--ro dpn-settings-complementary
   |  |  +--ro interface-id-reference           fpc:fpc-interface-id
   |  |  +--ro embedded-rule-set* [precedence]
   |  |  |  +--ro rule-id                      fpc:fpc-identity
   |  |  |  +--ro descriptor-match-type        enumeration
   |  |  |  +--ro precedence                   uint32
   |  |  |  +--ro action-definition-set* [action-order]
   |  |  |  |  +--ro action-order    uint32
   |  |  |  |  +--ro action-id?      fpc:fpc-identity
   |  |  |  |  +--ro action-type?    identityref
   |  |  |  |  +--ro (action-value)?
   |  |  |  +--ro descriptor-definition-set* [descriptor-id]
   |  |  |     +--ro descriptor-id      fpc:fpc-identity
   |  |  |     +--ro descriptor-type?   identityref
   |  |  |     +--ro (descriptor-value)?
   |  |  +--ro assigned-policy-reference-set*   fpc:fpc-identity
   |  +--ro requested-policy-reference-set*         fpc:fpc-identity
   |  +--ro context-settings-complementary
   +--rw monitor-set* [monitor-id]
      +--rw monitor-id             fpc:fpc-identity
      +--rw deterrable?            boolean
      +--rw binding-information
      +--rw target                 fpc-identity
      +--rw (configuration)
         +--:(periodic-config)
         |  +--rw period?                uint32
         +--:(threshold-config)
         |  +--rw lo-thresh?             uint32
         |  +--rw hi-thresh?             uint32
         +--:(scheduled-config)
         |  +--rw report-time?           uint32
         +--:(events-config-ident)
         |  +--rw event-identities*      identityref
         +--:(events-config)
            +--rw event-ids*             uint32
     ]]></artwork>
        <postamble></postamble>
      </figure>
</t>
  </section>
</section>
  </back>
</rfc>
